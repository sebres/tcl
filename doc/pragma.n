'\"
'\" Copyright (c) 2018 Donal K. Fellows
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\"
.TH pragma n 8.7 Tcl "Tcl Built-In Commands"
.so man.macros
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
tcl::pragma \- directives to assist efficient execution
.SH SYNOPSIS
.nf
\fBtcl::pragma noalias\fR ?\fIvariableSet ...\fR?
\fBtcl::pragma type \fItypeName\fR ?\fIvalue ...\fR?
.fi
.SH DESCRIPTION
The \fBtcl::pragma\fR command provides directives that can aid efficient
execution and compilation strategies for Tcl scripts, while also providing
meaningful execution models for those directives. It produces no output on
successful execution, and an error if a problem is detected. It supports two
subcommands:
.TP
\fBtcl::pragma noalias\fR ?\fIvariableSet ...\fR?
.
This subcommand takes an arbitrary number of variable sets, \fIvariableSet\fR,
etc., and checks to see if they alias each other. Each variable set is a list
of variable names, and two variable names in a variable set alias if they
resolve to the same variable storage (i.e., after allowing for any variable
resolution rules, any use of \fBglobal\fR or \fBupvar\fR, any
namespace-qualification, etc.) If any variable names in a variable set
indicate the same storage space, this command will produce an error. Only
existing variables can be checked this way.
.RS
.PP
This command takes multiple variable sets. Each variable set is checked
independently.
.RE
.TP
\fBtcl::pragma type \fItypeName\fR ?\fIvalue ...\fR?
.
This subcommand takes a value type, \fItypeName\fR, and throws an error if any
of the arbitrary number of \fIvalue\fRs are not of that type. Supported
\fItypeName\fRs are:
.RS
.TP
\fBboolean\fR
.
This indicates the type of values accepted by \fBTcl_GetBooleanFromObj\fR.
.TP
\fBdict\fR
.
This indicates the type of values accepted by \fBTcl_DictObjSize\fR.
.TP
\fBdouble\fR
.
This indicates the type of values accepted by \fBTcl_GetDoubleFromObj\fR.
.TP
\fBint64\fR
.
This indicates the type of values accepted by \fBTcl_GetWideIntFromObj\fR.
.TP
\fBinteger\fR
.
This indicates the type of any value accepted as an integer, without length
restriction. This is the type of values accepted by integer-accepting
\fBexpr\fR operators, such as the \fB&\fR operator or the left side of the
\fB<<\fR operator.
.TP
\fBlist\fR
.
This indicates the type of values accepted by \fBTcl_ListObjLength\fR.
.TP
\fBnumber\fR
.
This indicates the type of any value accepted as a number, without length
restriction. This is the type of values accepted by \fBexpr\fR operators such
as \fB+\fR or \fB*\fR.
.RE
.SH EXAMPLES
.PP
This shows how a procedure could declare that it only operates on integers:
.PP
.CS
proc addThreeIntegers {a b c} {
    \fBtcl::pragma type\fR integer $a $b $c
    return [expr {$a + $b + $c}]
}
.CE
.PP
This shows how a procedure could declare that two variables passed in by
name/\fBupvar\fR must be distinct from each other.
.PP
.CS
proc swap {v1Name v2Name} {
    upvar 1 $v1Name v1 $v2Name v2
    \fBtcl::pragma noalias\fR {v1 v2}
    set tmp $v2
    set v2 $v1
    set v1 $tmp
    return
}
.CE
.SH "SEE ALSO"
dict(n), global(n), list(n), string(n), upvar(n)
.SH KEYWORDS
compilation, variables, types
.\" Local variables:
.\" mode: nroff
.\" fill-column: 78
.\" End:
