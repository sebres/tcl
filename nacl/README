
		NaTcl : Tcl in Nacl


Overview
--------

NaCl == Native Client is Google's neat sandboxing technology, allowing
to  run  untrusted  code  compiled  natively,  in  the  context  of  a
browser. See http://code.google.com/p/nativeclient/.

The idea  is that with Tcl  running in this context,  and a supporting
browser (currently,  Chrome only; possibly FF +  Nacl plugin shortly),
one could  develop client-side  code mainly in  Tcl, with a  very thin
layer of JS in the page; so, basically, Tcl to control the HTML5 DOM !

Building Tcl for Nacl
---------------------

 - install the NaCl SDK (for me native_client_sdk_0_1_721_0)

 - set your PATH so that nacl-gcc et al become reachable

 - untar the present archive as an 'nacl' subdir in a Tcl source tree,
   as a sibling of 'unix"

 - cd inside it

 - run './configure' (which calls ../unix/configure with proper flags,
   and patches the generated Makefile)

 - run 'make'. This creates tcl.nmf and tcl.nexe (for x86-32)

 - launch the  NaCl-provided python-based  webserver, and make  it see
   your nacl dir somewhere in its document tree. e.g. 
   cd $NACL/examples; ln -s /..../tcl/nacl nacl; python httpd.py 5103

 - (once) open about:flags in Chrome and enable Native Client

 - start   '(cd  tools;./chromedebug)',  and   point  Chrome   to  the
   index.html in nacl. e.g. chromedebug http://localhost:5103/nacl.

 - alternatively, use './chrd' to load the 'balls' demo.

 - (every  time)  make  sure  no  non-chromedebug  chrome  process  is
   running, otherwise it  will be used instead, and  NaCl will fail to
   load. Also, when you update or tweak anything, it is a good idea to
   flush your browser's cache !

 - note:  'chromedebug' just  sets an  env  var for  debug output  (on
   stderr), and  stars chrome with '--no-sandbox',  which is currently
   needed for NaCl to be really enabled on Linux.

Overview of the porting method
------------------------------

Nacl  comes with  a  very incomplete  libc  and set  of headers.   The
strategy,  then,  is to  simply  "plug"  missing  syscalls or  library
functions with either explicitly  failing stubs (returning -1 or NULL,
and  setting errno)  or emulators,  and to  build a  big  include file
(naclcompat.h) with  all the necessary  type and macro  definitions to
compile.
 
Of course,  when one  of the  failing stubs is  called at  runtime, an
error is raised.  But one cannot hope much more, it's  a sandbox for a
reason.

This approach allows to compile Tcl for Nacl without changing a single
line of the original source distribution; all new things are in the
nacl subdir. Also, much is reused from ../unix.

Nacl context specifics
----------------------

One thing to keep in mind is  that NaCl lets us run in our sandbox, in
a  dedicated process, but  at the  time of  writing, it  is in  a very
synchronous  "lockstep"  interaction with  the  main renderer  process
executing  JS  code.  A  more  async  API  allowing  us  to  be  in  a
free-floating thread and exchanging messages  with JS is in the works,
but not baked yet.

Given  this,  NaTcl  simply   obeys  the  rules  of  the  synchronous,
event-driven  world of JS:  do everything  in quickly  returning event
callbacks,  never stick  for too  long.  Note that  most Tcl/Tk  users
should feel at  home, since it is exactly the  recipe for a responsive
Tk GUI.

For maximal genericity, the way NaTcl "retroacts" on the JS context is
by returning a JS string to eval(). Then you can do whatever you want,
including of course  arranging for future JS events  to call back into
NaTcl. See [domset] and [after] (in init.natcl, which is compiled into
the binray .nexe) as two very simple examples.

In   an  universe   without   syscalls,  loading   other  scripts   is
problematic. To circumvent this (and bootstrap the loading of the main
script), [source $url] is  reimplemented over a JS XmlHttpRequest. And
to preserve  the blocking semantics of traditional  [source] while XHR
is purely  async, this implementation is coro-based  and calls [yield]
after starting the request. When the download completes, JS calls back
into Tcl to resume the  coro, and continue the sequential execution of
the Tcl  script where  it left. This  allows for arbitrary  series and
nesting of [source].

For this reason, the main script is bootstrapped by evaluating:

     coroutine main_coro source $url

This means that all  the init code in the script will  run in the coro
context (for [source]'s  benefit, but that could be  extended to other
things).  But once  the  execution has  fallen  back out  of the  main
script, hopefully after setting up  many (JS) event handlers, it is up
to the app to establish other coro contexts if needed.

The bottom line is this:

   - a simple,  ol'good-Tk-style event-driven script will  not have to
     bother about coros

   - a more  advanced, coro-savvy script  can use coros to  do lengthy
     things (be they computations  of network downloads) while leaving
     the GUI responsive

   - in all cases, [source] works  as usual to fetch scripts over HTTP
     (in   the   same  domain   as   the   page   serving  the   NaTcl
     plugin). Relative URLs work: [source foo.natcl].

   - in all cases, falling back  out of the main scripts is equivalent
     to going  back to the Tk eventloop  in wish (except it  is the JS
     eventloop).


The "Google Balls" demo
-----------------------

If you point your chrome to "balls.html" (eg with chrd), you'll get a
full NaTcl emulation of the nice Javascript demo at:

 http://www.html5canvastutorials.com/labs/html5-canvas-google-bouncing-balls

This uses a canvas emulation script "canv.natcl", which demonstrates a
possible  (among  many)  way  of  organizing  Tcl-JS  interaction  for
graphics.  In the balls demo,  items are never destroyed nor shuffled,
which is  a favourable case for  lazy recompilation of  the JS repaint
function (basically the func is written just once, and only the coords
stored in a global array get updated, hence allowing for JIT compiling
of this function).

Perf measurements: the NaTcl version currently costs 3x the CPU of the
JS version,  so at  40fps it consumes  a full  core of my  2GHz laptop
(against 33% for the JS one). 

One should  note that the pure  string API used precludes  any used of
the  internal reps of  coordinates, so  there are  many string/integer
conversions. To be continued.

Future work
-----------

 Coming soon: [domget], more [canvas] features, and optimizations ;-)

