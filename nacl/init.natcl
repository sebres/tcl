#------ Standard NaTcl preamble

namespace eval ::nacl {
    variable verbose 0

    # core JS/Tcl interaction
    proc jsquote s {
        regsub -all {[''\\]} $s {\\&} s
        regsub -all \n $s {'+"\\n"+'} s
        return '${s}'
    }

    # hook - append Tcl hooks to be evaluated per ???
    variable hooks {}
    proc hook {args} {
        variable hooks
        lappend hooks {*}$args
    }

    # js - append javascript to be evaluated in nacl
    # as a result of currently evaluating Tcl script
    variable JS {}	;# accumulation of javascript to evaluate
    proc js {args} {
        variable JS
        append JS [join $args \;\n] \n
    }

    variable defaults {}
    proc opts {args} {
	set type ""
	if {[llength $args]%2} {
	    set args [lassign $args type]
	}

	set opts {}
	variable defaults
	if {$type ne "" && [dict exists $defaults $type]} {
	    set args [list {*}[dict get $defaults $type] {*}$args]
	}
	dict for {n v} $args {
	    if {$v eq ""} {
		set v "''"	;# ensure we don't send naked names
	    }
	    lappend opts "$n:$v"
	}

	if {$opts eq ""} {
	    return ""
	} else {
	    return "\{[join $opts ,]\}"
	}
    }

    proc alert {args} {
        js "alert([::nacl::jsquote [join $args]])"
    }

    proc bgerror {args} {
        printf "### BGERROR: [join $args]\n# [info errorstack]"
        js "alert([::nacl::jsquote [join $args]])"
    }

    proc wrap {s} {
        variable hooks
        if {[catch {
            uplevel #0 $s
            foreach x $hooks {uplevel #0 $x}
        } err eo]} {
            bgerror "$err ($eo)"
        }

        variable JS; set toJS $JS; set JS ""
        return $toJS
    }

    # evall - evaluate a list as a command
    # returns javascript to evaluate in nacl
    proc evall {args} {
        variable hooks
        if {[catch {
            uplevel #0 $args
            foreach x $hooks {uplevel #0 $x}
        } err eo]} {
            bgerror "$err ($eo)"
        }

        variable JS; set toJS $JS; set JS ""
        return $toJS
    }

    # start - natcl module has been loaded with the following args
    proc start {args} {
        set defaults {
            verbose 0
            script script
            toplevel toplevel
        }
        set ::argv [dict merge $defaults $args]
        if {[dict exists $args verbose]} {
            variable verbose [dict get $args verbose]
        }
    }

    namespace export -clear *
    namespace ensemble create -subcommands {}
}

namespace eval ::dom {
    # Delayed DOM-setting through the tclDo() trampoline
    proc put {element inner} {
        nacl js "$element.innerHTML=[nacl jsquote $inner]"
    }

    # get - get element's innerHTML and pass it to callback
    proc get {element args} {
        if {![llength $args]} {
            set args [info coroutine]
        }
        nacl js "tcl('[join $args "', '"]', '{'+$element.innerHTML+'}')"
    }

    namespace export -clear *
    namespace ensemble create -subcommands {}
}

# Coro-based [source] necessary for bootstrapping
proc ::source {url} {
    nacl js "tclsource([::nacl::jsquote $url],[::nacl::jsquote [info coroutine]])"
    set x [yield]
    uplevel #0 $x
}

# Async [after] using JS's setTimeout()
proc ::after {ms script} {
    nacl js "setTimeout(function(){tclDo([::nacl::jsquote $script]);},$ms)"
}

# Async [every] using JS's setInterval()
proc ::every {ms script} {
    nacl js "setInterval(function(){tclDo([::nacl::jsquote $script]);},$ms)"
}

# Delayed DOM-setting through the tclDo() trampoline
proc ::domset {element inner} {
    nacl js "$element.innerHTML=[::nacl::jsquote $inner]"
}

proc tclInit {} {
        printf "### tclInit called"
}
