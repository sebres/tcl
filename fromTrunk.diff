DELETED  ChangeLog
ADDED    README.mig-alloc-reform
DELETED  generic/tclAlloc.c
DELETED  generic/tclAssembly.c
Index: generic/tclBasic.c
==================================================================
--- generic/tclBasic.c
+++ generic/tclBasic.c
@@ -81,19 +81,15 @@
  * are used to save the evaluation state between NR calls to each coro.
  */
 
 #define SAVE_CONTEXT(context)				\
     (context).framePtr = iPtr->framePtr;		\
-    (context).varFramePtr = iPtr->varFramePtr;		\
-    (context).cmdFramePtr = iPtr->cmdFramePtr;		\
-    (context).lineLABCPtr = iPtr->lineLABCPtr
+    (context).varFramePtr = iPtr->varFramePtr
 
 #define RESTORE_CONTEXT(context)			\
     iPtr->framePtr = (context).framePtr;		\
-    iPtr->varFramePtr = (context).varFramePtr;		\
-    iPtr->cmdFramePtr = (context).cmdFramePtr;		\
-    iPtr->lineLABCPtr = (context).lineLABCPtr
+    iPtr->varFramePtr = (context).varFramePtr
 
 /*
  * Static functions in this file:
  */
 
@@ -165,10 +161,35 @@
 static void	        ClearTailcall(Tcl_Interp *interp,
 			    struct NRE_callback *tailcallPtr);
 static Tcl_ObjCmdProc NRCoroInjectObjCmd;
 
 MODULE_SCOPE const TclStubs tclStubs;
+
+static void UpdateStringOfScriptSource(Tcl_Obj *objPtr);
+
+static const Tcl_ObjType scriptSourceType = {
+    "scriptSource",			/* name */
+    NULL,			/* freeIntRepProc */
+    NULL,			/* dupIntRepProc */
+    UpdateStringOfScriptSource,	/* updateStringProc */
+    NULL			/* setFromAnyProc */
+};
+
+static void
+UpdateStringOfScriptSource(
+    Tcl_Obj *objPtr)
+{
+    const char *bytes = objPtr->internalRep.twoPtrValue.ptr1;
+    int len = PTR2INT(objPtr->internalRep.twoPtrValue.ptr2);
+
+    if (bytes) {
+	objPtr->bytes = (char *) ckalloc((unsigned) len + 1);
+	memcpy(objPtr->bytes, bytes, len);
+        objPtr->bytes[len] = '\0';
+	objPtr->length = len;
+    }
+}
 
 /*
  * Magical counts for the number of arguments accepted by a coroutine command
  * after particular kinds of [yield].
  */
@@ -515,26 +536,10 @@
     iPtr->numLevels = 0;
     iPtr->maxNestingDepth = MAX_NESTING_DEPTH;
     iPtr->framePtr = NULL;	/* Initialise as soon as :: is available */
     iPtr->varFramePtr = NULL;	/* Initialise as soon as :: is available */
 
-    /*
-     * TIP #280 - Initialize the arrays used to extend the ByteCode and Proc
-     * structures.
-     */
-
-    iPtr->cmdFramePtr = NULL;
-    iPtr->linePBodyPtr = ckalloc(sizeof(Tcl_HashTable));
-    iPtr->lineBCPtr = ckalloc(sizeof(Tcl_HashTable));
-    iPtr->lineLAPtr = ckalloc(sizeof(Tcl_HashTable));
-    iPtr->lineLABCPtr = ckalloc(sizeof(Tcl_HashTable));
-    Tcl_InitHashTable(iPtr->linePBodyPtr, TCL_ONE_WORD_KEYS);
-    Tcl_InitHashTable(iPtr->lineBCPtr, TCL_ONE_WORD_KEYS);
-    Tcl_InitHashTable(iPtr->lineLAPtr, TCL_ONE_WORD_KEYS);
-    Tcl_InitHashTable(iPtr->lineLABCPtr, TCL_ONE_WORD_KEYS);
-    iPtr->scriptCLLocPtr = NULL;
-
     iPtr->activeVarTracePtr = NULL;
 
     iPtr->returnOpts = NULL;
     iPtr->errorInfo = NULL;
     TclNewLiteralStringObj(iPtr->eiVar, "::errorInfo");
@@ -726,19 +731,16 @@
     /*
      * Initialise the thread-specific data ekeko. Note that the thread's alloc
      * cache was already initialised by the call to alloc the interp struct.
      */
 
-#if defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
-    iPtr->allocCache = TclpGetAllocCache();
-#else
-    iPtr->allocCache = NULL;
-#endif
-    iPtr->pendingObjDataPtr = NULL;
     iPtr->asyncReadyPtr = TclGetAsyncReadyPtr();
     iPtr->deferredCallbacks = NULL;
 
+    iPtr->cmdSourcePtr = Tcl_NewObj();
+    TclInvalidateStringRep(iPtr->cmdSourcePtr);
+
     /*
      * Create the core commands. Do it here, rather than calling
      * Tcl_CreateCommand, because it's faster (there's no need to check for a
      * pre-existing command by the same name). If a command has a Tcl_CmdProc
      * but no Tcl_ObjCmdProc, set the Tcl_ObjCmdProc to
@@ -822,16 +824,10 @@
     Tcl_CreateObjCommand(interp, "::tcl::unsupported::disassemble",
 	    Tcl_DisassembleObjCmd, NULL, NULL);
     Tcl_CreateObjCommand(interp, "::tcl::unsupported::representation",
 	    Tcl_RepresentationCmd, NULL, NULL);
 
-    /* Adding the bytecode assembler command */
-    cmdPtr = (Command *) Tcl_NRCreateCommand(interp,
-            "::tcl::unsupported::assemble", Tcl_AssembleObjCmd,
-            TclNRAssembleObjCmd, NULL, NULL);
-    cmdPtr->compileProc = &TclCompileAssembleCmd;
-
     Tcl_NRCreateCommand(interp, "::tcl::unsupported::inject", NULL,
 	    NRCoroInjectObjCmd, NULL, NULL);
 
 #ifdef USE_DTRACE
     /*
@@ -1346,11 +1342,10 @@
     Interp *iPtr = (Interp *) interp;
     Tcl_HashEntry *hPtr;
     Tcl_HashSearch search;
     Tcl_HashTable *hTablePtr;
     ResolverScheme *resPtr, *nextResPtr;
-    int i;
 
     /*
      * Punt if there is an error in the Tcl_Release/Tcl_Preserve matchup,
 	 * unless we are exiting.
      */
@@ -1545,103 +1540,19 @@
      * interpreter.
      */
 
     TclDeleteLiteralTable(interp, &iPtr->literalTable);
 
-    /*
-     * TIP #280 - Release the arrays for ByteCode/Proc extension, and
-     * contents.
-     */
-
-    for (hPtr = Tcl_FirstHashEntry(iPtr->linePBodyPtr, &search);
-	    hPtr != NULL;
-	    hPtr = Tcl_NextHashEntry(&search)) {
-	CmdFrame *cfPtr = Tcl_GetHashValue(hPtr);
-	Proc *procPtr = (Proc *) Tcl_GetHashKey(iPtr->linePBodyPtr, hPtr);
-
-	procPtr->iPtr = NULL;
-	if (cfPtr) {
-	    if (cfPtr->type == TCL_LOCATION_SOURCE) {
-		Tcl_DecrRefCount(cfPtr->data.eval.path);
-	    }
-	    ckfree(cfPtr->line);
-	    ckfree(cfPtr);
-	}
-	Tcl_DeleteHashEntry(hPtr);
-    }
-    Tcl_DeleteHashTable(iPtr->linePBodyPtr);
-    ckfree(iPtr->linePBodyPtr);
-    iPtr->linePBodyPtr = NULL;
-
-    /*
-     * See also tclCompile.c, TclCleanupByteCode
-     */
-
-    for (hPtr = Tcl_FirstHashEntry(iPtr->lineBCPtr, &search);
-	    hPtr != NULL;
-	    hPtr = Tcl_NextHashEntry(&search)) {
-	ExtCmdLoc *eclPtr = Tcl_GetHashValue(hPtr);
-
-	if (eclPtr->type == TCL_LOCATION_SOURCE) {
-	    Tcl_DecrRefCount(eclPtr->path);
-	}
-	for (i=0; i< eclPtr->nuloc; i++) {
-	    ckfree(eclPtr->loc[i].line);
-	}
-
-	if (eclPtr->loc != NULL) {
-	    ckfree(eclPtr->loc);
-	}
-
-	Tcl_DeleteHashTable(&eclPtr->litInfo);
-
-	ckfree(eclPtr);
-	Tcl_DeleteHashEntry(hPtr);
-    }
-    Tcl_DeleteHashTable(iPtr->lineBCPtr);
-    ckfree(iPtr->lineBCPtr);
-    iPtr->lineBCPtr = NULL;
-
-    /*
-     * Location stack for uplevel/eval/... scripts which were passed through
-     * proc arguments. Actually we track all arguments as we do not and cannot
-     * know which arguments will be used as scripts and which will not.
-     */
-
-    if (iPtr->lineLAPtr->numEntries && !TclInExit()) {
-	/*
-	 * When the interp goes away we have nothing on the stack, so there
-	 * are no arguments, so this table has to be empty.
-	 */
-
-	Tcl_Panic("Argument location tracking table not empty");
-    }
-
-    Tcl_DeleteHashTable(iPtr->lineLAPtr);
-    ckfree((char *) iPtr->lineLAPtr);
-    iPtr->lineLAPtr = NULL;
-
-    if (iPtr->lineLABCPtr->numEntries && !TclInExit()) {
-	/*
-	 * When the interp goes away we have nothing on the stack, so there
-	 * are no arguments, so this table has to be empty.
-	 */
-
-	Tcl_Panic("Argument location tracking table not empty");
-    }
-
-    Tcl_DeleteHashTable(iPtr->lineLABCPtr);
-    ckfree(iPtr->lineLABCPtr);
-    iPtr->lineLABCPtr = NULL;
-
     /*
      * Squelch the tables of traces on variables and searches over arrays in
      * the in the interpreter.
      */
 
     Tcl_DeleteHashTable(&iPtr->varTraces);
     Tcl_DeleteHashTable(&iPtr->varSearches);
+
+    Tcl_DecrRefCount(iPtr->cmdSourcePtr);
 
     ckfree(iPtr);
 }
 
 /*
@@ -2359,12 +2270,11 @@
     register int objc,		/* Number of arguments. */
     Tcl_Obj *const objv[])	/* Argument objects. */
 {
     Command *cmdPtr = clientData;
     int i, result;
-    const char **argv =
-	    TclStackAlloc(interp, (unsigned)(objc + 1) * sizeof(char *));
+    const char **argv = ckalloc((unsigned)(objc + 1) * sizeof(char *));
 
     for (i = 0; i < objc; i++) {
 	argv[i] = Tcl_GetString(objv[i]);
     }
     argv[objc] = 0;
@@ -2373,11 +2283,11 @@
      * Invoke the command's string-based Tcl_CmdProc.
      */
 
     result = cmdPtr->proc(cmdPtr->clientData, interp, objc, argv);
 
-    TclStackFree(interp, (void *) argv);
+    ckfree((void *) argv);
     return result;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -2408,12 +2318,11 @@
     register const char **argv)	/* Argument strings. */
 {
     Command *cmdPtr = clientData;
     Tcl_Obj *objPtr;
     int i, length, result;
-    Tcl_Obj **objv =
-	    TclStackAlloc(interp, (unsigned)(argc * sizeof(Tcl_Obj *)));
+    Tcl_Obj **objv = ckalloc((unsigned)(argc * sizeof(Tcl_Obj *)));
 
     for (i = 0; i < argc; i++) {
 	length = strlen(argv[i]);
 	TclNewStringObj(objPtr, argv[i], length);
 	Tcl_IncrRefCount(objPtr);
@@ -2445,11 +2354,11 @@
 
     for (i = 0; i < argc; i++) {
 	objPtr = objv[i];
 	Tcl_DecrRefCount(objPtr);
     }
-    TclStackFree(interp, objv);
+    ckfree(objv);
     return result;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -3360,38 +3269,30 @@
     Interp *iPtr,
     int objc,
     Tcl_Obj *const objv[],
     int lookup)
 {
-    Tcl_Obj *objPtr, *obj2Ptr;
-    CmdFrame *cfPtr = iPtr->cmdFramePtr;
-    const char *command = NULL;
-    int numChars;
-
-    objPtr = Tcl_NewListObj(objc, objv);
-    if (lookup && cfPtr && (cfPtr->numLevels == iPtr->numLevels-1)) {
-	switch (cfPtr->type) {
-	case TCL_LOCATION_EVAL:
-	case TCL_LOCATION_SOURCE:
-	    command = cfPtr->cmd.str.cmd;
-	    numChars = cfPtr->cmd.str.len;
-	    break;
-	case TCL_LOCATION_BC:
-	case TCL_LOCATION_PREBC:
-	    command = TclGetSrcInfoForCmd(iPtr, &numChars);
-	    break;
-	case TCL_LOCATION_EVAL_LIST:
-	    /* Got it already */
-	    break;
-	}
-	if (command) {
-	    obj2Ptr = Tcl_NewStringObj(command, numChars);
-	    objPtr->bytes = obj2Ptr->bytes;
-	    objPtr->length = numChars;
-	    obj2Ptr->bytes = NULL;
-	    Tcl_DecrRefCount(obj2Ptr);
-	}
+    Tcl_Obj *objPtr = Tcl_NewListObj(objc, objv);
+
+    if (iPtr->cmdSourcePtr->typePtr) {
+        char *command;
+        int len;
+        char *orig = iPtr->cmdSourcePtr->bytes;
+
+        command = Tcl_GetStringFromObj(iPtr->cmdSourcePtr, &len);
+        objPtr->bytes = (char *) ckalloc((unsigned) len + 1);
+        strcpy(objPtr->bytes, command);
+        objPtr->length = len;
+
+        /*
+         * Avoid leaving a string rep if none was there.
+         */
+
+        if (orig == NULL) {
+            TclInvalidateStringRep(iPtr->cmdSourcePtr);
+        }
+        
     }
     Tcl_IncrRefCount(objPtr);
     return objPtr;
 }
 
@@ -4256,11 +4157,12 @@
 	}
 	if (result != TCL_OK) {
 	    return result;
 	}
     }
-
+    iPtr->cmdSourcePtr->bytes = NULL;
+    iPtr->cmdSourcePtr->typePtr = NULL;
 
 #ifdef USE_DTRACE
     if (TCL_DTRACE_CMD_ARGS_ENABLED()) {
 	const char *a[10];
 	int i = 0;
@@ -4269,18 +4171,10 @@
 	    a[i] = i < objc ? TclGetString(objv[i]) : NULL; i++;
 	}
 	TCL_DTRACE_CMD_ARGS(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7],
 		a[8], a[9]);
     }
-    if (TCL_DTRACE_CMD_INFO_ENABLED() && iPtr->cmdFramePtr) {
-	Tcl_Obj *info = TclInfoFrame(interp, iPtr->cmdFramePtr);
-	const char *a[6]; int i[2];
-
-	TclDTraceInfo(info, a, i);
-	TCL_DTRACE_CMD_INFO(a[0], a[1], a[2], a[3], i[0], i[1], a[4], a[5]);
-	TclDecrRefCount(info);
-    }
     if (TCL_DTRACE_CMD_RETURN_ENABLED() || TCL_DTRACE_CMD_RESULT_ENABLED()) {
 	TclNRAddCallback(interp, DTraceCmdReturn, objv[0], NULL, NULL, NULL);
     }
     if (TCL_DTRACE_CMD_ENTRY_ENABLED()) {
 	TCL_DTRACE_CMD_ENTRY(TclGetString(objv[0]), objc - 1,
@@ -4576,11 +4470,11 @@
      */
 
     Tcl_ListObjGetElements(NULL, currNsPtr->unknownHandlerPtr,
 	    &handlerObjc, &handlerObjv);
     newObjc = objc + handlerObjc;
-    newObjv = TclStackAlloc(interp, (int) sizeof(Tcl_Obj *) * newObjc);
+    newObjv = ckalloc((int) sizeof(Tcl_Obj *) * newObjc);
 
     /*
      * Copy command prefix from unknown handler and add on the real command's
      * full argument list. Note that we only use memcpy() once because we have
      * to increment the reference count of all the handler arguments anyway.
@@ -4615,11 +4509,11 @@
 	 */
 
 	for (i = 0; i < handlerObjc; ++i) {
 	    Tcl_DecrRefCount(newObjv[i]);
 	}
-	TclStackFree(interp, newObjv);
+	ckfree(newObjv);
 	return TCL_ERROR;
     }
 
     if (lookupNsPtr) {
 	savedNsPtr = varFramePtr->nsPtr;
@@ -4653,11 +4547,11 @@
      */
 
     for (i = 0; i < objc; ++i) {
 	Tcl_DecrRefCount(objv[i]);
     }
-    TclStackFree(interp, objv);
+    ckfree(objv);
 
     return result;
 }
 
 static int
@@ -4816,12 +4710,11 @@
     Tcl_Token *tokenPtr,	/* Pointer to first in an array of tokens to
 				 * evaluate and concatenate. */
     int count)			/* Number of tokens to consider at tokenPtr.
 				 * Must be at least 1. */
 {
-    return TclSubstTokens(interp, tokenPtr, count, /* numLeftPtr */ NULL, 1,
-	    NULL, NULL);
+    return TclSubstTokens(interp, tokenPtr, count, /* numLeftPtr */ NULL);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -4885,11 +4778,10 @@
  *	TCL_ERROR. A result or error message is left in interp's result.
  *
  * Side effects:
  *	Depends on the script.
  *
- * TIP #280 : Keep public API, internally extended API.
  *----------------------------------------------------------------------
  */
 
 int
 Tcl_EvalEx(
@@ -4901,48 +4793,15 @@
 				 * first null character. */
     int flags)			/* Collection of OR-ed bits that control the
 				 * evaluation of the script. Only
 				 * TCL_EVAL_GLOBAL is currently supported. */
 {
-    return TclEvalEx(interp, script, numBytes, flags, 1, NULL, script);
-}
-
-int
-TclEvalEx(
-    Tcl_Interp *interp,		/* Interpreter in which to evaluate the
-				 * script. Also used for error reporting. */
-    const char *script,		/* First character of script to evaluate. */
-    int numBytes,		/* Number of bytes in script. If < 0, the
-				 * script consists of all bytes up to the
-				 * first NUL character. */
-    int flags,			/* Collection of OR-ed bits that control the
-				 * evaluation of the script. Only
-				 * TCL_EVAL_GLOBAL is currently supported. */
-    int line,			/* The line the script starts on. */
-    int *clNextOuter,		/* Information about an outer context for */
-    const char *outerScript)	/* continuation line data. This is set only in
-				 * TclSubstTokens(), to properly handle
-				 * [...]-nested commands. The 'outerScript'
-				 * refers to the most-outer script containing
-				 * the embedded command, which is refered to
-				 * by 'script'. The 'clNextOuter' refers to
-				 * the current entry in the table of
-				 * continuation lines in this "master script",
-				 * and the character offsets are relative to
-				 * the 'outerScript' as well.
-				 *
-				 * If outerScript == script, then this call is
-				 * for the outer-most script/command. See
-				 * Tcl_EvalEx() and TclEvalObjEx() for places
-				 * generating arguments for which this is
-				 * true. */
-{
     Interp *iPtr = (Interp *) interp;
     const char *p, *next;
     const unsigned int minObjs = 20;
     Tcl_Obj **objv, **objvSpace;
-    int *expand, *lines, *lineSpace;
+    int *expand;
     Tcl_Token *tokenPtr;
     int commandLength, bytesLeft, expandRequested, code = TCL_OK;
     CallFrame *savedVarFramePtr;/* Saves old copy of iPtr->varFramePtr in case
 				 * TCL_EVAL_GLOBAL was set. */
     int allowExceptions = (iPtr->evalFlags & TCL_ALLOW_EXCEPTIONS);
@@ -4950,33 +4809,14 @@
     unsigned int i, objectsUsed = 0;
 				/* These variables keep track of how much
 				 * state has been allocated while evaluating
 				 * the script, so that it can be freed
 				 * properly if an error occurs. */
-    Tcl_Parse *parsePtr = TclStackAlloc(interp, sizeof(Tcl_Parse));
-    CmdFrame *eeFramePtr = TclStackAlloc(interp, sizeof(CmdFrame));
+    Tcl_Parse *parsePtr = ckalloc(sizeof(Tcl_Parse));
     Tcl_Obj **stackObjArray =
-	    TclStackAlloc(interp, minObjs * sizeof(Tcl_Obj *));
-    int *expandStack = TclStackAlloc(interp, minObjs * sizeof(int));
-    int *linesStack = TclStackAlloc(interp, minObjs * sizeof(int));
-				/* TIP #280 Structures for tracking of command
-				 * locations. */
-    int *clNext = NULL;		/* Pointer for the tracking of invisible
-				 * continuation lines. Initialized only if the
-				 * caller gave us a table of locations to
-				 * track, via scriptCLLocPtr. It always refers
-				 * to the table entry holding the location of
-				 * the next invisible continuation line to
-				 * look for, while parsing the script. */
-
-    if (iPtr->scriptCLLocPtr) {
-	if (clNextOuter) {
-	    clNext = clNextOuter;
-	} else {
-	    clNext = &iPtr->scriptCLLocPtr->loc[0];
-	}
-    }
+	    ckalloc(minObjs * sizeof(Tcl_Obj *));
+    int *expandStack = ckalloc(minObjs * sizeof(int));
 
     if (numBytes < 0) {
 	numBytes = strlen(script);
     }
     Tcl_ResetResult(interp);
@@ -4990,110 +4830,23 @@
      * Each iteration through the following loop parses the next command from
      * the script and then executes it.
      */
 
     objv = objvSpace = stackObjArray;
-    lines = lineSpace = linesStack;
     expand = expandStack;
     p = script;
     bytesLeft = numBytes;
 
-    /*
-     * TIP #280 Initialize tracking. Do not push on the frame stack yet.
-     *
-     * We may continue counting based on a specific context (CTX), or open a
-     * new context, either for a sourced script, or 'eval'. For sourced files
-     * we always have a path object, even if nothing was specified in the
-     * interp itself. That makes code using it simpler as NULL checks can be
-     * left out. Sourced file without path in the 'scriptFile' is possible
-     * during Tcl initialization.
-     */
-
-    eeFramePtr->level = iPtr->cmdFramePtr ? iPtr->cmdFramePtr->level + 1 : 1;
-    eeFramePtr->numLevels = iPtr->numLevels;
-    eeFramePtr->framePtr = iPtr->framePtr;
-    eeFramePtr->nextPtr = iPtr->cmdFramePtr;
-    eeFramePtr->nline = 0;
-    eeFramePtr->line = NULL;
-
-    iPtr->cmdFramePtr = eeFramePtr;
-    if (iPtr->evalFlags & TCL_EVAL_CTX) {
-	/*
-	 * Path information comes out of the context.
-	 */
-
-	eeFramePtr->type = TCL_LOCATION_SOURCE;
-	eeFramePtr->data.eval.path = iPtr->invokeCmdFramePtr->data.eval.path;
-	Tcl_IncrRefCount(eeFramePtr->data.eval.path);
-    } else if (iPtr->evalFlags & TCL_EVAL_FILE) {
-	/*
-	 * Set up for a sourced file.
-	 */
-
-	eeFramePtr->type = TCL_LOCATION_SOURCE;
-
-	if (iPtr->scriptFile) {
-	    /*
-	     * Normalization here, to have the correct pwd. Should have
-	     * negligible impact on performance, as the norm should have been
-	     * done already by the 'source' invoking us, and it caches the
-	     * result.
-	     */
-
-	    Tcl_Obj *norm = Tcl_FSGetNormalizedPath(interp, iPtr->scriptFile);
-
-	    if (norm == NULL) {
-		/*
-		 * Error message in the interp result.
-		 */
-
-		code = TCL_ERROR;
-		goto error;
-	    }
-	    eeFramePtr->data.eval.path = norm;
-	} else {
-	    TclNewLiteralStringObj(eeFramePtr->data.eval.path, "");
-	}
-	Tcl_IncrRefCount(eeFramePtr->data.eval.path);
-    } else {
-	/*
-	 * Set up for plain eval.
-	 */
-
-	eeFramePtr->type = TCL_LOCATION_EVAL;
-	eeFramePtr->data.eval.path = NULL;
-    }
-
     iPtr->evalFlags = 0;
     do {
 	if (Tcl_ParseCommand(interp, p, bytesLeft, 0, parsePtr) != TCL_OK) {
 	    code = TCL_ERROR;
 	    goto error;
 	}
 
-	/*
-	 * TIP #280 Track lines. The parser may have skipped text till it
-	 * found the command we are now at. We have to count the lines in this
-	 * block, and do not forget invisible continuation lines.
-	 */
-
-	TclAdvanceLines(&line, p, parsePtr->commandStart);
-	TclAdvanceContinuations(&line, &clNext,
-		parsePtr->commandStart - outerScript);
-
 	gotParse = 1;
 	if (parsePtr->numWords > 0) {
-	    /*
-	     * TIP #280. Track lines within the words of the current
-	     * command. We use a separate pointer into the table of
-	     * continuation line locations to not lose our position for the
-	     * per-command parsing.
-	     */
-
-	    int wordLine = line;
-	    const char *wordStart = parsePtr->commandStart;
-	    int *wordCLNext = clNext;
 	    unsigned int objectsNeeded = 0;
 	    unsigned int numWords = parsePtr->numWords;
 
 	    /*
 	     * Generate an array of objects for the words of the command.
@@ -5100,43 +4853,19 @@
 	     */
 
 	    if (numWords > minObjs) {
 		expand =    ckalloc(numWords * sizeof(int));
 		objvSpace = ckalloc(numWords * sizeof(Tcl_Obj *));
-		lineSpace = ckalloc(numWords * sizeof(int));
 	    }
 	    expandRequested = 0;
 	    objv = objvSpace;
-	    lines = lineSpace;
 
-	    iPtr->cmdFramePtr = eeFramePtr->nextPtr;
 	    for (objectsUsed = 0, tokenPtr = parsePtr->tokenPtr;
 		    objectsUsed < numWords;
 		    objectsUsed++, tokenPtr += tokenPtr->numComponents+1) {
-		/*
-		 * TIP #280. Track lines to current word. Save the information
-		 * on a per-word basis, signaling dynamic words as needed.
-		 * Make the information available to the recursively called
-		 * evaluator as well, including the type of context (source
-		 * vs. eval).
-		 */
-
-		TclAdvanceLines(&wordLine, wordStart, tokenPtr->start);
-		TclAdvanceContinuations(&wordLine, &wordCLNext,
-			tokenPtr->start - outerScript);
-		wordStart = tokenPtr->start;
-
-		lines[objectsUsed] = TclWordKnownAtCompileTime(tokenPtr, NULL)
-			? wordLine : -1;
-
-		if (eeFramePtr->type == TCL_LOCATION_SOURCE) {
-		    iPtr->evalFlags |= TCL_EVAL_FILE;
-		}
-
 		code = TclSubstTokens(interp, tokenPtr+1,
-			tokenPtr->numComponents, NULL, wordLine,
-			wordCLNext, outerScript);
+			tokenPtr->numComponents, NULL);
 
 		iPtr->evalFlags = 0;
 
 		if (code != TCL_OK) {
 		    break;
@@ -5165,33 +4894,26 @@
 		} else {
 		    expand[objectsUsed] = 0;
 		    objectsNeeded++;
 		}
 
-		if (wordCLNext) {
-		    TclContinuationsEnterDerived(objv[objectsUsed],
-			    wordStart - outerScript, wordCLNext);
-		}
 	    } /* for loop */
-	    iPtr->cmdFramePtr = eeFramePtr;
 	    if (code != TCL_OK) {
 		goto error;
 	    }
 	    if (expandRequested) {
 		/*
 		 * Some word expansion was requested. Check for objv resize.
 		 */
 
 		Tcl_Obj **copy = objvSpace;
-		int *lcopy = lineSpace;
 		int wordIdx = numWords;
 		int objIdx = objectsNeeded - 1;
 
 		if ((numWords > minObjs) || (objectsNeeded > minObjs)) {
 		    objv = objvSpace =
 			    ckalloc(objectsNeeded * sizeof(Tcl_Obj *));
-		    lines = lineSpace = ckalloc(objectsNeeded * sizeof(int));
 		}
 
 		objectsUsed = 0;
 		while (wordIdx--) {
 		    if (expand[wordIdx]) {
@@ -5200,58 +4922,39 @@
 
 			Tcl_ListObjGetElements(NULL, temp, &numElements,
 				&elements);
 			objectsUsed += numElements;
 			while (numElements--) {
-			    lines[objIdx] = -1;
 			    objv[objIdx--] = elements[numElements];
 			    Tcl_IncrRefCount(elements[numElements]);
 			}
 			Tcl_DecrRefCount(temp);
 		    } else {
-			lines[objIdx] = lcopy[wordIdx];
 			objv[objIdx--] = copy[wordIdx];
 			objectsUsed++;
 		    }
 		}
 		objv += objIdx+1;
 
 		if (copy != stackObjArray) {
 		    ckfree(copy);
 		}
-		if (lcopy != linesStack) {
-		    ckfree(lcopy);
-		}
 	    }
 
 	    /*
 	     * Execute the command and free the objects for its words.
-	     *
-	     * TIP #280: Remember the command itself for 'info frame'. We
-	     * shorten the visible command by one char to exclude the
-	     * termination character, if necessary. Here is where we put our
-	     * frame on the stack of frames too. _After_ the nested commands
-	     * have been executed.
 	     */
 
-	    eeFramePtr->cmd.str.cmd = parsePtr->commandStart;
-	    eeFramePtr->cmd.str.len = parsePtr->commandSize;
+            {
+                Tcl_Obj *srcPtr = iPtr->cmdSourcePtr;
 
-	    if (parsePtr->term ==
-		    parsePtr->commandStart + parsePtr->commandSize - 1) {
-		eeFramePtr->cmd.str.len--;
-	    }
+                srcPtr->typePtr = &scriptSourceType;
+                srcPtr->internalRep.twoPtrValue.ptr1 = (char *) script;
+                srcPtr->internalRep.twoPtrValue.ptr2 = INT2PTR(numBytes);
 
-	    eeFramePtr->nline = objectsUsed;
-	    eeFramePtr->line = lines;
-
-	    TclArgumentEnter(interp, objv, objectsUsed, eeFramePtr);
-	    code = Tcl_EvalObjv(interp, objectsUsed, objv, TCL_EVAL_NOERR);
-	    TclArgumentRelease(interp, objv, objectsUsed);
-
-	    eeFramePtr->line = NULL;
-	    eeFramePtr->nline = 0;
+                code = Tcl_EvalObjv(interp, objectsUsed, objv, TCL_EVAL_NOERR);
+            }
 
 	    if (code != TCL_OK) {
 		goto error;
 	    }
 	    for (i = 0; i < objectsUsed; i++) {
@@ -5259,12 +4962,10 @@
 	    }
 	    objectsUsed = 0;
 	    if (objvSpace != stackObjArray) {
 		ckfree(objvSpace);
 		objvSpace = stackObjArray;
-		ckfree(lineSpace);
-		lineSpace = linesStack;
 	    }
 
 	    /*
 	     * Free expand separately since objvSpace could have been
 	     * reallocated above.
@@ -5276,19 +4977,15 @@
 	    }
 	}
 
 	/*
 	 * Advance to the next command in the script.
-	 *
-	 * TIP #280 Track Lines. Now we track how many lines were in the
-	 * executed command.
 	 */
 
 	next = parsePtr->commandStart + parsePtr->commandSize;
 	bytesLeft -= next - p;
 	p = next;
-	TclAdvanceLines(&line, parsePtr->commandStart, p);
 	Tcl_FreeParse(parsePtr);
 	gotParse = 0;
     } while (bytesLeft > 0);
     iPtr->varFramePtr = savedVarFramePtr;
     code = TCL_OK;
@@ -5335,463 +5032,22 @@
     if (gotParse) {
 	Tcl_FreeParse(parsePtr);
     }
     if (objvSpace != stackObjArray) {
 	ckfree(objvSpace);
-	ckfree(lineSpace);
     }
     if (expand != expandStack) {
 	ckfree(expand);
     }
     iPtr->varFramePtr = savedVarFramePtr;
 
  cleanup_return:
-    /*
-     * TIP #280. Release the local CmdFrame, and its contents.
-     */
-
-    iPtr->cmdFramePtr = iPtr->cmdFramePtr->nextPtr;
-    if (eeFramePtr->type == TCL_LOCATION_SOURCE) {
-	Tcl_DecrRefCount(eeFramePtr->data.eval.path);
-    }
-    TclStackFree(interp, linesStack);
-    TclStackFree(interp, expandStack);
-    TclStackFree(interp, stackObjArray);
-    TclStackFree(interp, eeFramePtr);
-    TclStackFree(interp, parsePtr);
-
-    return code;
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclAdvanceLines --
- *
- *	This function is a helper which counts the number of lines in a block
- *	of text and advances an external counter.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	The specified counter is advanced per the number of lines found.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclAdvanceLines(
-    int *line,
-    const char *start,
-    const char *end)
-{
-    register const char *p;
-
-    for (p = start; p < end; p++) {
-	if (*p == '\n') {
-	    (*line)++;
-	}
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclAdvanceContinuations --
- *
- *	This procedure is a helper which counts the number of continuation
- *	lines (CL) in a block of text using a table of CL locations and
- *	advances an external counter, and the pointer into the table.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	The specified counter is advanced per the number of continuation lines
- *	found.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclAdvanceContinuations(
-    int *line,
-    int **clNextPtrPtr,
-    int loc)
-{
-    /*
-     * Track the invisible continuation lines embedded in a script, if any.
-     * Here they are just spaces (already). They were removed by
-     * TclSubstTokens via TclParseBackslash.
-     *
-     * *clNextPtrPtr         <=> We have continuation lines to track.
-     * **clNextPtrPtr >= 0   <=> We are not beyond the last possible location.
-     * loc >= **clNextPtrPtr <=> We stepped beyond the current cont. line.
-     */
-
-    while (*clNextPtrPtr && (**clNextPtrPtr >= 0)
-	    && (loc >= **clNextPtrPtr)) {
-	/*
-	 * We just stepped over an invisible continuation line. Adjust the
-	 * line counter and step to the table entry holding the location of
-	 * the next continuation line to track.
-	 */
-
-	(*line)++;
-	(*clNextPtrPtr)++;
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- * Note: The whole data structure access for argument location tracking is
- * hidden behind these three functions. The only parts open are the lineLAPtr
- * field in the Interp structure. The CFWord definition is internal to here.
- * Should make it easier to redo the data structures if we find something more
- * space/time efficient.
- */
-
-/*
- *----------------------------------------------------------------------
- *
- * TclArgumentEnter --
- *
- *	This procedure is a helper for the TIP #280 uplevel extension. It
- *	enters location references for the arguments of a command to be
- *	invoked. Only the first entry has the actual data, further entries
- *	simply count the usage up.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	May allocate memory.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclArgumentEnter(
-    Tcl_Interp *interp,
-    Tcl_Obj **objv,
-    int objc,
-    CmdFrame *cfPtr)
-{
-    Interp *iPtr = (Interp *) interp;
-    int new, i;
-    Tcl_HashEntry *hPtr;
-    CFWord *cfwPtr;
-
-    for (i = 1; i < objc; i++) {
-	/*
-	 * Ignore argument words without line information (= dynamic). If they
-	 * are variables they may have location information associated with
-	 * that, either through globally recorded 'set' invokations, or
-	 * literals in bytecode. Eitehr way there is no need to record
-	 * something here.
-	 */
-
-	if (cfPtr->line[i] < 0) {
-	    continue;
-	}
-	hPtr = Tcl_CreateHashEntry(iPtr->lineLAPtr, objv[i], &new);
-	if (new) {
-	    /*
-	     * The word is not on the stack yet, remember the current location
-	     * and initialize references.
-	     */
-
-	    cfwPtr = ckalloc(sizeof(CFWord));
-	    cfwPtr->framePtr = cfPtr;
-	    cfwPtr->word = i;
-	    cfwPtr->refCount = 1;
-	    Tcl_SetHashValue(hPtr, cfwPtr);
-	} else {
-	    /*
-	     * The word is already on the stack, its current location is not
-	     * relevant. Just remember the reference to prevent early removal.
-	     */
-
-	    cfwPtr = Tcl_GetHashValue(hPtr);
-	    cfwPtr->refCount++;
-	}
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclArgumentRelease --
- *
- *	This procedure is a helper for the TIP #280 uplevel extension. It
- *	removes the location references for the arguments of a command just
- *	done. Usage is counted down, the data is removed only when no user is
- *	left over.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	May release memory.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclArgumentRelease(
-    Tcl_Interp *interp,
-    Tcl_Obj **objv,
-    int objc)
-{
-    Interp *iPtr = (Interp *) interp;
-    int i;
-
-    for (i = 1; i < objc; i++) {
-	CFWord *cfwPtr;
-	Tcl_HashEntry *hPtr =
-		Tcl_FindHashEntry(iPtr->lineLAPtr, (char *) objv[i]);
-
-	if (!hPtr) {
-	    continue;
-	}
-	cfwPtr = Tcl_GetHashValue(hPtr);
-
-	cfwPtr->refCount--;
-	if (cfwPtr->refCount > 0) {
-	    continue;
-	}
-
-	ckfree(cfwPtr);
-	Tcl_DeleteHashEntry(hPtr);
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclArgumentBCEnter --
- *
- *	This procedure is a helper for the TIP #280 uplevel extension. It
- *	enters location references for the literal arguments of commands in
- *	bytecode about to be invoked. Only the first entry has the actual
- *	data, further entries simply count the usage up.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	May allocate memory.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclArgumentBCEnter(
-    Tcl_Interp *interp,
-    Tcl_Obj *objv[],
-    int objc,
-    void *codePtr,
-    CmdFrame *cfPtr,
-    int pc)
-{
-    Interp *iPtr = (Interp *) interp;
-    Tcl_HashEntry *hePtr =
-	    Tcl_FindHashEntry(iPtr->lineBCPtr, (char *) codePtr);
-    ExtCmdLoc *eclPtr;
-
-    if (!hePtr) {
-	return;
-    }
-    eclPtr = Tcl_GetHashValue(hePtr);
-    hePtr = Tcl_FindHashEntry(&eclPtr->litInfo, INT2PTR(pc));
-    if (hePtr) {
-	int word;
-	int cmd = PTR2INT(Tcl_GetHashValue(hePtr));
-	ECL *ePtr = &eclPtr->loc[cmd];
-	CFWordBC *lastPtr = NULL;
-
-	/*
-	 * A few truths ...
-	 * (1) ePtr->nline == objc
-	 * (2) (ePtr->line[word] < 0) => !literal, for all words
-	 * (3) (word == 0) => !literal
-	 *
-	 * Item (2) is why we can use objv to get the literals, and do not
-	 * have to save them at compile time.
-	 */
-
-        if (ePtr->nline != objc) {
-            Tcl_Panic ("TIP 280 data structure inconsistency");
-        }
-
-	for (word = 1; word < objc; word++) {
-	    if (ePtr->line[word] >= 0) {
-		int isnew;
-		Tcl_HashEntry *hPtr = Tcl_CreateHashEntry(iPtr->lineLABCPtr,
-			objv[word], &isnew);
-		CFWordBC *cfwPtr = ckalloc(sizeof(CFWordBC));
-
-		cfwPtr->framePtr = cfPtr;
-		cfwPtr->obj = objv[word];
-		cfwPtr->pc = pc;
-		cfwPtr->word = word;
-		cfwPtr->nextPtr = lastPtr;
-		lastPtr = cfwPtr;
-
-		if (isnew) {
-		    /*
-		     * The word is not on the stack yet, remember the current
-		     * location and initialize references.
-		     */
-
-		    cfwPtr->prevPtr = NULL;
-		} else {
-		    /*
-		     * The object is already on the stack, however it may have
-		     * a different location now (literal sharing may map
-		     * multiple location to a single Tcl_Obj*. Save the old
-		     * information in the new structure.
-		     */
-
-		    cfwPtr->prevPtr = Tcl_GetHashValue(hPtr);
-		}
-
-		Tcl_SetHashValue(hPtr, cfwPtr);
-	    }
-	} /* for */
-
-	cfPtr->litarg = lastPtr;
-    } /* if */
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclArgumentBCRelease --
- *
- *	This procedure is a helper for the TIP #280 uplevel extension. It
- *	removes the location references for the literal arguments of commands
- *	in bytecode just done. Usage is counted down, the data is removed only
- *	when no user is left over.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	May release memory.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclArgumentBCRelease(
-    Tcl_Interp *interp,
-    CmdFrame *cfPtr)
-{
-    Interp *iPtr = (Interp *) interp;
-    CFWordBC *cfwPtr = (CFWordBC *) cfPtr->litarg;
-
-    while (cfwPtr) {
-	CFWordBC *nextPtr = cfwPtr->nextPtr;
-	Tcl_HashEntry *hPtr =
-		Tcl_FindHashEntry(iPtr->lineLABCPtr, (char *) cfwPtr->obj);
-	CFWordBC *xPtr = Tcl_GetHashValue(hPtr);
-
-	if (xPtr != cfwPtr) {
-	    Tcl_Panic("TclArgumentBC Enter/Release Mismatch");
-	}
-
-	if (cfwPtr->prevPtr) {
-	    Tcl_SetHashValue(hPtr, cfwPtr->prevPtr);
-	} else {
-	    Tcl_DeleteHashEntry(hPtr);
-	}
-
-	ckfree(cfwPtr);
-	cfwPtr = nextPtr;
-    }
-
-    cfPtr->litarg = NULL;
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclArgumentGet --
- *
- *	This procedure is a helper for the TIP #280 uplevel extension. It
- *	finds the location references for a Tcl_Obj, if any.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	Writes found location information into the result arguments.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclArgumentGet(
-    Tcl_Interp *interp,
-    Tcl_Obj *obj,
-    CmdFrame **cfPtrPtr,
-    int *wordPtr)
-{
-    Interp *iPtr = (Interp *) interp;
-    Tcl_HashEntry *hPtr;
-    CmdFrame *framePtr;
-
-    /*
-     * An object which either has no string rep or else is a canonical list is
-     * guaranteed to have been generated dynamically: bail out, this cannot
-     * have a usable absolute location. _Do not touch_ the information the set
-     * up by the caller. It knows better than us.
-     */
-
-    if ((obj->bytes == NULL) || TclListObjIsCanonical(obj)) {
-	return;
-    }
-
-    /*
-     * First look for location information recorded in the argument
-     * stack. That is nearest.
-     */
-
-    hPtr = Tcl_FindHashEntry(iPtr->lineLAPtr, (char *) obj);
-    if (hPtr) {
-	CFWord *cfwPtr = Tcl_GetHashValue(hPtr);
-
-	*wordPtr = cfwPtr->word;
-	*cfPtrPtr = cfwPtr->framePtr;
-	return;
-    }
-
-    /*
-     * Check if the Tcl_Obj has location information as a bytecode literal, in
-     * that stack.
-     */
-
-    hPtr = Tcl_FindHashEntry(iPtr->lineLABCPtr, (char *) obj);
-    if (hPtr) {
-	CFWordBC *cfwPtr = Tcl_GetHashValue(hPtr);
-
-	framePtr = cfwPtr->framePtr;
-	framePtr->data.tebc.pc = (char *) (((ByteCode *)
-		framePtr->data.tebc.codePtr)->codeStart + cfwPtr->pc);
-	*cfPtrPtr = cfwPtr->framePtr;
-	*wordPtr = cfwPtr->word;
-	return;
-    }
+    ckfree(expandStack);
+    ckfree(stackObjArray);
+    ckfree(parsePtr);
+
+    return code;
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -5883,11 +5139,10 @@
  * Side effects:
  *	The object is converted, if necessary, to a ByteCode object that holds
  *	the bytecode instructions for the commands. Executing the commands
  *	will almost certainly have side effects that depend on those commands.
  *
- * TIP #280 : Keep public API, internally extended API.
  *----------------------------------------------------------------------
  */
 
 int
 Tcl_EvalObjEx(
@@ -5897,43 +5152,26 @@
 				 * execute. */
     int flags)			/* Collection of OR-ed bits that control the
 				 * evaluation of the script. Supported values
 				 * are TCL_EVAL_GLOBAL and TCL_EVAL_DIRECT. */
 {
-    return TclEvalObjEx(interp, objPtr, flags, NULL, 0);
-}
-
-int
-TclEvalObjEx(
-    Tcl_Interp *interp,		/* Token for command interpreter (returned by
-				 * a previous call to Tcl_CreateInterp). */
-    register Tcl_Obj *objPtr,	/* Pointer to object containing commands to
-				 * execute. */
-    int flags,			/* Collection of OR-ed bits that control the
-				 * evaluation of the script. Supported values
-				 * are TCL_EVAL_GLOBAL and TCL_EVAL_DIRECT. */
-    const CmdFrame *invoker,	/* Frame of the command doing the eval. */
-    int word)			/* Index of the word which is in objPtr. */
-{
     int result = TCL_OK;
     NRE_callback *rootPtr = TOP_CB(interp);
 
-    result = TclNREvalObjEx(interp, objPtr, flags, invoker, word);
+    result = TclNREvalObjEx(interp, objPtr, flags);
     return TclNRRunCallbacks(interp, result, rootPtr);
 }
 
 int
 TclNREvalObjEx(
     Tcl_Interp *interp,		/* Token for command interpreter (returned by
 				 * a previous call to Tcl_CreateInterp). */
     register Tcl_Obj *objPtr,	/* Pointer to object containing commands to
 				 * execute. */
-    int flags,			/* Collection of OR-ed bits that control the
+    int flags)			/* Collection of OR-ed bits that control the
 				 * evaluation of the script. Supported values
 				 * are TCL_EVAL_GLOBAL and TCL_EVAL_DIRECT. */
-    const CmdFrame *invoker,	/* Frame of the command doing the eval. */
-    int word)			/* Index of the word which is in objPtr. */
 {
     Interp *iPtr = (Interp *) interp;
     int result;
 
     /*
@@ -5942,11 +5180,10 @@
      * finally direct evaluation. Precisely one of these blocks will be run.
      */
 
     if (TclListObjIsCanonical(objPtr)) {
 	Tcl_Obj *listPtr = objPtr;
-	CmdFrame *eoFramePtr = NULL;
 	int objc;
 	Tcl_Obj **objv;
 
 	/*
 	 * Pure List Optimization (no string representation). In this case, we
@@ -5976,57 +5213,20 @@
 	Tcl_IncrRefCount(objPtr);
 	listPtr = TclListObjCopy(interp, objPtr);
 	Tcl_IncrRefCount(listPtr);
 	TclDecrRefCount(objPtr);
 
-	if (word != INT_MIN) {
-	    /*
-	     * TIP #280 Structures for tracking lines. As we know that this is
-	     * dynamic execution we ignore the invoker, even if known.
-	     *
-	     * TIP #280. We do _not_ compute all the line numbers for the
-	     * words in the command. For the eval of a pure list the most
-	     * sensible choice is to put all words on line 1. Given that we
-	     * neither need memory for them nor compute anything. 'line' is
-	     * left NULL. The two places using this information (TclInfoFrame,
-	     * and TclInitCompileEnv), are special-cased to use the proper
-	     * line number directly instead of accessing the 'line' array.
-	     *
-	     * Note that we use (word==INTMIN) to signal that no command frame
-	     * should be pushed, as needed by alias and ensemble redirections.
-	     */
-
-	    eoFramePtr = TclStackAlloc(interp, sizeof(CmdFrame));
-	    eoFramePtr->nline = 0;
-	    eoFramePtr->line = NULL;
-
-	    eoFramePtr->type = TCL_LOCATION_EVAL_LIST;
-	    eoFramePtr->level = (iPtr->cmdFramePtr == NULL?
-		    1 : iPtr->cmdFramePtr->level + 1);
-	    eoFramePtr->numLevels = iPtr->numLevels;
-	    eoFramePtr->framePtr = iPtr->framePtr;
-	    eoFramePtr->nextPtr = iPtr->cmdFramePtr;
-
-	    eoFramePtr->cmd.listPtr = listPtr;
-	    eoFramePtr->data.eval.path = NULL;
-
-	    iPtr->cmdFramePtr = eoFramePtr;
-	}
-
-	TclNRDeferCallback(interp, TEOEx_ListCallback, listPtr, eoFramePtr,
+	TclNRDeferCallback(interp, TEOEx_ListCallback, listPtr, NULL,
 		NULL, NULL);
 
 	ListObjGetElements(listPtr, objc, objv);
 	return TclNREvalObjv(interp, objc, objv, flags, NULL);
     }
 
     if (!(flags & TCL_EVAL_DIRECT)) {
 	/*
 	 * Let the compiler/engine subsystem do the evaluation.
-	 *
-	 * TIP #280 The invoker provides us with the context for the script.
-	 * We transfer this to the byte code compiler.
 	 */
 
 	int allowExceptions = (iPtr->evalFlags & TCL_ALLOW_EXCEPTIONS);
 	ByteCode *codePtr;
 	CallFrame *savedVarFramePtr = NULL;	/* Saves old copy of
@@ -6039,11 +5239,11 @@
 	if (flags & TCL_EVAL_GLOBAL) {
 	    savedVarFramePtr = iPtr->varFramePtr;
 	    iPtr->varFramePtr = iPtr->rootFramePtr;
 	}
 	Tcl_IncrRefCount(objPtr);
-	codePtr = TclCompileObj(interp, objPtr, invoker, word);
+	codePtr = TclCompileObj(interp, objPtr);
 
 	TclNRAddCallback(interp, TEOEx_ByteCodeCallback, savedVarFramePtr,
 		objPtr, INT2PTR(allowExceptions), NULL);
         return TclNRExecuteByteCode(interp, codePtr);
     }
@@ -6052,125 +5252,18 @@
 	/*
 	 * We're not supposed to use the compiler or byte-code
 	 * interpreter. Let Tcl_EvalEx evaluate the command directly (and
 	 * probably more slowly).
 	 *
-	 * TIP #280. Propagate context as much as we can. Especially if the
-	 * script to evaluate is a single literal it makes sense to look if
-	 * our context is one with absolute line numbers we can then track
-	 * into the literal itself too.
-	 *
-	 * See also tclCompile.c, TclInitCompileEnv, for the equivalent code
-	 * in the bytecode compiler.
 	 */
 
 	const char *script;
 	int numSrcBytes;
 
-	/*
-	 * Now we check if we have data about invisible continuation lines for
-	 * the script, and make it available to the direct script parser and
-	 * evaluator we are about to call, if so.
-	 *
-	 * It may be possible that the script Tcl_Obj* can be free'd while the
-	 * evaluator is using it, leading to the release of the associated
-	 * ContLineLoc structure as well. To ensure that the latter doesn't
-	 * happen we set a lock on it. We release this lock later in this
-	 * function, after the evaluator is done. The relevant "lineCLPtr"
-	 * hashtable is managed in the file "tclObj.c".
-	 *
-	 * Another important action is to save (and later restore) the
-	 * continuation line information of the caller, in case we are
-	 * executing nested commands in the eval/direct path.
-	 */
-
-	ContLineLoc *saveCLLocPtr = iPtr->scriptCLLocPtr;
-	ContLineLoc *clLocPtr = TclContinuationsGet(objPtr);
-
-	if (clLocPtr) {
-	    iPtr->scriptCLLocPtr = clLocPtr;
-	    Tcl_Preserve(iPtr->scriptCLLocPtr);
-	} else {
-	    iPtr->scriptCLLocPtr = NULL;
-	}
-
 	Tcl_IncrRefCount(objPtr);
-	if (invoker == NULL) {
-	    /*
-	     * No context, force opening of our own.
-	     */
-
-	    script = Tcl_GetStringFromObj(objPtr, &numSrcBytes);
-	    result = Tcl_EvalEx(interp, script, numSrcBytes, flags);
-	} else {
-	    /*
-	     * We have an invoker, describing the command asking for the
-	     * evaluation of a subordinate script. This script may originate
-	     * in a literal word, or from a variable, etc. Using the line
-	     * array we now check if we have good line information for the
-	     * relevant word. The type of context is relevant as well. In a
-	     * non-'source' context we don't have to try tracking lines.
-	     *
-	     * First see if the word exists and is a literal. If not we go
-	     * through the easy dynamic branch. No need to perform more
-	     * complex invokations.
-	     */
-
-	    int pc = 0;
-	    CmdFrame *ctxPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-
-	    *ctxPtr = *invoker;
-	    if (invoker->type == TCL_LOCATION_BC) {
-		/*
-		 * Note: Type BC => ctxPtr->data.eval.path is not used.
-		 * ctxPtr->data.tebc.codePtr is used instead.
-		 */
-
-		TclGetSrcInfoForPc(ctxPtr);
-		pc = 1;
-	    }
-
-	    script = Tcl_GetStringFromObj(objPtr, &numSrcBytes);
-
-	    if ((invoker->nline <= word) ||
-		    (invoker->line[word] < 0) ||
-		    (ctxPtr->type != TCL_LOCATION_SOURCE)) {
-		/*
-		 * Dynamic script, or dynamic context, force our own context.
-		 */
-
-		result = Tcl_EvalEx(interp, script, numSrcBytes, flags);
-	    } else {
-		/*
-		 * Absolute context to reuse.
-		 */
-
-		iPtr->invokeCmdFramePtr = ctxPtr;
-		iPtr->evalFlags |= TCL_EVAL_CTX;
-
-		result = TclEvalEx(interp, script, numSrcBytes, flags,
-			ctxPtr->line[word], NULL, script);
-	    }
-	    if (pc && (ctxPtr->type == TCL_LOCATION_SOURCE)) {
-		/*
-		 * Death of SrcInfo reference.
-		 */
-
-		Tcl_DecrRefCount(ctxPtr->data.eval.path);
-	    }
-	    TclStackFree(interp, ctxPtr);
-	}
-
-	/*
-	 * Now release the lock on the continuation line information, if any,
-	 * and restore the caller's settings.
-	 */
-
-	if (iPtr->scriptCLLocPtr) {
-	    Tcl_Release(iPtr->scriptCLLocPtr);
-	}
-	iPtr->scriptCLLocPtr = saveCLLocPtr;
+        script = Tcl_GetStringFromObj(objPtr, &numSrcBytes);
+        result = Tcl_EvalEx(interp, script, numSrcBytes, flags);
 	TclDecrRefCount(objPtr);
 	return result;
     }
 }
 
@@ -6224,24 +5317,13 @@
 TEOEx_ListCallback(
     ClientData data[],
     Tcl_Interp *interp,
     int result)
 {
-    Interp *iPtr = (Interp *) interp;
     Tcl_Obj *listPtr = data[0];
-    CmdFrame *eoFramePtr = data[1];
 
-    /*
-     * Remove the cmdFrame
-     */
-
-    if (eoFramePtr) {
-	iPtr->cmdFramePtr = eoFramePtr->nextPtr;
-	TclStackFree(interp, eoFramePtr);
-    }
     TclDecrRefCount(listPtr);
-
     return result;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -7991,69 +7073,10 @@
 }
 
 /*
  *----------------------------------------------------------------------
  *
- * TclDTraceInfo --
- *
- *	Extract information from a TIP280 dict for use by DTrace probes.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	None.
- *
- *----------------------------------------------------------------------
- */
-
-void
-TclDTraceInfo(
-    Tcl_Obj *info,
-    const char **args,
-    int *argsi)
-{
-    static Tcl_Obj *keys[10] = { NULL };
-    Tcl_Obj **k = keys, *val;
-    int i = 0;
-
-    if (!*k) {
-#define kini(s) TclNewLiteralStringObj(keys[i], s); i++
-	kini("cmd");	kini("type");	kini("proc");	kini("file");
-	kini("method");	kini("class");	kini("lambda");	kini("object");
-	kini("line");	kini("level");
-#undef kini
-    }
-    for (i = 0; i < 6; i++) {
-	Tcl_DictObjGet(NULL, info, *k++, &val);
-	args[i] = val ? TclGetString(val) : NULL;
-    }
-    /* no "proc" -> use "lambda" */
-    if (!args[2]) {
-	Tcl_DictObjGet(NULL, info, *k, &val);
-	args[2] = val ? TclGetString(val) : NULL;
-    }
-    k++;
-    /* no "class" -> use "object" */
-    if (!args[5]) {
-	Tcl_DictObjGet(NULL, info, *k, &val);
-	args[5] = val ? TclGetString(val) : NULL;
-    }
-    k++;
-    for (i = 0; i < 2; i++) {
-	Tcl_DictObjGet(NULL, info, *k++, &val);
-	if (val) {
-	    TclGetIntFromObj(NULL, val, &argsi[i]);
-	} else {
-	    argsi[i] = 0;
-	}
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- *
  * DTraceCmdReturn --
  *
  *	NR callback for DTrace command return probes.
  *
  * Results:
@@ -8128,18 +7151,10 @@
 	    a[i] = i < objc ? TclGetString(objv[i]) : NULL; i++;
 	}
 	TCL_DTRACE_CMD_ARGS(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7],
 		a[8], a[9]);
     }
-    if (TCL_DTRACE_CMD_INFO_ENABLED() && ((Interp *) interp)->cmdFramePtr) {
-	Tcl_Obj *info = TclInfoFrame(interp, ((Interp *) interp)->cmdFramePtr);
-	const char *a[6]; int i[2];
-
-	TclDTraceInfo(info, a, i);
-	TCL_DTRACE_CMD_INFO(a[0], a[1], a[2], a[3], i[0], i[1], a[4], a[5]);
-	TclDecrRefCount(info);
-    }
     if ((TCL_DTRACE_CMD_RETURN_ENABLED() || TCL_DTRACE_CMD_RESULT_ENABLED())
 	    && objc) {
 	TclNRAddCallback(interp, DTraceCmdReturn, objv[0], NULL, NULL, NULL);
     }
     if (TCL_DTRACE_CMD_ENTRY_ENABLED() && objc) {
@@ -8213,11 +7228,11 @@
 Tcl_NREvalObj(
     Tcl_Interp *interp,
     Tcl_Obj *objPtr,
     int flags)
 {
-    return TclNREvalObjEx(interp, objPtr, flags, NULL, INT_MIN);
+    return TclNREvalObjEx(interp, objPtr, flags);
 }
 
 int
 Tcl_NREvalObjv(
     Tcl_Interp *interp,		/* Interpreter in which to evaluate the
@@ -8622,11 +7637,10 @@
 	 * the job here. The caller context has already been restored.
 	 */
 
 	NRE_ASSERT(iPtr->varFramePtr == corPtr->caller.varFramePtr);
 	NRE_ASSERT(iPtr->framePtr == corPtr->caller.framePtr);
-	NRE_ASSERT(iPtr->cmdFramePtr == corPtr->caller.cmdFramePtr);
 	ckfree(corPtr);
 	return result;
     }
 
     NRE_ASSERT(COR_IS_SUSPENDED(corPtr));
@@ -8675,20 +7689,10 @@
     TclDeleteExecEnv(corPtr->eePtr);
     corPtr->eePtr = NULL;
 
     corPtr->stackLevel = NULL;
 
-    /*
-     * #280.
-     * Drop the coroutine-owned copy of the lineLABCPtr hashtable for literal
-     * command arguments in bytecode.
-     */
-
-    Tcl_DeleteHashTable(corPtr->lineLABCPtr);
-    ckfree(corPtr->lineLABCPtr);
-    corPtr->lineLABCPtr = NULL;
-
     RESTORE_CONTEXT(corPtr->caller);
     iPtr->execEnvPtr = corPtr->callerEEPtr;
     iPtr->numLevels++;
 
     return result;
@@ -8831,11 +7835,11 @@
      * Add the callback to the coro's execEnv, so that it is the first thing
      * to happen when the coro is resumed.
      */
 
     iPtr->execEnvPtr = corPtr->eePtr;
-    TclNREvalObjEx(interp, Tcl_NewListObj(objc-2, objv+2), 0, NULL, INT_MIN);
+    TclNREvalObjEx(interp, Tcl_NewListObj(objc-2, objv+2), 0);
     iPtr->execEnvPtr = savedEEPtr;
 
     return TCL_OK;
 }
 
@@ -8973,46 +7977,16 @@
     Tcl_DStringFree(&ds);
 
     corPtr->cmdPtr = cmdPtr;
     cmdPtr->refCount++;
 
-    /*
-     * #280.
-     * Provide the new coroutine with its own copy of the lineLABCPtr
-     * hashtable for literal command arguments in bytecode. Note that that
-     * CFWordBC chains are not duplicated, only the entrypoints to them. This
-     * means that in the presence of coroutines each chain is potentially a
-     * tree. Like the chain -> tree conversion of the CmdFrame stack.
-     */
-
-    {
-	Tcl_HashSearch hSearch;
-	Tcl_HashEntry *hePtr;
-
-	corPtr->lineLABCPtr = ckalloc(sizeof(Tcl_HashTable));
-	Tcl_InitHashTable(corPtr->lineLABCPtr, TCL_ONE_WORD_KEYS);
-
-	for (hePtr = Tcl_FirstHashEntry(iPtr->lineLABCPtr,&hSearch);
-		hePtr; hePtr = Tcl_NextHashEntry(&hSearch)) {
-	    int isNew;
-	    Tcl_HashEntry *newPtr =
-		    Tcl_CreateHashEntry(corPtr->lineLABCPtr,
-		    Tcl_GetHashKey(iPtr->lineLABCPtr, hePtr),
-		    &isNew);
-
-	    Tcl_SetHashValue(newPtr, Tcl_GetHashValue(hePtr));
-	}
-    }
-
     /*
      * Create the base context.
      */
 
     corPtr->running.framePtr = iPtr->rootFramePtr;
     corPtr->running.varFramePtr = iPtr->rootFramePtr;
-    corPtr->running.cmdFramePtr = NULL;
-    corPtr->running.lineLABCPtr = corPtr->lineLABCPtr;
     corPtr->stackLevel = NULL;
     corPtr->auxNumLevels = 0;
 
     /*
      * Create the coro's execEnv, switch to it to push the exit and coro

Index: generic/tclCkalloc.c
==================================================================
--- generic/tclCkalloc.c
+++ generic/tclCkalloc.c
@@ -1305,14 +1305,10 @@
     }
     allocHead = NULL;
 
     Tcl_MutexUnlock(ckallocMutexPtr);
 #endif
-
-#if USE_TCLALLOC
-    TclFinalizeAllocSubsystem();
-#endif
 }
 
 /*
  * Local Variables:
  * mode: c

Index: generic/tclCmdAH.c
==================================================================
--- generic/tclCmdAH.c
+++ generic/tclCmdAH.c
@@ -301,11 +301,10 @@
     int objc,			/* Number of arguments. */
     Tcl_Obj *const objv[])	/* Argument objects. */
 {
     Tcl_Obj *varNamePtr = NULL;
     Tcl_Obj *optionVarNamePtr = NULL;
-    Interp *iPtr = (Interp *) interp;
 
     if ((objc < 2) || (objc > 4)) {
 	Tcl_WrongNumArgs(interp, 1, objv,
 		"script ?resultVarName? ?optionVarName?");
 	return TCL_ERROR;
@@ -319,15 +318,11 @@
     }
 
     TclNRAddCallback(interp, CatchObjCmdCallback, INT2PTR(objc),
 	    varNamePtr, optionVarNamePtr, NULL);
 
-    /*
-     * TIP #280. Make invoking context available to caught script.
-     */
-
-    return TclNREvalObjEx(interp, objv[1], 0, iPtr->cmdFramePtr, 1);
+    return TclNREvalObjEx(interp, objv[1], 0);
 }
 
 static int
 CatchObjCmdCallback(
     ClientData data[],
@@ -758,42 +753,29 @@
     Tcl_Interp *interp,		/* Current interpreter. */
     int objc,			/* Number of arguments. */
     Tcl_Obj *const objv[])	/* Argument objects. */
 {
     register Tcl_Obj *objPtr;
-    Interp *iPtr = (Interp *) interp;
-    CmdFrame *invoker = NULL;
-    int word = 0;
 
     if (objc < 2) {
 	Tcl_WrongNumArgs(interp, 1, objv, "arg ?arg ...?");
 	return TCL_ERROR;
     }
 
     if (objc == 2) {
-	/*
-	 * TIP #280. Make argument location available to eval'd script.
-	 */
-
-	invoker = iPtr->cmdFramePtr;
-	word = 1;
 	objPtr = objv[1];
-	TclArgumentGet(interp, objPtr, &invoker, &word);
     } else {
 	/*
 	 * More than one argument: concatenate them together with spaces
 	 * between, then evaluate the result. Tcl_EvalObjEx will delete the
 	 * object when it decrements its refcount after eval'ing it.
-	 *
-	 * TIP #280. Make invoking context available to eval'd script, done
-	 * with the default values.
 	 */
 
 	objPtr = Tcl_ConcatObj(objc-1, objv+1);
     }
     TclNRAddCallback(interp, EvalCmdErrMsg, NULL, NULL, NULL, NULL);
-    return TclNREvalObjEx(interp, objPtr, 0, invoker, word);
+    return TclNREvalObjEx(interp, objPtr, 0);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -2406,32 +2388,25 @@
     ClientData dummy,		/* Not used. */
     Tcl_Interp *interp,		/* Current interpreter. */
     int objc,			/* Number of arguments. */
     Tcl_Obj *const objv[])	/* Argument objects. */
 {
-    Interp *iPtr = (Interp *) interp;
     ForIterData *iterPtr;
 
     if (objc != 5) {
-	Tcl_WrongNumArgs(interp, 1, objv, "start test next command");
-	return TCL_ERROR;
+        Tcl_WrongNumArgs(interp, 1, objv, "start test next command");
+        return TCL_ERROR;
     }
 
-    TclSmallAllocEx(interp, sizeof(ForIterData), iterPtr);
+    TclCkSmallAlloc(sizeof(ForIterData), iterPtr);
     iterPtr->cond = objv[2];
     iterPtr->body = objv[4];
     iterPtr->next = objv[3];
     iterPtr->msg  = "\n    (\"for\" body line %d)";
-    iterPtr->word = 4;
 
     TclNRAddCallback(interp, ForSetupCallback, iterPtr, NULL, NULL, NULL);
-
-    /*
-     * TIP #280. Make invoking context available to initial script.
-     */
-
-    return TclNREvalObjEx(interp, objv[1], 0, iPtr->cmdFramePtr, 1);
+    return TclNREvalObjEx(interp, objv[1], 0);
 }
 
 static int
 ForSetupCallback(
     ClientData data[],
@@ -2442,11 +2417,11 @@
 
     if (result != TCL_OK) {
 	if (result == TCL_ERROR) {
 	    Tcl_AddErrorInfo(interp, "\n    (\"for\" initial command)");
 	}
-	TclSmallFreeEx(interp, iterPtr);
+	TclSmallFree(iterPtr);
 	return result;
     }
     TclNRAddCallback(interp, TclNRForIterCallback, iterPtr, NULL, NULL, NULL);
     return TCL_OK;
 }
@@ -2480,71 +2455,62 @@
 	break;
     case TCL_ERROR:
 	Tcl_AppendObjToErrorInfo(interp,
 		Tcl_ObjPrintf(iterPtr->msg, Tcl_GetErrorLine(interp)));
     }
-    TclSmallFreeEx(interp, iterPtr);
+    TclSmallFree(iterPtr);
     return result;
 }
 
 static int
 ForCondCallback(
     ClientData data[],
     Tcl_Interp *interp,
     int result)
 {
-    Interp *iPtr = (Interp *) interp;
     ForIterData *iterPtr = data[0];
     Tcl_Obj *boolObj = data[1];
     int value;
 
     if (result != TCL_OK) {
 	Tcl_DecrRefCount(boolObj);
-	TclSmallFreeEx(interp, iterPtr);
+	TclSmallFree(iterPtr);
 	return result;
     } else if (Tcl_GetBooleanFromObj(interp, boolObj, &value) != TCL_OK) {
 	Tcl_DecrRefCount(boolObj);
-	TclSmallFreeEx(interp, iterPtr);
+	TclSmallFree(iterPtr);
 	return TCL_ERROR;
     }
     Tcl_DecrRefCount(boolObj);
 
     if (value) {
-	/* TIP #280. */
 	if (iterPtr->next) {
 	    TclNRAddCallback(interp, ForNextCallback, iterPtr, NULL, NULL,
 		    NULL);
 	} else {
 	    TclNRAddCallback(interp, TclNRForIterCallback, iterPtr, NULL,
 		    NULL, NULL);
 	}
-	return TclNREvalObjEx(interp, iterPtr->body, 0, iPtr->cmdFramePtr,
-		iterPtr->word);
+	return TclNREvalObjEx(interp, iterPtr->body, 0);
     }
-    TclSmallFreeEx(interp, iterPtr);
+    TclSmallFree(iterPtr);
     return result;
 }
 
 static int
 ForNextCallback(
     ClientData data[],
     Tcl_Interp *interp,
     int result)
 {
-    Interp *iPtr = (Interp *) interp;
     ForIterData *iterPtr = data[0];
     Tcl_Obj *next = iterPtr->next;
 
     if ((result == TCL_OK) || (result == TCL_CONTINUE)) {
 	TclNRAddCallback(interp, ForPostNextCallback, iterPtr, NULL, NULL,
 		NULL);
-
-	/*
-	 * TIP #280. Make invoking context available to next script.
-	 */
-
-	return TclNREvalObjEx(interp, next, 0, iPtr->cmdFramePtr, 3);
+	return TclNREvalObjEx(interp, next, 0);
     }
 
     TclNRAddCallback(interp, TclNRForIterCallback, iterPtr, NULL, NULL, NULL);
     return result;
 }
@@ -2558,11 +2524,11 @@
     ForIterData *iterPtr = data[0];
 
     if ((result != TCL_BREAK) && (result != TCL_OK)) {
 	if (result == TCL_ERROR) {
 	    Tcl_AddErrorInfo(interp, "\n    (\"for\" loop-end command)");
-	    TclSmallFreeEx(interp, iterPtr);
+	    TclSmallFree(iterPtr);
 	}
 	return result;
     }
     TclNRAddCallback(interp, TclNRForIterCallback, iterPtr, NULL, NULL, NULL);
     return result;
@@ -2658,11 +2624,11 @@
      * The setting up of all of these pointers is moderately messy, but allows
      * the rest of this code to be simple and for us to use a single memory
      * allocation for better performance.
      */
 
-    statePtr = TclStackAlloc(interp,
+    statePtr = ckalloc(
 	    sizeof(struct ForeachState) + 3 * numLists * sizeof(int)
 	    + 2 * numLists * (sizeof(Tcl_Obj **) + sizeof(Tcl_Obj *)));
     memset(statePtr, 0,
 	    sizeof(struct ForeachState) + 3 * numLists * sizeof(int)
 	    + 2 * numLists * (sizeof(Tcl_Obj **) + sizeof(Tcl_Obj *)));
@@ -2734,12 +2700,11 @@
 	if (result == TCL_ERROR) {
 	    goto done;
 	}
 
 	TclNRAddCallback(interp, ForeachLoopStep, statePtr, NULL, NULL, NULL);
-	return TclNREvalObjEx(interp, objv[objc-1], 0,
-		((Interp *) interp)->cmdFramePtr, objc-1);
+	return TclNREvalObjEx(interp, objv[objc-1], 0);
     }
 
     /*
      * This cleanup stage is only used when an error occurs during setup or if
      * there is no work to do.
@@ -2800,12 +2765,11 @@
 	if (result == TCL_ERROR) {
 	    goto done;
 	}
 
 	TclNRAddCallback(interp, ForeachLoopStep, statePtr, NULL, NULL, NULL);
-	return TclNREvalObjEx(interp, statePtr->bodyPtr, 0,
-		((Interp *) interp)->cmdFramePtr, statePtr->bodyIdx);
+	return TclNREvalObjEx(interp, statePtr->bodyPtr, 0);
     }
 
     /*
      * We're done. Tidy up our work space and finish off.
      */
@@ -2881,11 +2845,11 @@
 	}
     }
     if (statePtr->resultList != NULL) {
 	TclDecrRefCount(statePtr->resultList);
     }
-    TclStackFree(interp, statePtr);
+    ckfree(statePtr);
 }
 
 /*
  *----------------------------------------------------------------------
  *

Index: generic/tclCmdIL.c
==================================================================
--- generic/tclCmdIL.c
+++ generic/tclCmdIL.c
@@ -120,13 +120,10 @@
 static int		InfoDefaultCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
 /* TIP #348 - New 'info' subcommand 'errorstack' */
 static int		InfoErrorStackCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
-/* TIP #280 - New 'info' subcommand 'frame' */
-static int		InfoFrameCmd(ClientData dummy, Tcl_Interp *interp,
-			    int objc, Tcl_Obj *const objv[]);
 static int		InfoFunctionsCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
 static int		InfoHostnameCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
 static int		InfoLevelCmd(ClientData dummy, Tcl_Interp *interp,
@@ -168,11 +165,10 @@
     {"complete",	   InfoCompleteCmd,	    TclCompileBasic1ArgCmd, NULL, NULL, 0},
     {"coroutine",	   TclInfoCoroutineCmd,     TclCompileInfoCoroutineCmd, NULL, NULL, 0},
     {"default",		   InfoDefaultCmd,	    TclCompileBasic3ArgCmd, NULL, NULL, 0},
     {"errorstack",	   InfoErrorStackCmd,	    TclCompileBasic0Or1ArgCmd, NULL, NULL, 0},
     {"exists",		   TclInfoExistsCmd,	    TclCompileInfoExistsCmd, NULL, NULL, 0},
-    {"frame",		   InfoFrameCmd,	    TclCompileBasic0Or1ArgCmd, NULL, NULL, 0},
     {"functions",	   InfoFunctionsCmd,	    TclCompileBasic0Or1ArgCmd, NULL, NULL, 0},
     {"globals",		   TclInfoGlobalsCmd,	    TclCompileBasic0Or1ArgCmd, NULL, NULL, 0},
     {"hostname",	   InfoHostnameCmd,	    TclCompileBasic0ArgCmd, NULL, NULL, 0},
     {"level",		   InfoLevelCmd,	    TclCompileInfoLevelCmd, NULL, NULL, 0},
     {"library",		   InfoLibraryCmd,	    TclCompileBasic0ArgCmd, NULL, NULL, 0},
@@ -252,11 +248,10 @@
 IfConditionCallback(
     ClientData data[],
     Tcl_Interp *interp,
     int result)
 {
-    Interp *iPtr = (Interp *) interp;
     int objc = PTR2INT(data[0]);
     Tcl_Obj *const *objv = data[1];
     int i = PTR2INT(data[2]);
     Tcl_Obj *boolObj = data[3];
     int value, thenScriptIndex = 0;
@@ -295,16 +290,11 @@
 	 */
 
 	i++;
 	if (i >= objc) {
 	    if (thenScriptIndex) {
-		/*
-		 * TIP #280. Make invoking context available to branch.
-		 */
-
-		return TclNREvalObjEx(interp, objv[thenScriptIndex], 0,
-			iPtr->cmdFramePtr, thenScriptIndex);
+		return TclNREvalObjEx(interp, objv[thenScriptIndex], 0);
 	    }
 	    return TCL_OK;
 	}
 	clause = TclGetString(objv[i]);
 	if ((clause[0] != 'e') || (strcmp(clause, "elseif") != 0)) {
@@ -352,18 +342,13 @@
 		-1));
 	Tcl_SetErrorCode(interp, "TCL", "WRONGARGS", NULL);
 	return TCL_ERROR;
     }
     if (thenScriptIndex) {
-	/*
-	 * TIP #280. Make invoking context available to branch/else.
-	 */
-
-	return TclNREvalObjEx(interp, objv[thenScriptIndex], 0,
-		iPtr->cmdFramePtr, thenScriptIndex);
+	return TclNREvalObjEx(interp, objv[thenScriptIndex], 0);
     }
-    return TclNREvalObjEx(interp, objv[i], 0, iPtr->cmdFramePtr, i);
+    return TclNREvalObjEx(interp, objv[i], 0);
 
   missingScript:
     Tcl_SetObjResult(interp, Tcl_ObjPrintf(
 	    "wrong # args: no script following \"%s\" argument",
 	    TclGetString(objv[i-1])));
@@ -1114,357 +1099,10 @@
 
     Tcl_SetObjResult(interp,
 	    Tcl_NewBooleanObj(varPtr && varPtr->value.objPtr));
     return TCL_OK;
 }
-
-/*
- *----------------------------------------------------------------------
- *
- * InfoFrameCmd --
- *	TIP #280
- *
- *	Called to implement the "info frame" command that returns the location
- *	of either the currently executing command, or its caller. Handles the
- *	following syntax:
- *
- *		info frame ?number?
- *
- * Results:
- *	Returns TCL_OK if successful and TCL_ERROR if there is an error.
- *
- * Side effects:
- *	Returns a result in the interpreter's result object. If there is an
- *	error, the result is an error message.
- *
- *----------------------------------------------------------------------
- */
-
-static int
-InfoFrameCmd(
-    ClientData dummy,		/* Not used. */
-    Tcl_Interp *interp,		/* Current interpreter. */
-    int objc,			/* Number of arguments. */
-    Tcl_Obj *const objv[])	/* Argument objects. */
-{
-    Interp *iPtr = (Interp *) interp;
-    int level, topLevel, code = TCL_OK;
-    CmdFrame *runPtr, *framePtr;
-    CoroutineData *corPtr = iPtr->execEnvPtr->corPtr;
-
-    if (objc > 2) {
-	Tcl_WrongNumArgs(interp, 1, objv, "?number?");
-	return TCL_ERROR;
-    }
-
-    topLevel = ((iPtr->cmdFramePtr == NULL)
-	    ? 0
-	    : iPtr->cmdFramePtr->level);
-
-    if (corPtr) {
-	/*
-	 * A coroutine: must fix the level computations AND the cmdFrame chain,
-	 * which is interrupted at the base.
-	 */
-
-	CmdFrame *lastPtr = NULL;
-
-	runPtr = iPtr->cmdFramePtr;
-
-	/* TODO - deal with overflow */
-	topLevel += corPtr->caller.cmdFramePtr->level;
-	while (runPtr) {
-	    runPtr->level += corPtr->caller.cmdFramePtr->level;
-	    lastPtr = runPtr;
-	    runPtr = runPtr->nextPtr;
-	}
-	if (lastPtr) {
-	    lastPtr->nextPtr = corPtr->caller.cmdFramePtr;
-	} else {
-	    iPtr->cmdFramePtr = corPtr->caller.cmdFramePtr;
-	}
-    }
-
-    if (objc == 1) {
-	/*
-	 * Just "info frame".
-	 */
-
-	Tcl_SetObjResult(interp, Tcl_NewIntObj(topLevel));
-	goto done;
-    }
-
-    /*
-     * We've got "info frame level" and must parse the level first.
-     */
-
-    if (TclGetIntFromObj(interp, objv[1], &level) != TCL_OK) {
-	code = TCL_ERROR;
-	goto done;
-    }
-
-    if ((level > topLevel) || (level <= - topLevel)) {
-    levelError:
-	Tcl_SetObjResult(interp, Tcl_ObjPrintf(
-		"bad level \"%s\"", TclGetString(objv[1])));
-	Tcl_SetErrorCode(interp, "TCL", "LOOKUP", "STACK_FRAME",
-		TclGetString(objv[1]), NULL);
-	code = TCL_ERROR;
-	goto done;
-    }
-
-    /*
-     * Let us convert to relative so that we know how many levels to go back
-     */
-
-    if (level > 0) {
-	level -= topLevel;
-    }
-
-    framePtr = iPtr->cmdFramePtr;
-    while (++level <= 0) {
-	framePtr = framePtr->nextPtr;
-	if (!framePtr) {
-	    goto levelError;
-	}
-    }
-
-    Tcl_SetObjResult(interp, TclInfoFrame(interp, framePtr));
-
-  done:
-    if (corPtr) {
-
-	if (iPtr->cmdFramePtr == corPtr->caller.cmdFramePtr) {
-	    iPtr->cmdFramePtr = NULL;
-	} else {
-	    runPtr = iPtr->cmdFramePtr;
-	    while (runPtr->nextPtr != corPtr->caller.cmdFramePtr) {
-	    	runPtr->level -= corPtr->caller.cmdFramePtr->level;
-		runPtr = runPtr->nextPtr;
-	    }
-	    runPtr->level = 1;
-	    runPtr->nextPtr = NULL;
-	}
-
-    }
-    return code;
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclInfoFrame --
- *
- *	Core of InfoFrameCmd, returns TIP280 dict for a given frame.
- *
- * Results:
- *	Returns TIP280 dict.
- *
- * Side effects:
- *	None.
- *
- *----------------------------------------------------------------------
- */
-
-Tcl_Obj *
-TclInfoFrame(
-    Tcl_Interp *interp,		/* Current interpreter. */
-    CmdFrame *framePtr)		/* Frame to get info for. */
-{
-    Interp *iPtr = (Interp *) interp;
-    Tcl_Obj *tmpObj;
-    Tcl_Obj *lv[20];		/* Keep uptodate when more keys are added to
-				 * the dict. */
-    int lc = 0;
-    /*
-     * This array is indexed by the TCL_LOCATION_... values, except
-     * for _LAST.
-     */
-    static const char *const typeString[TCL_LOCATION_LAST] = {
-	"eval", "eval", "eval", "precompiled", "source", "proc"
-    };
-    Proc *procPtr = framePtr->framePtr ? framePtr->framePtr->procPtr : NULL;
-
-    /*
-     * Pull the information and construct the dictionary to return, as list.
-     * Regarding use of the CmdFrame fields see tclInt.h, and its definition.
-     */
-
-#define ADD_PAIR(name, value) \
-	TclNewLiteralStringObj(tmpObj, name); \
-	lv[lc++] = tmpObj; \
-	lv[lc++] = (value)
-
-    switch (framePtr->type) {
-    case TCL_LOCATION_EVAL:
-	/*
-	 * Evaluation, dynamic script. Type, line, cmd, the latter through
-	 * str.
-	 */
-
-	ADD_PAIR("type", Tcl_NewStringObj(typeString[framePtr->type], -1));
-	ADD_PAIR("line", Tcl_NewIntObj(framePtr->line[0]));
-	ADD_PAIR("cmd", Tcl_NewStringObj(framePtr->cmd.str.cmd,
-		framePtr->cmd.str.len));
-	break;
-
-    case TCL_LOCATION_EVAL_LIST:
-	/*
-	 * List optimized evaluation. Type, line, cmd, the latter through
-	 * listPtr, possibly a frame.
-	 */
-
-	ADD_PAIR("type", Tcl_NewStringObj(typeString[framePtr->type], -1));
-	ADD_PAIR("line", Tcl_NewIntObj(1));
-
-	/*
-	 * We put a duplicate of the command list obj into the result to
-	 * ensure that the 'pure List'-property of the command itself is not
-	 * destroyed. Otherwise the query here would disable the list
-	 * optimization path in Tcl_EvalObjEx.
-	 */
-
-	ADD_PAIR("cmd", Tcl_DuplicateObj(framePtr->cmd.listPtr));
-	break;
-
-    case TCL_LOCATION_PREBC:
-	/*
-	 * Precompiled. Result contains the type as signal, nothing else.
-	 */
-
-	ADD_PAIR("type", Tcl_NewStringObj(typeString[framePtr->type], -1));
-	break;
-
-    case TCL_LOCATION_BC: {
-	/*
-	 * Execution of bytecode. Talk to the BC engine to fill out the frame.
-	 */
-
-	CmdFrame *fPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-
-	*fPtr = *framePtr;
-
-	/*
-	 * Note:
-	 * Type BC => f.data.eval.path	  is not used.
-	 *	      f.data.tebc.codePtr is used instead.
-	 */
-
-	TclGetSrcInfoForPc(fPtr);
-
-	/*
-	 * Now filled: cmd.str.(cmd,len), line
-	 * Possibly modified: type, path!
-	 */
-
-	ADD_PAIR("type", Tcl_NewStringObj(typeString[fPtr->type], -1));
-	if (fPtr->line) {
-	    ADD_PAIR("line", Tcl_NewIntObj(fPtr->line[0]));
-	}
-
-	if (fPtr->type == TCL_LOCATION_SOURCE) {
-	    ADD_PAIR("file", fPtr->data.eval.path);
-
-	    /*
-	     * Death of reference by TclGetSrcInfoForPc.
-	     */
-
-	    Tcl_DecrRefCount(fPtr->data.eval.path);
-	}
-
-	ADD_PAIR("cmd",
-		Tcl_NewStringObj(fPtr->cmd.str.cmd, fPtr->cmd.str.len));
-	TclStackFree(interp, fPtr);
-	break;
-    }
-
-    case TCL_LOCATION_SOURCE:
-	/*
-	 * Evaluation of a script file.
-	 */
-
-	ADD_PAIR("type", Tcl_NewStringObj(typeString[framePtr->type], -1));
-	ADD_PAIR("line", Tcl_NewIntObj(framePtr->line[0]));
-	ADD_PAIR("file", framePtr->data.eval.path);
-
-	/*
-	 * Refcount framePtr->data.eval.path goes up when lv is converted into
-	 * the result list object.
-	 */
-
-	ADD_PAIR("cmd", Tcl_NewStringObj(framePtr->cmd.str.cmd,
-		framePtr->cmd.str.len));
-	break;
-
-    case TCL_LOCATION_PROC:
-	Tcl_Panic("TCL_LOCATION_PROC found in standard frame");
-	break;
-    }
-
-    /*
-     * 'proc'. Common to all frame types. Conditional on having an associated
-     * Procedure CallFrame.
-     */
-
-    if (procPtr != NULL) {
-	Tcl_HashEntry *namePtr = procPtr->cmdPtr->hPtr;
-
-	if (namePtr) {
-	    Tcl_Obj *procNameObj;
-
-	    /*
-	     * This is a regular command.
-	     */
-
-	    TclNewObj(procNameObj);
-	    Tcl_GetCommandFullName(interp, (Tcl_Command) procPtr->cmdPtr,
-		    procNameObj);
-	    ADD_PAIR("proc", procNameObj);
-	} else if (procPtr->cmdPtr->clientData) {
-	    ExtraFrameInfo *efiPtr = procPtr->cmdPtr->clientData;
-	    int i;
-
-	    /*
-	     * This is a non-standard command. Luckily, it's told us how to
-	     * render extra information about its frame.
-	     */
-
-	    for (i=0 ; i<efiPtr->length ; i++) {
-		lv[lc++] = Tcl_NewStringObj(efiPtr->fields[i].name, -1);
-		if (efiPtr->fields[i].proc) {
-		    lv[lc++] =
-			efiPtr->fields[i].proc(efiPtr->fields[i].clientData);
-		} else {
-		    lv[lc++] = efiPtr->fields[i].clientData;
-		}
-	    }
-	}
-    }
-
-    /*
-     * 'level'. Common to all frame types. Conditional on having an associated
-     * _visible_ CallFrame.
-     */
-
-    if ((framePtr->framePtr != NULL) && (iPtr->varFramePtr != NULL)) {
-	CallFrame *current = framePtr->framePtr;
-	CallFrame *top = iPtr->varFramePtr;
-	CallFrame *idx;
-
-	for (idx=top ; idx!=NULL ; idx=idx->callerVarPtr) {
-	    if (idx == current) {
-		int c = framePtr->framePtr->level;
-		int t = iPtr->varFramePtr->level;
-
-		ADD_PAIR("level", Tcl_NewIntObj(t - c));
-		break;
-	    }
-	}
-    }
-
-    return Tcl_NewListObj(lc, lv);
-}
 
 /*
  *----------------------------------------------------------------------
  *
  * InfoFunctionsCmd --
@@ -3057,11 +2695,11 @@
 	case LSEARCH_INDEX: {		/* -index */
 	    Tcl_Obj **indices;
 	    int j;
 
 	    if (sortInfo.indexc > 1) {
-		TclStackFree(interp, sortInfo.indexv);
+		ckfree(sortInfo.indexv);
 	    }
 	    if (i > objc-4) {
 		if (startPtr != NULL) {
 		    Tcl_DecrRefCount(startPtr);
 		}
@@ -3093,11 +2731,11 @@
 	    case 1:
 		sortInfo.indexv = &sortInfo.singleIndex;
 		break;
 	    default:
 		sortInfo.indexv =
-			TclStackAlloc(interp, sizeof(int) * sortInfo.indexc);
+			ckalloc(sizeof(int) * sortInfo.indexc);
 	    }
 
 	    /*
 	     * Fill the array by parsing each index. We don't know whether
 	     * their scale is sensible yet, but we at least perform the
@@ -3204,11 +2842,11 @@
 	 * "did not match anything at all" result straight away. [Bug 1374778]
 	 */
 
 	if (offset > listc-1) {
 	    if (sortInfo.indexc > 1) {
-		TclStackFree(interp, sortInfo.indexv);
+		ckfree(sortInfo.indexv);
 	    }
 	    if (allMatches || inlineReturn) {
 		Tcl_ResetResult(interp);
 	    } else {
 		Tcl_SetObjResult(interp, Tcl_NewIntObj(-1));
@@ -3529,11 +3167,11 @@
      * Cleanup the index list array.
      */
 
   done:
     if (sortInfo.indexc > 1) {
-	TclStackFree(interp, sortInfo.indexv);
+	ckfree(sortInfo.indexv);
     }
     return result;
 }
 
 /*
@@ -3823,11 +3461,11 @@
 	case 1:
 	    sortInfo.indexv = &sortInfo.singleIndex;
 	    break;
 	default:
 	    sortInfo.indexv =
-		    TclStackAlloc(interp, sizeof(int) * sortInfo.indexc);
+		    ckalloc(sizeof(int) * sortInfo.indexc);
 	    allocatedIndexVector = 1;	/* Cannot use indexc field, as it
 					 * might be decreased by 1 later. */
 	}
 	for (j=0 ; j<sortInfo.indexc ; j++) {
 	    TclGetIntForIndexM(interp, indexv[j], SORTIDX_END,
@@ -3922,10 +3560,11 @@
 		sortInfo.indexc--;
 
 		/*
 		 * Do not shrink the actual memory block used; that doesn't
 		 * work with TclStackAlloc-allocated memory. [Bug 2918962]
+                 * FIXME: TclStackAlloc is now retired, we could shrink it.
 		 */
 
 		for (i = 0; i < sortInfo.indexc; i++) {
 		    sortInfo.indexv[i] = sortInfo.indexv[i+1];
 		}
@@ -3959,11 +3598,11 @@
     /*
      * The following loop creates a SortElement for each list element and
      * begins sorting it into the sublists as it appears.
      */
 
-    elementArray = TclStackAlloc(interp, length * sizeof(SortElement));
+    elementArray = ckalloc(length * sizeof(SortElement));
 
     for (i=0; i < length; i++){
 	idx = groupSize * i + groupOffset;
 	if (indexc) {
 	    /*
@@ -4083,21 +3722,21 @@
 	listRepPtr->elemCount = i;
 	Tcl_SetObjResult(interp, resultPtr);
     }
 
   done1:
-    TclStackFree(interp, elementArray);
+    ckfree(elementArray);
 
   done:
     if (sortInfo.sortMode == SORTMODE_COMMAND) {
 	TclDecrRefCount(sortInfo.compareCmdPtr);
 	TclDecrRefCount(listObj);
 	sortInfo.compareCmdPtr = NULL;
     }
   done2:
     if (allocatedIndexVector) {
-	TclStackFree(interp, sortInfo.indexv);
+	ckfree(sortInfo.indexv);
     }
     return sortInfo.resultCode;
 }
 
 /*

Index: generic/tclCmdMZ.c
==================================================================
--- generic/tclCmdMZ.c
+++ generic/tclCmdMZ.c
@@ -1900,11 +1900,11 @@
 	/*
 	 * Copy the dictionary out into an array; that's the easiest way to
 	 * adapt this code...
 	 */
 
-	mapElemv = TclStackAlloc(interp, sizeof(Tcl_Obj *) * mapElemc);
+	mapElemv = ckalloc(sizeof(Tcl_Obj *) * mapElemc);
 	Tcl_DictObjFirst(interp, objv[objc-2], &search, mapElemv+0,
 		mapElemv+1, &done);
 	for (i=2 ; i<mapElemc ; i+=2) {
 	    Tcl_DictObjNext(&search, mapElemv+i, mapElemv+i+1, &done);
 	}
@@ -2011,14 +2011,14 @@
 	 * repeated function calls later, significantly speeding up the
 	 * algorithm. We only need the lowercase first char in the nocase
 	 * case.
 	 */
 
-	mapStrings = TclStackAlloc(interp, mapElemc*2*sizeof(Tcl_UniChar *));
-	mapLens = TclStackAlloc(interp, mapElemc * 2 * sizeof(int));
+	mapStrings = ckalloc(mapElemc*2*sizeof(Tcl_UniChar *));
+	mapLens = ckalloc(mapElemc * 2 * sizeof(int));
 	if (nocase) {
-	    u2lc = TclStackAlloc(interp, mapElemc * sizeof(Tcl_UniChar));
+	    u2lc = ckalloc(mapElemc * sizeof(Tcl_UniChar));
 	}
 	for (index = 0; index < mapElemc; index++) {
 	    mapStrings[index] = Tcl_GetUnicodeFromObj(mapElemv[index],
 		    mapLens+index);
 	    if (nocase && ((index % 2) == 0)) {
@@ -2064,14 +2064,14 @@
 		    break;
 		}
 	    }
 	}
 	if (nocase) {
-	    TclStackFree(interp, u2lc);
+	    ckfree(u2lc);
 	}
-	TclStackFree(interp, mapLens);
-	TclStackFree(interp, mapStrings);
+	ckfree(mapLens);
+	ckfree(mapStrings);
     }
     if (p != ustring1) {
 	/*
 	 * Put the rest of the unmapped chars onto result.
 	 */
@@ -2079,11 +2079,11 @@
 	Tcl_AppendUnicodeToObj(resultPtr, p, ustring1 - p);
     }
     Tcl_SetObjResult(interp, resultPtr);
   done:
     if (mapWithDict) {
-	TclStackFree(interp, mapElemv);
+	ckfree(mapElemv);
     }
     if (copySource) {
 	Tcl_DecrRefCount(sourceObj);
     }
     return TCL_OK;
@@ -3478,16 +3478,10 @@
     int noCase, patternLength;
     const char *pattern;
     Tcl_Obj *stringObj, *indexVarObj, *matchVarObj;
     Tcl_Obj *const *savedObjv = objv;
     Tcl_RegExp regExpr = NULL;
-    Interp *iPtr = (Interp *) interp;
-    int pc = 0;
-    int bidx = 0;		/* Index of body argument. */
-    Tcl_Obj *blist = NULL;	/* List obj which is the body */
-    CmdFrame *ctxPtr;		/* Copy of the topmost cmdframe, to allow us
-				 * to mess with the line information */
 
     /*
      * If you add options that make -e and -g not unique prefixes of -exact or
      * -glob, you *must* fix TclCompileSwitchCmd's option parser as well.
      */
@@ -3607,26 +3601,20 @@
     }
 
     stringObj = objv[i];
     objc -= i + 1;
     objv += i + 1;
-    bidx = i + 1;		/* First after the match string. */
 
     /*
      * If all of the pattern/command pairs are lumped into a single argument,
      * split them out again.
-     *
-     * TIP #280: Determine the lines the words in the list start at, based on
-     * the same data for the list word itself. The cmdFramePtr line
-     * information is manipulated directly.
      */
 
     splitObjs = 0;
     if (objc == 1) {
 	Tcl_Obj **listv;
 
-	blist = objv[0];
 	if (TclListObjGetElements(interp, objv[0], &objc, &listv) != TCL_OK){
 	    return TCL_ERROR;
 	}
 
 	/*
@@ -3850,62 +3838,10 @@
      * We've got a match. Find a body to execute, skipping bodies that are
      * "-".
      */
 
   matchFound:
-    ctxPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-    *ctxPtr = *iPtr->cmdFramePtr;
-
-    if (splitObjs) {
-	/*
-	 * We have to perform the GetSrc and other type dependent handling of
-	 * the frame here because we are munging with the line numbers,
-	 * something the other commands like if, etc. are not doing. Them are
-	 * fine with simply passing the CmdFrame through and having the
-	 * special handling done in 'info frame', or the bc compiler
-	 */
-
-	if (ctxPtr->type == TCL_LOCATION_BC) {
-	    /*
-	     * Type BC => ctxPtr->data.eval.path    is not used.
-	     *		  ctxPtr->data.tebc.codePtr is used instead.
-	     */
-
-	    TclGetSrcInfoForPc(ctxPtr);
-	    pc = 1;
-
-	    /*
-	     * The line information in the cmdFrame is now a copy we do not
-	     * own.
-	     */
-	}
-
-	if (ctxPtr->type == TCL_LOCATION_SOURCE && ctxPtr->line[bidx] >= 0) {
-	    int bline = ctxPtr->line[bidx];
-
-	    ctxPtr->line = ckalloc(objc * sizeof(int));
-	    ctxPtr->nline = objc;
-	    TclListLines(blist, bline, objc, ctxPtr->line, objv);
-	} else {
-	    /*
-	     * This is either a dynamic code word, when all elements are
-	     * relative to themselves, or something else less expected and
-	     * where we have no information. The result is the same in both
-	     * cases; tell the code to come that it doesn't know where it is,
-	     * which triggers reversion to the old behavior.
-	     */
-
-	    int k;
-
-	    ctxPtr->line = ckalloc(objc * sizeof(int));
-	    ctxPtr->nline = objc;
-	    for (k=0; k < objc; k++) {
-		ctxPtr->line[k] = -1;
-	    }
-	}
-    }
-
     for (j = i + 1; ; j += 2) {
 	if (j >= objc) {
 	    /*
 	     * This shouldn't happen since we've checked that the last body is
 	     * not a continuation...
@@ -3916,17 +3852,12 @@
 	if (strcmp(TclGetString(objv[j]), "-") != 0) {
 	    break;
 	}
     }
 
-    /*
-     * TIP #280: Make invoking context available to switch branch.
-     */
-
-    Tcl_NRAddCallback(interp, SwitchPostProc, INT2PTR(splitObjs), ctxPtr,
-	    INT2PTR(pc), (ClientData) pattern);
-    return TclNREvalObjEx(interp, objv[j], 0, ctxPtr, splitObjs ? j : bidx+j);
+    Tcl_NRAddCallback(interp, SwitchPostProc, (ClientData) pattern, NULL, NULL, NULL);
+    return TclNREvalObjEx(interp, objv[j], 0);
 }
 
 static int
 SwitchPostProc(
     ClientData data[],		/* Data passed from Tcl_NRAddCallback above */
@@ -3933,31 +3864,13 @@
     Tcl_Interp *interp,		/* Tcl interpreter */
     int result)			/* Result to return*/
 {
     /* Unpack the preserved data */
 
-    int splitObjs = PTR2INT(data[0]);
-    CmdFrame *ctxPtr = data[1];
-    int pc = PTR2INT(data[2]);
-    const char *pattern = data[3];
+    const char *pattern = data[0];
     int patternLength = strlen(pattern);
 
-    /*
-     * Clean up TIP 280 context information
-     */
-
-    if (splitObjs) {
-	ckfree(ctxPtr->line);
-	if (pc && (ctxPtr->type == TCL_LOCATION_SOURCE)) {
-	    /*
-	     * Death of SrcInfo reference.
-	     */
-
-	    Tcl_DecrRefCount(ctxPtr->data.eval.path);
-	}
-    }
-
     /*
      * Generate an error message if necessary.
      */
 
     if (result == TCL_ERROR) {
@@ -3967,11 +3880,10 @@
 	Tcl_AppendObjToErrorInfo(interp, Tcl_ObjPrintf(
 		"\n    (\"%.*s%s\" arm line %d)",
 		(overflow ? limit : patternLength), pattern,
 		(overflow ? "..." : ""), Tcl_GetErrorLine(interp)));
     }
-    TclStackFree(interp, ctxPtr);
     return result;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -4296,12 +4208,11 @@
      * Execute the body.
      */
 
     Tcl_NRAddCallback(interp, TryPostBody, handlersObj, finallyObj,
 	    (ClientData)objv, INT2PTR(objc));
-    return TclNREvalObjEx(interp, bodyObj, 0,
-	    ((Interp *) interp)->cmdFramePtr, 1);
+    return TclNREvalObjEx(interp, bodyObj, 0);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -4512,12 +4423,11 @@
 
 	    handlerBodyObj = info[4];
 	    Tcl_NRAddCallback(interp, TryPostHandler, objv, options, info[0],
 		    INT2PTR((finallyObj == NULL) ? 0 : objc - 1));
 	    Tcl_DecrRefCount(handlersObj);
-	    return TclNREvalObjEx(interp, handlerBodyObj, 0,
-		    ((Interp *) interp)->cmdFramePtr, 4*i + 5);
+	    return TclNREvalObjEx(interp, handlerBodyObj, 0);
 
 	handlerFailed:
 	    resultObj = Tcl_GetObjResult(interp);
 	    Tcl_IncrRefCount(resultObj);
 	    options = During(interp, result, options, NULL);
@@ -4539,12 +4449,11 @@
      */
 
     if (finallyObj != NULL) {
 	Tcl_NRAddCallback(interp, TryPostFinal, resultObj, options, cmdObj,
 		NULL);
-	return TclNREvalObjEx(interp, finallyObj, 0,
-		((Interp *) interp)->cmdFramePtr, objc - 1);
+	return TclNREvalObjEx(interp, finallyObj, 0);
     }
 
     /*
      * Install the correct result/options into the interpreter and clean up
      * any temporary storage.
@@ -4619,18 +4528,15 @@
     /*
      * Process the finally clause if it is present.
      */
 
     if (finallyObj != NULL) {
-	Interp *iPtr = (Interp *) interp;
-
 	Tcl_NRAddCallback(interp, TryPostFinal, resultObj, options, cmdObj,
 		NULL);
 
 	/* The 'finally' script is always the last argument word. */
-	return TclNREvalObjEx(interp, finallyObj, 0, iPtr->cmdFramePtr,
-		finally);
+	return TclNREvalObjEx(interp, finallyObj, 0);
     }
 
     /*
      * Install the correct result/options into the interpreter and clean up
      * any temporary storage.
@@ -4747,80 +4653,23 @@
 
     /*
      * We reuse [for]'s callback, passing a NULL for the 'next' script.
      */
 
-    TclSmallAllocEx(interp, sizeof(ForIterData), iterPtr);
+    TclCkSmallAlloc(sizeof(ForIterData), iterPtr);
     iterPtr->cond = objv[1];
     iterPtr->body = objv[2];
     iterPtr->next = NULL;
     iterPtr->msg  = "\n    (\"while\" body line %d)";
-    iterPtr->word = 2;
 
     TclNRAddCallback(interp, TclNRForIterCallback, iterPtr, NULL,
 	    NULL, NULL);
     return TCL_OK;
 }
-
-/*
- *----------------------------------------------------------------------
- *
- * TclListLines --
- *
- *	???
- *
- * Results:
- *	Filled in array of line numbers?
- *
- * Side effects:
- *	None.
- *
- *----------------------------------------------------------------------
- */
-
-void
-TclListLines(
-    Tcl_Obj *listObj,		/* Pointer to obj holding a string with list
-				 * structure. Assumed to be valid. Assumed to
-				 * contain n elements. */
-    int line,			/* Line the list as a whole starts on. */
-    int n,			/* #elements in lines */
-    int *lines,			/* Array of line numbers, to fill. */
-    Tcl_Obj *const *elems)      /* The list elems as Tcl_Obj*, in need of
-				 * derived continuation data */
-{
-    const char *listStr = Tcl_GetString(listObj);
-    const char *listHead = listStr;
-    int i, length = strlen(listStr);
-    const char *element = NULL, *next = NULL;
-    ContLineLoc *clLocPtr = TclContinuationsGet(listObj);
-    int *clNext = (clLocPtr ? &clLocPtr->loc[0] : NULL);
-
-    for (i = 0; i < n; i++) {
-	TclFindElement(NULL, listStr, length, &element, &next, NULL, NULL);
-
-	TclAdvanceLines(&line, listStr, element);
-				/* Leading whitespace */
-	TclAdvanceContinuations(&line, &clNext, element - listHead);
-	if (elems && clNext) {
-	    TclContinuationsEnterDerived(elems[i], element-listHead, clNext);
-	}
-	lines[i] = line;
-	length -= (next - listStr);
-	TclAdvanceLines(&line, element, next);
-				/* Element */
-	listStr = next;
-
-	if (*element == 0) {
-	    /* ASSERT i == n */
-	    break;
-	}
-    }
-}
 
 /*
  * Local Variables:
  * mode: c
  * c-basic-offset: 4
  * fill-column: 78
  * End:
  */

Index: generic/tclCompCmds.c
==================================================================
--- generic/tclCompCmds.c
+++ generic/tclCompCmds.c
@@ -37,12 +37,11 @@
 static int		IndexTailVarIfKnown(Tcl_Interp *interp,
 			    Tcl_Token *varTokenPtr, CompileEnv *envPtr);
 static int		PushVarName(Tcl_Interp *interp,
 			    Tcl_Token *varTokenPtr, CompileEnv *envPtr,
 			    int flags, int *localIndexPtr,
-			    int *simpleVarNamePtr, int *isScalarPtr,
-			    int line, int *clNext);
+			    int *simpleVarNamePtr, int *isScalarPtr);
 static int		CompileEachloopCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, Command *cmdPtr,
 			    CompileEnv *envPtr, int collect);
 static int		CompileDictEachCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, Command *cmdPtr,
@@ -52,46 +51,22 @@
 /*
  * Macro that encapsulates an efficiency trick that avoids a function call for
  * the simplest of compiles. The ANSI C "prototype" for this macro is:
  *
  * static void		CompileWord(CompileEnv *envPtr, Tcl_Token *tokenPtr,
- *			    Tcl_Interp *interp, int word);
+ *			    Tcl_Interp *interp);
  */
 
-#define CompileWord(envPtr, tokenPtr, interp, word) \
+#define CompileWord(envPtr, tokenPtr, interp) \
     if ((tokenPtr)->type == TCL_TOKEN_SIMPLE_WORD) {			\
 	TclEmitPush(TclRegisterNewLiteral((envPtr), (tokenPtr)[1].start, \
 		(tokenPtr)[1].size), (envPtr));				\
     } else {								\
-	envPtr->line = mapPtr->loc[eclIndex].line[word];		\
-	envPtr->clNext = mapPtr->loc[eclIndex].next[word];		\
 	TclCompileTokens((interp), (tokenPtr)+1, (tokenPtr)->numComponents, \
 		(envPtr));						\
     }
 
-/*
- * TIP #280: Remember the per-word line information of the current command. An
- * index is used instead of a pointer as recursive compilation may reallocate,
- * i.e. move, the array. This is also the reason to save the nuloc now, it may
- * change during the course of the function.
- *
- * Macro to encapsulate the variable definition and setup.
- */
-
-#define DefineLineInformation \
-    ExtCmdLoc *mapPtr = envPtr->extCmdMapPtr;				\
-    int eclIndex = mapPtr->nuloc - 1
-
-#define SetLineInformation(word) \
-    envPtr->line = mapPtr->loc[eclIndex].line[(word)];			\
-    envPtr->clNext = mapPtr->loc[eclIndex].next[(word)]
-
-#define PushVarNameWord(i,v,e,f,l,s,sc,word) \
-    PushVarName(i,v,e,f,l,s,sc,						\
-	    mapPtr->loc[eclIndex].line[(word)],				\
-	    mapPtr->loc[eclIndex].next[(word)])
-
 /*
  * Often want to issue one of two versions of an instruction based on whether
  * the argument will fit in a single byte or not. This makes it much clearer.
  */
 
@@ -153,11 +128,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr, *valueTokenPtr;
     int simpleVarName, isScalar, localIndex, numWords;
-    DefineLineInformation;	/* TIP #280 */
 
     numWords = parsePtr->numWords;
     if (numWords == 1) {
 	return TCL_ERROR;
     } else if (numWords == 2) {
@@ -182,22 +156,22 @@
      * qualifiers.
      */
 
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
 
-    PushVarNameWord(interp, varTokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, varTokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
 
     /*
      * We are doing an assignment, otherwise TclCompileSetCmd was called, so
      * push the new value. This will need to be extended to push a value for
      * each argument.
      */
 
     if (numWords > 2) {
 	valueTokenPtr = TokenAfter(varTokenPtr);
-	CompileWord(envPtr, valueTokenPtr, interp, 2);
+	CompileWord(envPtr, valueTokenPtr, interp);
     }
 
     /*
      * Emit instructions to set/get the variable.
      */
@@ -248,21 +222,20 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     int simpleVarName, isScalar, localIndex;
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    PushVarNameWord(interp, tokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, tokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
     if (!isScalar) {
 	return TCL_ERROR;
     }
 
     if (localIndex >= 0) {
@@ -280,11 +253,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     int simpleVarName, isScalar, localIndex;
     int dataVar, iterVar, keyVar, valVar, infoIndex;
     int back, fwd, offsetBack, offsetFwd, savedStackDepth;
     ForeachInfo *infoPtr;
@@ -292,12 +264,12 @@
     if (parsePtr->numWords != 3) {
 	return TCL_ERROR;
     }
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    PushVarNameWord(interp, tokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, tokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
     if (!isScalar) {
 	return TCL_ERROR;
     }
     tokenPtr = TokenAfter(tokenPtr);
 
@@ -349,11 +321,11 @@
 
     /*
      * Start issuing instructions to write to the array.
      */
 
-    CompileWord(envPtr, tokenPtr, interp, 2);
+    CompileWord(envPtr, tokenPtr, interp);
     TclEmitOpcode(	INST_DUP,				envPtr);
     TclEmitOpcode(	INST_LIST_LENGTH,			envPtr);
     PushLiteral(envPtr, "1", 1);
     TclEmitOpcode(	INST_BITAND,				envPtr);
     offsetFwd = CurrentOffset(envPtr);
@@ -427,20 +399,19 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr = TokenAfter(parsePtr->tokenPtr);
     int simpleVarName, isScalar, localIndex, savedStackDepth;
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
 
-    PushVarNameWord(interp, tokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, tokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
     if (!isScalar) {
 	return TCL_ERROR;
     }
 
     if (localIndex >= 0) {
@@ -533,11 +504,10 @@
     Tcl_Token *cmdTokenPtr, *resultNameTokenPtr, *optsNameTokenPtr;
     const char *name;
     int resultIndex, optsIndex, nameChars, range;
     int initStackDepth = envPtr->currStackDepth;
     int savedStackDepth;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * If syntax does not match what we expect for [catch], do not compile.
      * Let runtime checks determine if syntax has changed.
      */
@@ -617,11 +587,10 @@
      * [Bug 219184]
      * The reason for duplicating the script is that EVAL_STK would otherwise
      * begin by undeflowing the stack below the mark set by BEGIN_CATCH4.
      */
 
-    SetLineInformation(1);
     if (cmdTokenPtr->type == TCL_TOKEN_SIMPLE_WORD) {
 	savedStackDepth = envPtr->currStackDepth;
 	TclEmitInstInt4(	INST_BEGIN_CATCH4, range,	envPtr);
 	ExceptionRangeStarts(envPtr, range);
 	CompileBody(envPtr, cmdTokenPtr, interp);
@@ -836,11 +805,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
     int numWords, i;
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *varTokenPtr;
     int dictVarIndex, nameChars;
     const char *name;
 
     /*
@@ -876,11 +844,11 @@
      */
 
     tokenPtr = TokenAfter(varTokenPtr);
     numWords = parsePtr->numWords-1;
     for (i=1 ; i<numWords ; i++) {
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
 	tokenPtr = TokenAfter(tokenPtr);
     }
 
     /*
      * Now emit the instruction to do the dict manipulation.
@@ -899,11 +867,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *varTokenPtr, *keyTokenPtr;
     int dictVarIndex, nameChars, incrAmount;
     const char *name;
 
     /*
@@ -965,11 +932,11 @@
 
     /*
      * Emit the key and the code to actually do the increment.
      */
 
-    CompileWord(envPtr, keyTokenPtr, interp, 3);
+    CompileWord(envPtr, keyTokenPtr, interp);
     TclEmitInstInt4( INST_DICT_INCR_IMM, incrAmount,	envPtr);
     TclEmitInt4(     dictVarIndex,			envPtr);
     return TCL_OK;
 }
 
@@ -982,11 +949,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
     int numWords, i;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * There must be at least two arguments after the command (the single-arg
      * case is legal, but too special and magic for us to deal with here).
      */
@@ -1000,11 +966,11 @@
     /*
      * Only compile this because we need INST_DICT_GET anyway.
      */
 
     for (i=0 ; i<numWords ; i++) {
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
 	tokenPtr = TokenAfter(tokenPtr);
     }
     TclEmitInstInt4(INST_DICT_GET, numWords-1, envPtr);
     TclAdjustStackDepth(-1, envPtr);
     return TCL_OK;
@@ -1019,11 +985,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
     int numWords, i;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * There must be at least two arguments after the command (the single-arg
      * case is legal, but too special and magic for us to deal with here).
      */
@@ -1037,11 +1002,11 @@
     /*
      * Now we do the code generation.
      */
 
     for (i=0 ; i<numWords ; i++) {
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
 	tokenPtr = TokenAfter(tokenPtr);
     }
     TclEmitInstInt4(INST_DICT_EXISTS, numWords-1, envPtr);
     TclAdjustStackDepth(-1, envPtr);
     return TCL_OK;
@@ -1055,11 +1020,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     int i, dictVarIndex, nameChars;
     const char *name;
 
     /*
      * There must be at least one argument after the variable name for us to
@@ -1094,11 +1058,11 @@
      * Remaining words (the key path) can be handled normally.
      */
 
     for (i=2 ; i<parsePtr->numWords ; i++) {
 	tokenPtr = TokenAfter(tokenPtr);
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
     }
 
     /*
      * Now emit the instruction to do the dict manipulation.
      */
@@ -1115,11 +1079,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     int worker;			/* Temp var for building the value in. */
     Tcl_Token *tokenPtr;
     Tcl_Obj *keyObj, *valueObj, *dictObj;
     const char *bytes;
     int i, len;
@@ -1184,13 +1147,13 @@
     PushLiteral(envPtr,		"", 0);
     Emit14Inst(			INST_STORE_SCALAR, worker,	envPtr);
     TclEmitOpcode(		INST_POP,			envPtr);
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
     for (i=1 ; i<parsePtr->numWords ; i+=2) {
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
 	tokenPtr = TokenAfter(tokenPtr);
-	CompileWord(envPtr, tokenPtr, interp, i+1);
+	CompileWord(envPtr, tokenPtr, interp);
 	tokenPtr = TokenAfter(tokenPtr);
 	TclEmitInstInt4(	INST_DICT_SET, 1,		envPtr);
 	TclEmitInt4(			worker,			envPtr);
 	TclAdjustStackDepth(-1, envPtr);
 	TclEmitOpcode(		INST_POP,			envPtr);
@@ -1208,11 +1171,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     int i, workerIndex, infoIndex, outLoop;
 
     /*
      * Deal with some special edge cases. Note that in the case with one
@@ -1222,11 +1184,11 @@
     if (parsePtr->numWords < 2) {
 	PushLiteral(envPtr, "", 0);
 	return TCL_OK;
     } else if (parsePtr->numWords == 2) {
 	tokenPtr = TokenAfter(parsePtr->tokenPtr);
-	CompileWord(envPtr, tokenPtr, interp, 1);
+	CompileWord(envPtr, tokenPtr, interp);
 	TclEmitOpcode(		INST_DUP,			envPtr);
 	TclEmitOpcode(		INST_DICT_VERIFY,		envPtr);
 	return TCL_OK;
     }
 
@@ -1246,11 +1208,11 @@
     /*
      * Get the first dictionary and verify that it is so.
      */
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    CompileWord(envPtr, tokenPtr, interp, 1);
+    CompileWord(envPtr, tokenPtr, interp);
     TclEmitOpcode(		INST_DUP,			envPtr);
     TclEmitOpcode(		INST_DICT_VERIFY,		envPtr);
     Emit14Inst(			INST_STORE_SCALAR, workerIndex,	envPtr);
     TclEmitOpcode(		INST_POP,			envPtr);
 
@@ -1266,11 +1228,11 @@
 	 * Get the dictionary, and merge its pairs into the first dict (using
 	 * a small loop).
 	 */
 
 	tokenPtr = TokenAfter(tokenPtr);
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
 	TclEmitInstInt4(	INST_DICT_FIRST, infoIndex,	envPtr);
 	TclEmitInstInt1(	INST_JUMP_TRUE1, 24,		envPtr);
 	TclEmitInstInt4(	INST_REVERSE, 2,		envPtr);
 	TclEmitInstInt4(	INST_DICT_SET, 1,		envPtr);
 	TclEmitInt4(			workerIndex,		envPtr);
@@ -1349,11 +1311,10 @@
     CompileEnv *envPtr,		/* Holds resulting instructions. */
     int collect)		/* Flag == TCL_EACH_COLLECT to collect and
 				 * construct a new dictionary with the loop
 				 * body result. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *varsTokenPtr, *dictTokenPtr, *bodyTokenPtr;
     int keyVarIndex, valueVarIndex, nameChars, loopRange, catchRange;
     int infoIndex, jumpDisplacement, bodyTargetOffset, emptyTargetOffset;
     int numVars, endTargetOffset;
     int collectVar = -1;	/* Index of temp var holding the result
@@ -1458,11 +1419,11 @@
     /*
      * Get the dictionary and start the iteration. No catching of errors at
      * this point.
      */
 
-    CompileWord(envPtr, dictTokenPtr, interp, 3);
+    CompileWord(envPtr, dictTokenPtr, interp);
     TclEmitInstInt4(	INST_DICT_FIRST, infoIndex,		envPtr);
     emptyTargetOffset = CurrentOffset(envPtr);
     TclEmitInstInt4(	INST_JUMP_TRUE4, 0,			envPtr);
 
     /*
@@ -1493,11 +1454,10 @@
 
     /*
      * Compile the loop body itself. It should be stack-neutral.
      */
 
-    SetLineInformation(3);
     CompileBody(envPtr, bodyTokenPtr, interp);
     if (collect == TCL_EACH_COLLECT) {
 	Emit14Inst(	INST_LOAD_SCALAR, keyVarIndex,		envPtr);
 	TclEmitInstInt4(INST_OVER, 1,				envPtr);
 	TclEmitInstInt4(INST_DICT_SET, 1,			envPtr);
@@ -1600,11 +1560,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     const char *name;
     int i, nameChars, dictIndex, numVars, range, infoIndex;
     Tcl_Token **keyTokenPtrs, *dictVarTokenPtr, *bodyTokenPtr, *tokenPtr;
     int savedStackDepth = envPtr->currStackDepth;
     DictUpdateInfo *duiPtr;
@@ -1654,12 +1613,11 @@
      * that are to be used.
      */
 
     duiPtr = ckalloc(sizeof(DictUpdateInfo) + sizeof(int) * (numVars - 1));
     duiPtr->length = numVars;
-    keyTokenPtrs = TclStackAlloc(interp,
-	    sizeof(Tcl_Token *) * numVars);
+    keyTokenPtrs = ckalloc(sizeof(Tcl_Token *) * numVars);
     tokenPtr = TokenAfter(dictVarTokenPtr);
 
     for (i=0 ; i<numVars ; i++) {
 	/*
 	 * Put keys to one side for later compilation to bytecode.
@@ -1693,11 +1651,11 @@
 	tokenPtr = TokenAfter(tokenPtr);
     }
     if (tokenPtr->type != TCL_TOKEN_SIMPLE_WORD) {
     failedUpdateInfoAssembly:
 	ckfree(duiPtr);
-	TclStackFree(interp, keyTokenPtrs);
+	ckfree(keyTokenPtrs);
 	return TCL_ERROR;
     }
     bodyTokenPtr = tokenPtr;
 
     /*
@@ -1706,11 +1664,11 @@
      */
 
     infoIndex = TclCreateAuxData(duiPtr, &tclDictUpdateInfoType, envPtr);
 
     for (i=0 ; i<numVars ; i++) {
-	CompileWord(envPtr, keyTokenPtrs[i], interp, i);
+	CompileWord(envPtr, keyTokenPtrs[i], interp);
     }
     TclEmitInstInt4(	INST_LIST, numVars,			envPtr);
     TclEmitInstInt4(	INST_DICT_UPDATE_START, dictIndex,	envPtr);
     TclEmitInt4(	infoIndex,				envPtr);
 
@@ -1717,11 +1675,10 @@
     range = DeclareExceptionRange(envPtr, CATCH_EXCEPTION_RANGE);
     TclEmitInstInt4(	INST_BEGIN_CATCH4, range,		envPtr);
 
     ExceptionRangeStarts(envPtr, range);
     envPtr->currStackDepth++;
-    SetLineInformation(parsePtr->numWords - 1);
     CompileBody(envPtr, bodyTokenPtr, interp);
     envPtr->currStackDepth = savedStackDepth;
     ExceptionRangeEnds(envPtr, range);
 
     /*
@@ -1758,11 +1715,11 @@
 
     if (TclFixupForwardJumpToHere(envPtr, &jumpFixup, 127)) {
 	Tcl_Panic("TclCompileDictCmd(update): bad jump distance %d",
 		(int) (CurrentOffset(envPtr) - jumpFixup.codeOffset));
     }
-    TclStackFree(interp, keyTokenPtrs);
+    ckfree(keyTokenPtrs);
     envPtr->currStackDepth = savedStackDepth + 1;
     return TCL_OK;
 }
 
 int
@@ -1772,11 +1729,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     int i, dictVarIndex;
 
     /*
      * There must be at least two argument after the command. And we impose an
@@ -1812,11 +1768,11 @@
      * Produce the string to concatenate onto the dictionary entry.
      */
 
     tokenPtr = TokenAfter(tokenPtr);
     for (i=2 ; i<parsePtr->numWords ; i++) {
-	CompileWord(envPtr, tokenPtr, interp, i);
+	CompileWord(envPtr, tokenPtr, interp);
 	tokenPtr = TokenAfter(tokenPtr);
     }
     if (parsePtr->numWords > 4) {
 	TclEmitInstInt1(INST_CONCAT1, parsePtr->numWords-3, envPtr);
     }
@@ -1836,11 +1792,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *varTokenPtr, *keyTokenPtr, *valueTokenPtr;
     int dictVarIndex, nameChars;
     const char *name;
 
     /*
@@ -1864,12 +1819,12 @@
     }
     dictVarIndex = TclFindCompiledLocal(name, nameChars, 1, envPtr);
     if (dictVarIndex < 0) {
 	return TCL_ERROR;
     }
-    CompileWord(envPtr, keyTokenPtr, interp, 3);
-    CompileWord(envPtr, valueTokenPtr, interp, 4);
+    CompileWord(envPtr, keyTokenPtr, interp);
+    CompileWord(envPtr, valueTokenPtr, interp);
     TclEmitInstInt4(	INST_DICT_LAPPEND, dictVarIndex,	envPtr);
     return TCL_OK;
 }
 
 int
@@ -1879,11 +1834,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     int i, range, varNameTmp, pathTmp, keysTmp, gotPath, dictVar = -1;
     int bodyIsEmpty = 1;
     Tcl_Token *varTokenPtr, *tokenPtr;
     int savedStackDepth = envPtr->currStackDepth;
     JumpFixup jumpFixup;
@@ -1953,11 +1907,11 @@
 		 * Case: Path into dict in LVT with empty body.
 		 */
 
 		tokenPtr = TokenAfter(varTokenPtr);
 		for (i=2 ; i<parsePtr->numWords-1 ; i++) {
-		    CompileWord(envPtr, tokenPtr, interp, i-1);
+		    CompileWord(envPtr, tokenPtr, interp);
 		    tokenPtr = TokenAfter(tokenPtr);
 		}
 		TclEmitInstInt4(INST_LIST, parsePtr->numWords-3,envPtr);
 		Emit14Inst(	INST_LOAD_SCALAR, dictVar,	envPtr);
 		TclEmitInstInt4(INST_OVER, 1,			envPtr);
@@ -1982,11 +1936,11 @@
 		 * Case: Path into dict in non-simple var with empty body.
 		 */
 
 		tokenPtr = varTokenPtr;
 		for (i=1 ; i<parsePtr->numWords-1 ; i++) {
-		    CompileWord(envPtr, tokenPtr, interp, i-1);
+		    CompileWord(envPtr, tokenPtr, interp);
 		    tokenPtr = TokenAfter(tokenPtr);
 		}
 		TclEmitInstInt4(INST_LIST, parsePtr->numWords-3,envPtr);
 		TclEmitInstInt4(INST_OVER, 1,			envPtr);
 		TclEmitOpcode(	INST_LOAD_STK,			envPtr);
@@ -1997,11 +1951,11 @@
 	    } else {
 		/*
 		 * Case: Direct dict in non-simple var with empty body.
 		 */
 
-		CompileWord(envPtr, varTokenPtr, interp, 0);
+		CompileWord(envPtr, varTokenPtr, interp);
 		TclEmitOpcode(	INST_DUP,			envPtr);
 		TclEmitOpcode(	INST_LOAD_STK,			envPtr);
 		PushLiteral(envPtr, "", 0);
 		TclEmitOpcode(	INST_DICT_EXPAND,		envPtr);
 		PushLiteral(envPtr, "", 0);
@@ -2037,17 +1991,17 @@
     /*
      * Issue instructions. First, the part to expand the dictionary.
      */
 
     if (varNameTmp > -1) {
-	CompileWord(envPtr, varTokenPtr, interp, 0);
+	CompileWord(envPtr, varTokenPtr, interp);
 	Emit14Inst(		INST_STORE_SCALAR, varNameTmp,	envPtr);
     }
     tokenPtr = TokenAfter(varTokenPtr);
     if (gotPath) {
 	for (i=2 ; i<parsePtr->numWords-1 ; i++) {
-	    CompileWord(envPtr, tokenPtr, interp, i-1);
+	    CompileWord(envPtr, tokenPtr, interp);
 	    tokenPtr = TokenAfter(tokenPtr);
 	}
 	TclEmitInstInt4(	INST_LIST, parsePtr->numWords-3,envPtr);
 	Emit14Inst(		INST_STORE_SCALAR, pathTmp,	envPtr);
 	TclEmitOpcode(		INST_POP,			envPtr);
@@ -2073,11 +2027,10 @@
     range = DeclareExceptionRange(envPtr, CATCH_EXCEPTION_RANGE);
     TclEmitInstInt4(		INST_BEGIN_CATCH4, range,	envPtr);
 
     ExceptionRangeStarts(envPtr, range);
     envPtr->currStackDepth++;
-    SetLineInformation(parsePtr->numWords-1);
     CompileBody(envPtr, tokenPtr, interp);
     envPtr->currStackDepth = savedStackDepth;
     ExceptionRangeEnds(envPtr, range);
 
     /*
@@ -2228,19 +2181,18 @@
      * General syntax: [error message ?errorInfo? ?errorCode?]
      * However, we only deal with the case where there is just a message.
      */
     Tcl_Token *messageTokenPtr;
     int savedStackDepth = envPtr->currStackDepth;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
     messageTokenPtr = TokenAfter(parsePtr->tokenPtr);
 
     PushLiteral(envPtr, "-code error -level 0", 20);
-    CompileWord(envPtr, messageTokenPtr, interp, 1);
+    CompileWord(envPtr, messageTokenPtr, interp);
     TclEmitOpcode(INST_RETURN_STK, envPtr);
     envPtr->currStackDepth = savedStackDepth + 1;
     return TCL_OK;
 }
 
@@ -2275,17 +2227,10 @@
 
     if (parsePtr->numWords == 1) {
 	return TCL_ERROR;
     }
 
-    /*
-     * TIP #280: Use the per-word line information of the current command.
-     */
-
-    envPtr->line = envPtr->extCmdMapPtr->loc[
-	    envPtr->extCmdMapPtr->nuloc-1].line[1];
-
     firstWordPtr = TokenAfter(parsePtr->tokenPtr);
     TclCompileExprWords(interp, firstWordPtr, parsePtr->numWords-1, envPtr);
     return TCL_OK;
 }
 
@@ -2319,11 +2264,10 @@
     Tcl_Token *startTokenPtr, *testTokenPtr, *nextTokenPtr, *bodyTokenPtr;
     JumpFixup jumpEvalCondFixup;
     int testCodeOffset, bodyCodeOffset, nextCodeOffset, jumpDist;
     int bodyRange, nextRange;
     int savedStackDepth = envPtr->currStackDepth;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 5) {
 	return TCL_ERROR;
     }
 
@@ -2362,11 +2306,10 @@
 
     /*
      * Inline compile the initial command.
      */
 
-    SetLineInformation(1);
     CompileBody(envPtr, startTokenPtr, interp);
     TclEmitOpcode(INST_POP, envPtr);
 
     /*
      * Jump to the evaluation of the condition. This code uses the "loop
@@ -2385,11 +2328,10 @@
     /*
      * Compile the loop body.
      */
 
     bodyCodeOffset = ExceptionRangeStarts(envPtr, bodyRange);
-    SetLineInformation(4);
     CompileBody(envPtr, bodyTokenPtr, interp);
     ExceptionRangeEnds(envPtr, bodyRange);
     envPtr->currStackDepth = savedStackDepth + 1;
     TclEmitOpcode(INST_POP, envPtr);
 
@@ -2397,11 +2339,10 @@
      * Compile the "next" subcommand.
      */
 
     envPtr->currStackDepth = savedStackDepth;
     nextCodeOffset = ExceptionRangeStarts(envPtr, nextRange);
-    SetLineInformation(3);
     CompileBody(envPtr, nextTokenPtr, interp);
     ExceptionRangeEnds(envPtr, nextRange);
     envPtr->currStackDepth = savedStackDepth + 1;
     TclEmitOpcode(INST_POP, envPtr);
     envPtr->currStackDepth = savedStackDepth;
@@ -2418,11 +2359,10 @@
 	bodyCodeOffset += 3;
 	nextCodeOffset += 3;
 	testCodeOffset += 3;
     }
 
-    SetLineInformation(2);
     envPtr->currStackDepth = savedStackDepth;
     TclCompileExprWords(interp, testTokenPtr, 1, envPtr);
     envPtr->currStackDepth = savedStackDepth + 1;
 
     jumpDist = CurrentOffset(envPtr) - bodyCodeOffset;
@@ -2527,14 +2467,13 @@
 				 * index. */
 
     Tcl_Token *tokenPtr, *bodyTokenPtr;
     unsigned char *jumpPc;
     JumpFixup jumpFalseFixup;
-    int jumpBackDist, jumpBackOffset, infoIndex, range, bodyIndex;
+    int jumpBackDist, jumpBackOffset, infoIndex, range;
     int numWords, numLists, numVars, loopIndex, tempVar, i, j, code;
     int savedStackDepth = envPtr->currStackDepth;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * We parse the variable list argument words and create two arrays:
      *    varcList[i] is number of variables in i-th var list.
      *    varvList[i] points to array of var names in i-th var list.
@@ -2568,21 +2507,18 @@
     bodyTokenPtr = tokenPtr;
     if (bodyTokenPtr->type != TCL_TOKEN_SIMPLE_WORD) {
 	return TCL_ERROR;
     }
 
-    bodyIndex = i-1;
-
     /*
      * Allocate storage for the varcList and varvList arrays if necessary.
      */
 
     numLists = (numWords - 2)/2;
-    varcList = TclStackAlloc(interp, numLists * sizeof(int));
+    varcList = ckalloc(numLists * sizeof(int));
     memset(varcList, 0, numLists * sizeof(int));
-    varvList = (const char ***) TclStackAlloc(interp,
-	    numLists * sizeof(const char **));
+    varvList = (const char ***) ckalloc(numLists * sizeof(const char **));
     memset((char*) varvList, 0, numLists * sizeof(const char **));
 
     /*
      * Break up each var list and set the varcList and varvList arrays. Don't
      * compile the foreach inline if any var name needs substitutions or isn't
@@ -2713,11 +2649,10 @@
     loopIndex = 0;
     for (i = 0, tokenPtr = parsePtr->tokenPtr;
 	    i < numWords-1;
 	    i++, tokenPtr = TokenAfter(tokenPtr)) {
 	if ((i%2 == 0) && (i > 0)) {
-	    SetLineInformation(i);
 	    CompileTokens(envPtr, tokenPtr, interp);
 	    tempVar = (firstValueTemp + loopIndex);
 	    Emit14Inst(		INST_STORE_SCALAR, tempVar,	envPtr);
 	    TclEmitOpcode(	INST_POP,			envPtr);
 	    loopIndex++;
@@ -2751,11 +2686,10 @@
 
     /*
      * Inline compile the loop body.
      */
 
-    SetLineInformation(bodyIndex);
     ExceptionRangeStarts(envPtr, range);
     CompileBody(envPtr, bodyTokenPtr, interp);
     ExceptionRangeEnds(envPtr, range);
     envPtr->currStackDepth = savedStackDepth + 1;
 
@@ -2830,12 +2764,12 @@
     for (loopIndex = 0;  loopIndex < numLists;  loopIndex++) {
 	if (varvList[loopIndex] != NULL) {
 	    ckfree(varvList[loopIndex]);
 	}
     }
-    TclStackFree(interp, (void *)varvList);
-    TclStackFree(interp, varcList);
+    ckfree((void *)varvList);
+    ckfree(varcList);
     return code;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -3007,11 +2941,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr = parsePtr->tokenPtr;
     Tcl_Obj **objv, *formatObj, *tmpObj;
     char *bytes, *start;
     int i, j, len;
 
@@ -3156,11 +3089,11 @@
 		 * Push the code to produce the string that would be
 		 * substituted with %s, except we'll be concatenating
 		 * directly.
 		 */
 
-		CompileWord(envPtr, tokenPtr, interp, j);
+		CompileWord(envPtr, tokenPtr, interp);
 		tokenPtr = TokenAfter(tokenPtr);
 		j++;
 		i++;
 	    }
 	    start = bytes + 1;
@@ -3228,11 +3161,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr;
     int localIndex, numWords, i;
-    DefineLineInformation;	/* TIP #280 */
 
     numWords = parsePtr->numWords;
     if (numWords < 2) {
 	return TCL_ERROR;
     }
@@ -3261,11 +3193,11 @@
 
 	if (localIndex < 0) {
 	    return TCL_ERROR;
 	}
 
-	CompileWord(envPtr, varTokenPtr, interp, 1);
+	CompileWord(envPtr, varTokenPtr, interp);
 	TclEmitInstInt4(	INST_NSUPVAR, localIndex,	envPtr);
     }
 
     /*
      * Pop the namespace, and set the result to empty
@@ -3320,11 +3252,10 @@
 				 * to this value at the start of each test. */
     int realCond = 1;		/* Set to 0 for static conditions:
 				 * "if 0 {..}" */
     int boolVal;		/* Value of static condition. */
     int compileScripts = 1;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * Only compile the "if" command if all arguments are simple words, in
      * order to insure correct substitution [Bug 219166]
      */
@@ -3397,11 +3328,10 @@
 		realCond = 0;
 		if (!boolVal) {
 		    compileScripts = 0;
 		}
 	    } else {
-		SetLineInformation(wordIdx);
 		Tcl_ResetResult(interp);
 		TclCompileExprWords(interp, testTokenPtr, 1, envPtr);
 		if (jumpFalseFixupArray.next >= jumpFalseFixupArray.end) {
 		    TclExpandJumpFixupArray(&jumpFalseFixupArray);
 		}
@@ -3439,11 +3369,10 @@
 	/*
 	 * Compile the "then" command body.
 	 */
 
 	if (compileScripts) {
-	    SetLineInformation(wordIdx);
 	    envPtr->currStackDepth = savedStackDepth;
 	    CompileBody(envPtr, tokenPtr, interp);
 	}
 
 	if (realCond) {
@@ -3527,11 +3456,10 @@
 	if (compileScripts) {
 	    /*
 	     * Compile the else command body.
 	     */
 
-	    SetLineInformation(wordIdx);
 	    CompileBody(envPtr, tokenPtr, interp);
 	}
 
 	/*
 	 * Make sure there are no words after the else clause.
@@ -3621,20 +3549,19 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr, *incrTokenPtr;
     int simpleVarName, isScalar, localIndex, haveImmValue, immValue;
-    DefineLineInformation;	/* TIP #280 */
 
     if ((parsePtr->numWords != 2) && (parsePtr->numWords != 3)) {
 	return TCL_ERROR;
     }
 
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
 
-    PushVarNameWord(interp, varTokenPtr, envPtr, TCL_NO_LARGE_INDEX,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, varTokenPtr, envPtr, TCL_NO_LARGE_INDEX,
+	    &localIndex, &simpleVarName, &isScalar);
 
     /*
      * If an increment is given, push it, but see first if it's a small
      * integer.
      */
@@ -3657,11 +3584,10 @@
 	    }
 	    if (!haveImmValue) {
 		PushLiteral(envPtr, word, numBytes);
 	    }
 	} else {
-	    SetLineInformation(2);
 	    CompileTokens(envPtr, incrTokenPtr, interp);
 	}
     } else {			/* No incr amount given so use 1. */
 	haveImmValue = 1;
     }
@@ -3736,11 +3662,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     Tcl_Obj *objPtr;
     char *bytes;
 
     /*
@@ -3772,11 +3697,11 @@
     /*
      * Confirmed as a literal that will not frighten the horses. Compile. Note
      * that the result needs to be list-ified.
      */
 
-    CompileWord(envPtr, tokenPtr,		interp, 1);
+    CompileWord(envPtr, tokenPtr,		interp);
     TclEmitOpcode(	INST_RESOLVE_COMMAND,	envPtr);
     TclEmitOpcode(	INST_DUP,		envPtr);
     TclEmitOpcode(	INST_STR_LEN,		envPtr);
     TclEmitInstInt1(	INST_JUMP_FALSE1, 7,	envPtr);
     TclEmitInstInt4(	INST_LIST, 1,		envPtr);
@@ -3821,11 +3746,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
     int isScalar, simpleVarName, localIndex;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
 
@@ -3836,12 +3760,12 @@
      * body and if the name is simple text that does not include namespace
      * qualifiers.
      */
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    PushVarNameWord(interp, tokenPtr, envPtr, 0, &localIndex,
-	    &simpleVarName, &isScalar, 1);
+    PushVarName(interp, tokenPtr, envPtr, 0, &localIndex,
+	    &simpleVarName, &isScalar);
 
     /*
      * Emit instruction to check the variable for existence.
      */
 
@@ -3884,18 +3808,16 @@
 
 	TclEmitOpcode(		INST_INFO_LEVEL_NUM,		envPtr);
     } else if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     } else {
-	DefineLineInformation;	/* TIP #280 */
 
 	/*
 	 * Compile the argument, then add the instruction to convert it into a
 	 * list of arguments.
 	 */
 
-	SetLineInformation(1);
 	CompileTokens(envPtr, TokenAfter(parsePtr->tokenPtr), interp);
 	TclEmitOpcode(		INST_INFO_LEVEL_ARGS,		envPtr);
     }
     return TCL_OK;
 }
@@ -3907,17 +3829,16 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr = TokenAfter(parsePtr->tokenPtr);
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
-    CompileWord(envPtr,		tokenPtr,		interp, 1);
+    CompileWord(envPtr,		tokenPtr,		interp);
     TclEmitOpcode(		INST_TCLOO_CLASS,	envPtr);
     return TCL_OK;
 }
 
 int
@@ -3927,11 +3848,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr = TokenAfter(parsePtr->tokenPtr);
 
     /*
      * We only handle [info object isa object <somevalue>]. The first three
      * words are compressed to a single token by the ensemble compilation
@@ -3949,11 +3869,11 @@
 
     /*
      * Issue the code.
      */
 
-    CompileWord(envPtr,		tokenPtr,		interp, 2);
+    CompileWord(envPtr,		tokenPtr,		interp);
     TclEmitOpcode(		INST_TCLOO_IS_OBJECT,	envPtr);
     return TCL_OK;
 }
 
 int
@@ -3963,17 +3883,16 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr = TokenAfter(parsePtr->tokenPtr);
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
-    CompileWord(envPtr,		tokenPtr,		interp, 1);
+    CompileWord(envPtr,		tokenPtr,		interp);
     TclEmitOpcode(		INST_TCLOO_NS,		envPtr);
     return TCL_OK;
 }
 
 /*
@@ -4003,11 +3922,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr;
     int simpleVarName, isScalar, localIndex, numWords;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * If we're not in a procedure, don't compile.
      */
 
@@ -4035,22 +3953,22 @@
      * namespace qualifiers.
      */
 
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
 
-    PushVarNameWord(interp, varTokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, varTokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
 
     /*
      * If we are doing an assignment, push the new value. In the no values
      * case, create an empty object.
      */
 
     if (numWords > 2) {
 	Tcl_Token *valueTokenPtr = TokenAfter(varTokenPtr);
 
-	CompileWord(envPtr, valueTokenPtr, interp, 2);
+	CompileWord(envPtr, valueTokenPtr, interp);
     }
 
     /*
      * Emit instructions to set/get the variable.
      */
@@ -4106,11 +4024,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
     int simpleVarName, isScalar, localIndex, numWords, idx;
-    DefineLineInformation;	/* TIP #280 */
 
     numWords = parsePtr->numWords;
 
     /*
      * Check for command syntax error, but we'll punt that to runtime.
@@ -4123,11 +4040,11 @@
     /*
      * Generate code to push list being taken apart by [lassign].
      */
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    CompileWord(envPtr, tokenPtr, interp, 1);
+    CompileWord(envPtr, tokenPtr, interp);
 
     /*
      * Generate code to assign values from the list to variables.
      */
 
@@ -4136,12 +4053,12 @@
 
 	/*
 	 * Generate the next variable name.
 	 */
 
-	PushVarNameWord(interp, tokenPtr, envPtr, 0, &localIndex,
-		&simpleVarName, &isScalar, idx+2);
+	PushVarName(interp, tokenPtr, envPtr, 0, &localIndex,
+		&simpleVarName, &isScalar);
 
 	/*
 	 * Emit instructions to get the idx'th item out of the list value on
 	 * the stack and assign it to the variable.
 	 */
@@ -4215,11 +4132,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *idxTokenPtr, *valTokenPtr;
     int i, numWords = parsePtr->numWords;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * Quit if too few args.
      */
 
@@ -4259,11 +4175,11 @@
 	     *	 lindex <arbitraryValue> end-<posInt>
 	     * This is best compiled as a push of the arbitrary value followed
 	     * by an "immediate lindex" which is the most efficient variety.
 	     */
 
-	    CompileWord(envPtr, valTokenPtr, interp, 1);
+	    CompileWord(envPtr, valTokenPtr, interp);
 	    TclEmitInstInt4(	INST_LIST_INDEX_IMM, idx,	envPtr);
 	    return TCL_OK;
 	}
 
 	/*
@@ -4276,11 +4192,11 @@
      * Push the operands onto the stack.
      */
 
   emitComplexLindex:
     for (i=1 ; i<numWords ; i++) {
-	CompileWord(envPtr, valTokenPtr, interp, i);
+	CompileWord(envPtr, valTokenPtr, interp);
 	valTokenPtr = TokenAfter(valTokenPtr);
     }
 
     /*
      * Emit INST_LIST_INDEX if objc==3, or INST_LIST_INDEX_MULTI if there are
@@ -4321,11 +4237,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *valueTokenPtr;
     int i, numWords;
 
     /*
      * If we're not in a procedure, don't compile.
@@ -4347,11 +4262,11 @@
 	 */
 
 	numWords = parsePtr->numWords;
 	valueTokenPtr = TokenAfter(parsePtr->tokenPtr);
 	for (i = 1; i < numWords; i++) {
-	    CompileWord(envPtr, valueTokenPtr, interp, i);
+	    CompileWord(envPtr, valueTokenPtr, interp);
 	    valueTokenPtr = TokenAfter(valueTokenPtr);
 	}
 	TclEmitInstInt4(	INST_LIST, numWords - 1,	envPtr);
     }
 
@@ -4384,18 +4299,17 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
 
-    CompileWord(envPtr, varTokenPtr, interp, 1);
+    CompileWord(envPtr, varTokenPtr, interp);
     TclEmitOpcode(		INST_LIST_LENGTH,		envPtr);
     return TCL_OK;
 }
 
 /*
@@ -4417,11 +4331,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds the resulting instructions. */
 {
     Tcl_Token *tokenPtr, *listTokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Obj *tmpObj;
     int idx1, idx2, result;
 
     if (parsePtr->numWords != 4) {
 	return TCL_ERROR;
@@ -4486,11 +4399,11 @@
      * Issue instructions. It's not safe to skip doing the LIST_RANGE, as
      * we've not proved that the 'list' argument is really a list. Not that it
      * is worth trying to do that given current knowledge.
      */
 
-    CompileWord(envPtr, listTokenPtr, interp, 1);
+    CompileWord(envPtr, listTokenPtr, interp);
     TclEmitInstInt4(		INST_LIST_RANGE_IMM, idx1,	envPtr);
     TclEmitInt4(		idx2,				envPtr);
     return TCL_OK;
 }
 
@@ -4516,11 +4429,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds the resulting instructions. */
 {
     Tcl_Token *tokenPtr, *listTokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Obj *tmpObj;
     int idx1, idx2, result, guaranteedDropAll = 0;
 
     if (parsePtr->numWords != 4) {
 	return TCL_ERROR;
@@ -4604,11 +4516,11 @@
      * Issue instructions. It's not safe to skip doing the LIST_RANGE, as
      * we've not proved that the 'list' argument is really a list. Not that it
      * is worth trying to do that given current knowledge.
      */
 
-    CompileWord(envPtr, listTokenPtr, interp, 1);
+    CompileWord(envPtr, listTokenPtr, interp);
     if (guaranteedDropAll) {
 	TclEmitOpcode(		INST_LIST_LENGTH,		envPtr);
 	TclEmitOpcode(		INST_POP,			envPtr);
 	PushLiteral(envPtr, "", 0);
     } else {
@@ -4673,11 +4585,10 @@
 				 * parse of the variable name. */
     int localIndex;		/* Index of var in local var table. */
     int simpleVarName;		/* Flag == 1 if var name is simple. */
     int isScalar;		/* Flag == 1 if scalar, 0 if array. */
     int i;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * Check argument count.
      */
 
@@ -4696,20 +4607,20 @@
      * body and if the name is simple text that does not include namespace
      * qualifiers.
      */
 
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
-    PushVarNameWord(interp, varTokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, varTokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
 
     /*
      * Push the "index" args and the new element value.
      */
 
     for (i=2 ; i<parsePtr->numWords ; ++i) {
 	varTokenPtr = TokenAfter(varTokenPtr);
-	CompileWord(envPtr, varTokenPtr, interp, i);
+	CompileWord(envPtr, varTokenPtr, interp);
     }
 
     /*
      * Duplicate the variable name if it's been pushed.
      */
@@ -4873,11 +4784,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
@@ -4908,11 +4818,11 @@
      */
 
     PushLiteral(envPtr,		"::namespace",		11);
     PushLiteral(envPtr,		"inscope",		7);
     TclEmitOpcode(		INST_NS_CURRENT,	envPtr);
-    CompileWord(envPtr,		tokenPtr,		interp, 1);
+    CompileWord(envPtr,		tokenPtr,		interp);
     TclEmitInstInt4(		INST_LIST, 4,		envPtr);
     return TCL_OK;
 }
 
 int
@@ -4923,18 +4833,17 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    DefineLineInformation;	/* TIP #280 */
     int off;
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
 
-    CompileWord(envPtr, tokenPtr, interp, 1);
+    CompileWord(envPtr, tokenPtr, interp);
     PushLiteral(envPtr, "0", 1);
     PushLiteral(envPtr, "::", 2);
     TclEmitInstInt4(	INST_OVER, 2,			envPtr);
     TclEmitOpcode(	INST_STR_FIND_LAST,		envPtr);
     off = CurrentOffset(envPtr);
@@ -4959,11 +4868,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    DefineLineInformation;	/* TIP #280 */
     JumpFixup jumpFixup;
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
@@ -4970,11 +4878,11 @@
 
     /*
      * Take care; only add 2 to found index if the string was actually found.
      */
 
-    CompileWord(envPtr, tokenPtr, interp, 1);
+    CompileWord(envPtr, tokenPtr, interp);
     PushLiteral(envPtr, "::", 2);
     TclEmitInstInt4(	INST_OVER, 1,			envPtr);
     TclEmitOpcode(	INST_STR_FIND_LAST,		envPtr);
     TclEmitOpcode(	INST_DUP,			envPtr);
     PushLiteral(envPtr, "0", 1);
@@ -4997,11 +4905,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr, *otherTokenPtr, *localTokenPtr;
     int simpleVarName, isScalar, localIndex, numWords, i;
-    DefineLineInformation;	/* TIP #280 */
 
     if (envPtr->procPtr == NULL) {
 	return TCL_ERROR;
     }
 
@@ -5017,11 +4924,11 @@
     /*
      * Push the namespace
      */
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
-    CompileWord(envPtr, tokenPtr, interp, 1);
+    CompileWord(envPtr, tokenPtr, interp);
 
     /*
      * Loop over the (otherVar, thisVar) pairs. If any of the thisVar is not a
      * local variable, return an error so that the non-compiled command will
      * be called at runtime.
@@ -5030,13 +4937,13 @@
     localTokenPtr = tokenPtr;
     for (i=3; i<=numWords; i+=2) {
 	otherTokenPtr = TokenAfter(localTokenPtr);
 	localTokenPtr = TokenAfter(otherTokenPtr);
 
-	CompileWord(envPtr, otherTokenPtr, interp, 1);
-	PushVarNameWord(interp, localTokenPtr, envPtr, 0,
-		&localIndex, &simpleVarName, &isScalar, 1);
+	CompileWord(envPtr, otherTokenPtr, interp);
+	PushVarName(interp, localTokenPtr, envPtr, 0,
+		&localIndex, &simpleVarName, &isScalar);
 
 	if ((localIndex < 0) || !isScalar) {
 	    return TCL_ERROR;
 	}
 	TclEmitInstInt4(	INST_NSUPVAR, localIndex,	envPtr);
@@ -5058,11 +4965,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr, *opt;
     int idx;
 
     if (parsePtr->numWords < 2 || parsePtr->numWords > 3) {
 	return TCL_ERROR;
@@ -5090,11 +4996,11 @@
 
     /*
      * Issue the bytecode.
      */
 
-    CompileWord(envPtr,		tokenPtr,		interp, idx);
+    CompileWord(envPtr,		tokenPtr,		interp);
     TclEmitOpcode(		INST_RESOLVE_COMMAND,	envPtr);
     return TCL_OK;
 }
 
 /*
@@ -5126,11 +5032,10 @@
 {
     Tcl_Token *varTokenPtr;	/* Pointer to the Tcl_Token representing the
 				 * parse of the RE or string. */
     int i, len, nocase, exact, sawLast, simple;
     const char *str;
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * We are only interested in compiling simple regexp cases. Currently
      * supported compile cases are:
      *   regexp ?-nocase? ?--? staticString $var
@@ -5229,19 +5134,19 @@
 	    Tcl_DStringFree(&ds);
 	}
     }
 
     if (!simple) {
-	CompileWord(envPtr, varTokenPtr, interp, parsePtr->numWords-2);
+	CompileWord(envPtr, varTokenPtr, interp);
     }
 
     /*
      * Push the string arg.
      */
 
     varTokenPtr = TokenAfter(varTokenPtr);
-    CompileWord(envPtr, varTokenPtr, interp, parsePtr->numWords-1);
+    CompileWord(envPtr, varTokenPtr, interp);
 
     if (simple) {
 	if (exact && !nocase) {
 	    TclEmitOpcode(	INST_STR_EQ,			envPtr);
 	} else {
@@ -5307,11 +5212,10 @@
      *   regsub -all [--] simpleRE string simpleReplacement
      *
      * The only optional part is the "--", and no other options are handled.
      */
 
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr, *stringTokenPtr;
     Tcl_Obj *patternObj = NULL, *replacementObj = NULL;
     Tcl_DString pattern;
     const char *bytes;
     int len, exact, result = TCL_ERROR;
@@ -5420,11 +5324,11 @@
     result = TCL_OK;
     bytes = Tcl_DStringValue(&pattern) + 1;
     PushLiteral(envPtr,	bytes, len);
     bytes = Tcl_GetStringFromObj(replacementObj, &len);
     PushLiteral(envPtr,	bytes, len);
-    CompileWord(envPtr,	stringTokenPtr, interp, parsePtr->numWords-2);
+    CompileWord(envPtr,	stringTokenPtr, interp);
     TclEmitOpcode(	INST_STR_MAP,	envPtr);
 
   done:
     Tcl_DStringFree(&pattern);
     if (patternObj) {
@@ -5472,11 +5376,10 @@
     int explicitResult = (0 == (numWords % 2));
     int numOptionWords = numWords - 1 - explicitResult;
     int savedStackDepth = envPtr->currStackDepth;
     Tcl_Obj *returnOpts, **objv;
     Tcl_Token *wordTokenPtr = TokenAfter(parsePtr->tokenPtr);
-    DefineLineInformation;	/* TIP #280 */
 
     /*
      * Check for special case which can always be compiled:
      *	    return -options <opts> <msg>
      * Unlike the normal [return] compilation, this version does everything at
@@ -5489,22 +5392,22 @@
 	    && (wordTokenPtr[1].size == 8)
 	    && (strncmp(wordTokenPtr[1].start, "-options", 8) == 0)) {
 	Tcl_Token *optsTokenPtr = TokenAfter(wordTokenPtr);
 	Tcl_Token *msgTokenPtr = TokenAfter(optsTokenPtr);
 
-	CompileWord(envPtr, optsTokenPtr, interp, 2);
-	CompileWord(envPtr, msgTokenPtr,  interp, 3);
+	CompileWord(envPtr, optsTokenPtr, interp);
+	CompileWord(envPtr, msgTokenPtr,  interp);
 	TclEmitOpcode(INST_RETURN_STK, envPtr);
 	envPtr->currStackDepth = savedStackDepth + 1;
 	return TCL_OK;
     }
 
     /*
      * Allocate some working space.
      */
 
-    objv = TclStackAlloc(interp, numOptionWords * sizeof(Tcl_Obj *));
+    objv = ckalloc(numOptionWords * sizeof(Tcl_Obj *));
 
     /*
      * Scan through the return options. If any are unknown at compile time,
      * there is no value in bytecompiling. Save the option values known in an
      * objv array for merging into a return options dictionary.
@@ -5524,11 +5427,11 @@
 	    &returnOpts, &code, &level);
   cleanup:
     while (--objc >= 0) {
 	TclDecrRefCount(objv[objc]);
     }
-    TclStackFree(interp, objv);
+    ckfree(objv);
     if (TCL_ERROR == status) {
 	/*
 	 * Something was bogus in the return options. Clear the error message,
 	 * and report back to the compiler that this must be interpreted at
 	 * runtime.
@@ -5542,11 +5445,11 @@
      * All options are known at compile time, so we're going to bytecompile.
      * Emit instructions to push the result on the stack.
      */
 
     if (explicitResult) {
-	 CompileWord(envPtr, wordTokenPtr, interp, numWords-1);
+	 CompileWord(envPtr, wordTokenPtr, interp);
     } else {
 	/*
 	 * No explict result argument, so default result is empty string.
 	 */
 
@@ -5660,11 +5563,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *tokenPtr, *otherTokenPtr, *localTokenPtr;
     int simpleVarName, isScalar, localIndex, numWords, i;
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Obj *objPtr = Tcl_NewObj();
 
     if (envPtr->procPtr == NULL) {
 	Tcl_DecrRefCount(objPtr);
 	return TCL_ERROR;
@@ -5696,11 +5598,11 @@
 
 	if (newTypePtr != typePtr) {
 	    if (numWords%2) {
 		return TCL_ERROR;
 	    }
-	    CompileWord(envPtr, tokenPtr, interp, 1);
+	    CompileWord(envPtr, tokenPtr, interp);
 	    otherTokenPtr = TokenAfter(tokenPtr);
 	    i = 4;
 	} else {
 	    if (!(numWords%2)) {
 		return TCL_ERROR;
@@ -5721,13 +5623,13 @@
      */
 
     for (; i<=numWords; i+=2, otherTokenPtr = TokenAfter(localTokenPtr)) {
 	localTokenPtr = TokenAfter(otherTokenPtr);
 
-	CompileWord(envPtr, otherTokenPtr, interp, 1);
-	PushVarNameWord(interp, localTokenPtr, envPtr, 0,
-		&localIndex, &simpleVarName, &isScalar, 1);
+	CompileWord(envPtr, otherTokenPtr, interp);
+	PushVarName(interp, localTokenPtr, envPtr, 0,
+		&localIndex, &simpleVarName, &isScalar);
 
 	if ((localIndex < 0) || !isScalar) {
 	    return TCL_ERROR;
 	}
 	TclEmitInstInt4(	INST_UPVAR, localIndex,		envPtr);
@@ -5769,11 +5671,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr, *valueTokenPtr;
     int localIndex, numWords, i;
-    DefineLineInformation;	/* TIP #280 */
 
     numWords = parsePtr->numWords;
     if (numWords < 2) {
 	return TCL_ERROR;
     }
@@ -5799,19 +5700,19 @@
 
 	if (localIndex < 0) {
 	    return TCL_ERROR;
 	}
 
-	CompileWord(envPtr, varTokenPtr, interp, i);
+	CompileWord(envPtr, varTokenPtr, interp);
 	TclEmitInstInt4(	INST_VARIABLE, localIndex,	envPtr);
 
 	if (i+1 < numWords) {
 	    /*
 	     * A value has been given: set the variable, pop the value
 	     */
 
-	    CompileWord(envPtr, valueTokenPtr, interp, i+1);
+	    CompileWord(envPtr, valueTokenPtr, interp);
 	    Emit14Inst(		INST_STORE_SCALAR, localIndex,	envPtr);
 	    TclEmitOpcode(	INST_POP,			envPtr);
 	}
     }
 
@@ -6007,14 +5908,11 @@
     Tcl_Token *varTokenPtr,	/* Points to a variable token. */
     CompileEnv *envPtr,		/* Holds resulting instructions. */
     int flags,			/* TCL_NO_LARGE_INDEX. */
     int *localIndexPtr,		/* Must not be NULL. */
     int *simpleVarNamePtr,	/* Must not be NULL. */
-    int *isScalarPtr,		/* Must not be NULL. */
-    int line,			/* Line the token starts on. */
-    int *clNext)		/* Reference to offset of next hidden cont.
-				 * line. */
+    int *isScalarPtr)		/* Must not be NULL. */
 {
     register const char *p;
     const char *name, *elName;
     register int i, n;
     Tcl_Token *elemTokenPtr = NULL;
@@ -6071,11 +5969,11 @@
 		/*
 		 * An array element, the element name is a simple string:
 		 * assemble the corresponding token.
 		 */
 
-		elemTokenPtr = TclStackAlloc(interp, sizeof(Tcl_Token));
+		elemTokenPtr = ckalloc(sizeof(Tcl_Token));
 		allocedTokens = 1;
 		elemTokenPtr->type = TCL_TOKEN_TEXT;
 		elemTokenPtr->start = elName;
 		elemTokenPtr->size = elNameChars;
 		elemTokenPtr->numComponents = 0;
@@ -6124,11 +6022,11 @@
 		/*
 		 * Make a first token with the extra characters in the first
 		 * token.
 		 */
 
-		elemTokenPtr = TclStackAlloc(interp, n * sizeof(Tcl_Token));
+		elemTokenPtr = ckalloc(n * sizeof(Tcl_Token));
 		allocedTokens = 1;
 		elemTokenPtr->type = TCL_TOKEN_TEXT;
 		elemTokenPtr->start = elName;
 		elemTokenPtr->size = remainingChars;
 		elemTokenPtr->numComponents = 0;
@@ -6190,12 +6088,10 @@
 	 * Compile the element script, if any.
 	 */
 
 	if (elName != NULL) {
 	    if (elNameChars) {
-		envPtr->line = line;
-		envPtr->clNext = clNext;
 		TclCompileTokens(interp, elemTokenPtr, elemTokenCount,
 			envPtr);
 	    } else {
 		PushLiteral(envPtr, "", 0);
 	    }
@@ -6203,20 +6099,18 @@
     } else {
 	/*
 	 * The var name isn't simple: compile and push it.
 	 */
 
-	envPtr->line = line;
-	envPtr->clNext = clNext;
 	CompileTokens(envPtr, varTokenPtr, interp);
     }
 
     if (removedParen) {
 	varTokenPtr[removedParen].size++;
     }
     if (allocedTokens) {
-	TclStackFree(interp, elemTokenPtr);
+	ckfree(elemTokenPtr);
     }
     *localIndexPtr = localIndex;
     *simpleVarNamePtr = simpleVarName;
     *isScalarPtr = (elName == NULL);
     return TCL_OK;

Index: generic/tclCompCmdsSZ.c
==================================================================
--- generic/tclCompCmdsSZ.c
+++ generic/tclCompCmdsSZ.c
@@ -28,12 +28,11 @@
 			    Tcl_Obj *appendObj, ByteCode *codePtr,
 			    unsigned int pcOffset);
 static int		PushVarName(Tcl_Interp *interp,
 			    Tcl_Token *varTokenPtr, CompileEnv *envPtr,
 			    int flags, int *localIndexPtr,
-			    int *simpleVarNamePtr, int *isScalarPtr,
-			    int line, int *clNext);
+			    int *simpleVarNamePtr, int *isScalarPtr);
 static int		CompileAssociativeBinaryOpCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, const char *identity,
 			    int instruction, CompileEnv *envPtr);
 static int		CompileComparisonOpCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, int instruction,
@@ -43,21 +42,17 @@
 			    CompileEnv *envPtr);
 static int		CompileUnaryOpCmd(Tcl_Interp *interp,
 			    Tcl_Parse *parsePtr, int instruction,
 			    CompileEnv *envPtr);
 static void		IssueSwitchChainedTests(Tcl_Interp *interp,
-			    CompileEnv *envPtr, ExtCmdLoc *mapPtr,
-			    int eclIndex, int mode, int noCase,
+			    CompileEnv *envPtr, int mode, int noCase,
 			    int valueIndex, Tcl_Token *valueTokenPtr,
-			    int numWords, Tcl_Token **bodyToken,
-			    int *bodyLines, int **bodyNext);
+			    int numWords, Tcl_Token **bodyToken);
 static void		IssueSwitchJumpTable(Tcl_Interp *interp,
-			    CompileEnv *envPtr, ExtCmdLoc *mapPtr,
-			    int eclIndex, int valueIndex,
+			    CompileEnv *envPtr, int valueIndex,
 			    Tcl_Token *valueTokenPtr, int numWords,
-			    Tcl_Token **bodyToken, int *bodyLines,
-			    int **bodyContLines);
+			    Tcl_Token **bodyToken);
 static int		IssueTryFinallyInstructions(Tcl_Interp *interp,
 			    CompileEnv *envPtr, Tcl_Token *bodyToken,
 			    int numHandlers, int *matchCodes,
 			    Tcl_Obj **matchClauses, int *resultVarIndices,
 			    int *optionVarIndices, Tcl_Token **handlerTokens,
@@ -79,38 +74,14 @@
 #define CompileWord(envPtr, tokenPtr, interp, word) \
     if ((tokenPtr)->type == TCL_TOKEN_SIMPLE_WORD) {			\
 	TclEmitPush(TclRegisterNewLiteral((envPtr), (tokenPtr)[1].start, \
 		(tokenPtr)[1].size), (envPtr));				\
     } else {								\
-	envPtr->line = mapPtr->loc[eclIndex].line[word];		\
-	envPtr->clNext = mapPtr->loc[eclIndex].next[word];		\
 	TclCompileTokens((interp), (tokenPtr)+1, (tokenPtr)->numComponents, \
 		(envPtr));						\
     }
 
-/*
- * TIP #280: Remember the per-word line information of the current command. An
- * index is used instead of a pointer as recursive compilation may reallocate,
- * i.e. move, the array. This is also the reason to save the nuloc now, it may
- * change during the course of the function.
- *
- * Macro to encapsulate the variable definition and setup.
- */
-
-#define DefineLineInformation \
-    ExtCmdLoc *mapPtr = envPtr->extCmdMapPtr;				\
-    int eclIndex = mapPtr->nuloc - 1
-
-#define SetLineInformation(word) \
-    envPtr->line = mapPtr->loc[eclIndex].line[(word)];			\
-    envPtr->clNext = mapPtr->loc[eclIndex].next[(word)]
-
-#define PushVarNameWord(i,v,e,f,l,s,sc,word) \
-    PushVarName(i,v,e,f,l,s,sc,						\
-	    mapPtr->loc[eclIndex].line[(word)],				\
-	    mapPtr->loc[eclIndex].next[(word)])
-
 /*
  * Flags bits used by PushVarName.
  */
 
 #define TCL_NO_LARGE_INDEX 1	/* Do not return localIndex value > 255 */
@@ -136,11 +107,11 @@
 #define OP14(name,val1,val2) \
     TclEmitInstInt1(INST_##name,(val1),envPtr);TclEmitInt4((val2),envPtr)
 #define OP44(name,val1,val2) \
     TclEmitInstInt4(INST_##name,(val1),envPtr);TclEmitInt4((val2),envPtr)
 #define BODY(token,index) \
-    SetLineInformation((index));CompileBody(envPtr,(token),interp)
+    CompileBody(envPtr,(token),interp)
 #define PUSH(str) \
     PushLiteral(envPtr,(str),strlen(str))
 #define JUMP(var,name) \
     (var) = CurrentOffset(envPtr);TclEmitInstInt4(INST_##name,0,envPtr)
 #define FIXJUMP(var) \
@@ -177,11 +148,10 @@
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr, *valueTokenPtr;
     int isAssignment, isScalar, simpleVarName, localIndex, numWords;
-    DefineLineInformation;	/* TIP #280 */
 
     numWords = parsePtr->numWords;
     if ((numWords != 2) && (numWords != 3)) {
 	return TCL_ERROR;
     }
@@ -194,12 +164,12 @@
      * body and if the name is simple text that does not include namespace
      * qualifiers.
      */
 
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
-    PushVarNameWord(interp, varTokenPtr, envPtr, 0,
-	    &localIndex, &simpleVarName, &isScalar, 1);
+    PushVarName(interp, varTokenPtr, envPtr, 0,
+	    &localIndex, &simpleVarName, &isScalar);
 
     /*
      * If we are doing an assignment, push the new value.
      */
 
@@ -274,11 +244,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
 
     /*
      * We don't support any flags; the bytecode isn't that sophisticated.
      */
@@ -306,11 +275,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
 
     /*
      * We don't support any flags; the bytecode isn't that sophisticated.
      */
@@ -338,11 +306,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
 
     /*
      * We don't support any flags; the bytecode isn't that sophisticated.
      */
@@ -370,11 +337,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
 
     /*
      * We don't support any flags; the bytecode isn't that sophisticated.
      */
@@ -402,11 +368,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
 
     if (parsePtr->numWords != 3) {
 	return TCL_ERROR;
     }
@@ -430,11 +395,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     int i, length, exactMatch = 0, nocase = 0;
     const char *str;
 
     if (parsePtr->numWords < 3 || parsePtr->numWords > 4) {
@@ -484,11 +448,10 @@
 		exactMatch = TclMatchIsTrivial(TclGetString(copy));
 		TclDecrRefCount(copy);
 	    }
 	    PushLiteral(envPtr, str, length);
 	} else {
-	    SetLineInformation(i+1+nocase);
 	    CompileTokens(envPtr, tokenPtr, interp);
 	}
 	tokenPtr = TokenAfter(tokenPtr);
     }
 
@@ -511,11 +474,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr;
     Tcl_Obj *objPtr;
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
@@ -534,11 +496,10 @@
 	int len = Tcl_GetCharLength(objPtr);
 
 	len = sprintf(buf, "%d", len);
 	PushLiteral(envPtr, buf, len);
     } else {
-	SetLineInformation(1);
 	CompileTokens(envPtr, tokenPtr, interp);
 	TclEmitOpcode(INST_STR_LEN, envPtr);
     }
     TclDecrRefCount(objPtr);
     return TCL_OK;
@@ -551,11 +512,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *mapTokenPtr, *stringTokenPtr;
     Tcl_Obj *mapObj, **objv;
     char *bytes;
     int len;
 
@@ -614,11 +574,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *stringTokenPtr, *fromTokenPtr, *toTokenPtr;
     Tcl_Obj *tmpObj;
     int idx1, idx2, result;
 
     if (parsePtr->numWords != 4) {
@@ -729,17 +688,16 @@
     int numOpts = numArgs - 1;
     int objc, flags = TCL_SUBST_ALL;
     Tcl_Obj **objv/*, *toSubst = NULL*/;
     Tcl_Token *wordTokenPtr = TokenAfter(parsePtr->tokenPtr);
     int code = TCL_ERROR;
-    DefineLineInformation;	/* TIP #280 */
 
     if (numArgs == 0) {
 	return TCL_ERROR;
     }
 
-    objv = TclStackAlloc(interp, /*numArgs*/ numOpts * sizeof(Tcl_Obj *));
+    objv = ckalloc(/*numArgs*/ numOpts * sizeof(Tcl_Obj *));
 
     for (objc = 0; objc < /*numArgs*/ numOpts; objc++) {
 	objv[objc] = Tcl_NewObj();
 	Tcl_IncrRefCount(objv[objc]);
 	if (!TclWordKnownAtCompileTime(wordTokenPtr, objv[objc])) {
@@ -768,18 +726,17 @@
 
   cleanup:
     while (--objc >= 0) {
 	TclDecrRefCount(objv[objc]);
     }
-    TclStackFree(interp, objv);
+    ckfree(objv);
     if (/*toSubst == NULL*/ code != TCL_OK) {
 	return TCL_ERROR;
     }
 
-    SetLineInformation(numArgs);
     TclSubstCompile(interp, wordTokenPtr[1].start, wordTokenPtr[1].size,
-	    flags, mapPtr->loc[eclIndex].line[numArgs], envPtr);
+	    flags, envPtr);
 
 /*    TclDecrRefCount(toSubst);*/
     return TCL_OK;
 }
 
@@ -787,15 +744,14 @@
 TclSubstCompile(
     Tcl_Interp *interp,
     const char *bytes,
     int numBytes,
     int flags,
-    int line,
     CompileEnv *envPtr)
 {
     Tcl_Token *endTokenPtr, *tokenPtr;
-    int breakOffset = 0, count = 0, bline = line;
+    int breakOffset = 0, count = 0;
     Tcl_Parse parse;
     Tcl_InterpState state = NULL;
 
     TclSubstParse(interp, bytes, numBytes, flags, &parse, &state);
 
@@ -823,12 +779,10 @@
 	switch (tokenPtr->type) {
 	case TCL_TOKEN_TEXT:
 	    literal = TclRegisterNewLiteral(envPtr,
 		    tokenPtr->start, tokenPtr->size);
 	    TclEmitPush(literal, envPtr);
-	    TclAdvanceLines(&bline, tokenPtr->start,
-		    tokenPtr->start + tokenPtr->size);
 	    count++;
 	    continue;
 	case TCL_TOKEN_BS:
 	    length = TclParseBackslash(tokenPtr->start, tokenPtr->size,
 		    NULL, buf);
@@ -857,13 +811,11 @@
 		if (foundCommand) {
 		    break;
 		}
 	    }
 
-	    envPtr->line = bline;
 	    TclCompileVarSubst(interp, tokenPtr, envPtr);
-	    bline = envPtr->line;
 	    count++;
 	    continue;
 	}
 
 	while (count > 255) {
@@ -888,11 +840,10 @@
 		Tcl_Panic("TclCompileSubstCmd: bad start jump distance %d",
 			(int) (CurrentOffset(envPtr) - startFixup.codeOffset));
 	    }
 	}
 
-	envPtr->line = bline;
 	catchRange = DeclareExceptionRange(envPtr, CATCH_EXCEPTION_RANGE);
 	OP4(	BEGIN_CATCH4, catchRange);
 	ExceptionRangeStarts(envPtr, catchRange);
 
 	switch (tokenPtr->type) {
@@ -1005,11 +956,10 @@
 	/* CONTINUE jump to here */
 	if (TclFixupForwardJumpToHere(envPtr, &endFixup, 127)) {
 	    Tcl_Panic("TclCompileSubstCmd: bad end jump distance %d",
 		    (int) (CurrentOffset(envPtr) - endFixup.codeOffset));
 	}
-	bline = envPtr->line;
     }
 
     while (count > 255) {
 	OP1(	CONCAT1, 255);
 	count -= 254;
@@ -1072,19 +1022,14 @@
     enum {Switch_Exact, Switch_Glob, Switch_Regexp} mode;
 				/* What kind of switch are we doing? */
 
     Tcl_Token *bodyTokenArray;	/* Array of real pattern list items. */
     Tcl_Token **bodyToken;	/* Array of pointers to pattern list items. */
-    int *bodyLines;		/* Array of line numbers for body list
-				 * items. */
-    int **bodyContLines;	/* Array of continuation line info. */
     int noCase;			/* Has the -nocase flag been given? */
     int foundMode = 0;		/* Have we seen a mode flag yet? */
     int i, valueIndex;
     int result = TCL_ERROR;
-    DefineLineInformation;	/* TIP #280 */
-    int *clNext = envPtr->clNext;
 
     /*
      * Only handle the following versions:
      *   switch         ?--? word {pattern body ...}
      *   switch -exact  ?--? word {pattern body ...}
@@ -1219,14 +1164,10 @@
      */
 
     if (numWords == 1) {
 	const char *bytes;
 	int maxLen, numBytes;
-	int bline;		/* TIP #280: line of the pattern/action list,
-				 * and start of list for when tracking the
-				 * location. This list comes immediately after
-				 * the value we switch on. */
 
 	if (tokenPtr->type != TCL_TOKEN_SIMPLE_WORD) {
 	    return TCL_ERROR;
 	}
 	bytes = tokenPtr[1].start;
@@ -1237,14 +1178,11 @@
 	if (maxLen < 2)  {
 	    return TCL_ERROR;
 	}
 	bodyTokenArray = ckalloc(sizeof(Tcl_Token) * maxLen);
 	bodyToken = ckalloc(sizeof(Tcl_Token *) * maxLen);
-	bodyLines = ckalloc(sizeof(int) * maxLen);
-	bodyContLines = ckalloc(sizeof(int*) * maxLen);
 
-	bline = mapPtr->loc[eclIndex].line[valueIndex+1];
 	numWords = 0;
 
 	while (numBytes > 0) {
 	    const char *prevBytes = bytes;
 	    int literal;
@@ -1257,33 +1195,17 @@
 
 	    bodyTokenArray[numWords].type = TCL_TOKEN_TEXT;
 	    bodyTokenArray[numWords].numComponents = 0;
 	    bodyToken[numWords] = bodyTokenArray + numWords;
 
-	    /*
-	     * TIP #280: Now determine the line the list element starts on
-	     * (there is no need to do it earlier, due to the possibility of
-	     * aborting, see above).
-	     */
-
-	    TclAdvanceLines(&bline, prevBytes, bodyTokenArray[numWords].start);
-	    TclAdvanceContinuations(&bline, &clNext,
-		    bodyTokenArray[numWords].start - envPtr->source);
-	    bodyLines[numWords] = bline;
-	    bodyContLines[numWords] = clNext;
-	    TclAdvanceLines(&bline, bodyTokenArray[numWords].start, bytes);
-	    TclAdvanceContinuations(&bline, &clNext, bytes - envPtr->source);
-
 	    numBytes -= (bytes - prevBytes);
 	    numWords++;
 	}
 	if (numWords % 2) {
 	abort:
 	    ckfree((char *) bodyToken);
 	    ckfree((char *) bodyTokenArray);
-	    ckfree((char *) bodyLines);
-	    ckfree((char *) bodyContLines);
 	    return TCL_ERROR;
 	}
     } else if (numWords % 2 || numWords == 0) {
 	/*
 	 * Odd number of words (>1) available, or no words at all available.
@@ -1298,12 +1220,10 @@
 	/*
 	 * Multi-word definition of patterns & actions.
 	 */
 
 	bodyToken = ckalloc(sizeof(Tcl_Token *) * numWords);
-	bodyLines = ckalloc(sizeof(int) * numWords);
-	bodyContLines = ckalloc(sizeof(int*) * numWords);
 	bodyTokenArray = NULL;
 	for (i=0 ; i<numWords ; i++) {
 	    /*
 	     * We only handle the very simplest case. Anything more complex is
 	     * a good reason to go to the interpreted case anyway due to
@@ -1313,16 +1233,10 @@
 	    if (tokenPtr->type != TCL_TOKEN_SIMPLE_WORD) {
 		goto freeTemporaries;
 	    }
 	    bodyToken[i] = tokenPtr+1;
 
-	    /*
-	     * TIP #280: Copy line information from regular cmd info.
-	     */
-
-	    bodyLines[i] = mapPtr->loc[eclIndex].line[valueIndex+1+i];
-	    bodyContLines[i] = mapPtr->loc[eclIndex].next[valueIndex+1+i];
 	    tokenPtr = TokenAfter(tokenPtr);
 	}
     }
 
     /*
@@ -1342,27 +1256,24 @@
      * over-conservative with determining whether we can do the jump table,
      * but it handles the most common case well enough.
      */
 
     if (mode == Switch_Exact) {
-	IssueSwitchJumpTable(interp, envPtr, mapPtr, eclIndex, valueIndex,
-		valueTokenPtr, numWords, bodyToken, bodyLines, bodyContLines);
+	IssueSwitchJumpTable(interp, envPtr, valueIndex,
+		valueTokenPtr, numWords, bodyToken);
     } else {
-	IssueSwitchChainedTests(interp, envPtr, mapPtr, eclIndex, mode,noCase,
-		valueIndex, valueTokenPtr, numWords, bodyToken, bodyLines,
-		bodyContLines);
+	IssueSwitchChainedTests(interp, envPtr, mode,noCase,
+		valueIndex, valueTokenPtr, numWords, bodyToken);
     }
     result = TCL_OK;
 
     /*
      * Clean up all our temporary space and return.
      */
 
   freeTemporaries:
     ckfree(bodyToken);
-    ckfree(bodyLines);
-    ckfree(bodyContLines);
     if (bodyTokenArray != NULL) {
 	ckfree(bodyTokenArray);
     }
     return result;
 }
@@ -1385,24 +1296,18 @@
 
 static void
 IssueSwitchChainedTests(
     Tcl_Interp *interp,		/* Context for compiling script bodies. */
     CompileEnv *envPtr,		/* Holds resulting instructions. */
-    ExtCmdLoc *mapPtr,		/* For mapping tokens to their source code
-				 * location. */
-    int eclIndex,
     int mode,			/* Exact, Glob or Regexp */
     int noCase,			/* Case-insensitivity flag. */
     int valueIndex,		/* The value to match against. */
     Tcl_Token *valueTokenPtr,
     int numBodyTokens,		/* Number of tokens describing things the
 				 * switch can match against and bodies to
 				 * execute when the match succeeds. */
-    Tcl_Token **bodyToken,	/* Array of pointers to pattern list items. */
-    int *bodyLines,		/* Array of line numbers for body list
-				 * items. */
-    int **bodyContLines)	/* Array of continuation line info. */
+    Tcl_Token **bodyToken)	/* Array of pointers to pattern list items. */
 {
     enum {Switch_Exact, Switch_Glob, Switch_Regexp};
     int savedStackDepth = envPtr->currStackDepth;
     int foundDefault;		/* Flag to indicate whether a "default" clause
 				 * is present. */
@@ -1420,21 +1325,20 @@
 
     /*
      * First, we push the value we're matching against on the stack.
      */
 
-    SetLineInformation(valueIndex);
     CompileTokens(envPtr, valueTokenPtr, interp);
 
     /*
      * Generate a test for each arm.
      */
 
     contFixIndex = -1;
     contFixCount = 0;
-    fixupArray = TclStackAlloc(interp, sizeof(JumpFixup) * numBodyTokens);
-    fixupTargetArray = TclStackAlloc(interp, sizeof(int) * numBodyTokens);
+    fixupArray = ckalloc(sizeof(JumpFixup) * numBodyTokens);
+    fixupTargetArray = ckalloc(sizeof(int) * numBodyTokens);
     memset(fixupTargetArray, 0, numBodyTokens * sizeof(int));
     fixupCount = 0;
     foundDefault = 0;
     for (i=0 ; i<numBodyTokens ; i+=2) {
 	nextArmFixupIndex = -1;
@@ -1574,12 +1478,10 @@
 	 * pattern.
 	 */
 
 	OP(	POP);
 	envPtr->currStackDepth = savedStackDepth + 1;
-	envPtr->line = bodyLines[i+1];		/* TIP #280 */
-	envPtr->clNext = bodyContLines[i+1];	/* TIP #280 */
 	TclCompileCmdWord(interp, bodyToken[i+1], 1, envPtr);
 
 	if (!foundDefault) {
 	    TclEmitForwardJump(envPtr, TCL_UNCONDITIONAL_JUMP,
 		    &fixupArray[fixupCount]);
@@ -1629,12 +1531,12 @@
 		    fixupTargetArray[j] += 3;
 		}
 	    }
 	}
     }
-    TclStackFree(interp, fixupTargetArray);
-    TclStackFree(interp, fixupArray);
+    ckfree(fixupTargetArray);
+    ckfree(fixupArray);
 
     envPtr->currStackDepth = savedStackDepth + 1;
 }
 
 /*
@@ -1652,22 +1554,16 @@
 
 static void
 IssueSwitchJumpTable(
     Tcl_Interp *interp,		/* Context for compiling script bodies. */
     CompileEnv *envPtr,		/* Holds resulting instructions. */
-    ExtCmdLoc *mapPtr,		/* For mapping tokens to their source code
-				 * location. */
-    int eclIndex,
     int valueIndex,		/* The value to match against. */
     Tcl_Token *valueTokenPtr,
     int numBodyTokens,		/* Number of tokens describing things the
 				 * switch can match against and bodies to
 				 * execute when the match succeeds. */
-    Tcl_Token **bodyToken,	/* Array of pointers to pattern list items. */
-    int *bodyLines,		/* Array of line numbers for body list
-				 * items. */
-    int **bodyContLines)	/* Array of continuation line info. */
+    Tcl_Token **bodyToken)	/* Array of pointers to pattern list items. */
 {
     JumptableInfo *jtPtr;
     int savedStackDepth = envPtr->currStackDepth;
     int infoIndex, isNew, *finalFixups, numRealBodies = 0, jumpLocation;
     int mustGenerate, foundDefault, jumpToDefault, i;
@@ -1676,11 +1572,10 @@
 
     /*
      * First, we push the value we're matching against on the stack.
      */
 
-    SetLineInformation(valueIndex);
     CompileTokens(envPtr, valueTokenPtr, interp);
 
     /*
      * Compile the switch by using a jump table, which is basically a
      * hashtable that maps from literal values to match against to the offset
@@ -1692,11 +1587,11 @@
      */
 
     jtPtr = ckalloc(sizeof(JumptableInfo));
     Tcl_InitHashTable(&jtPtr->hashTable, TCL_STRING_KEYS);
     infoIndex = TclCreateAuxData(jtPtr, &tclJumptableInfoType, envPtr);
-    finalFixups = TclStackAlloc(interp, sizeof(int) * (numBodyTokens/2));
+    finalFixups = ckalloc(sizeof(int) * (numBodyTokens/2));
     foundDefault = 0;
     mustGenerate = 1;
 
     /*
      * Next, issue the instruction to do the jump, together with what we want
@@ -1780,12 +1675,10 @@
 	/*
 	 * Compile the body of the arm.
 	 */
 
 	envPtr->currStackDepth = savedStackDepth;
-	envPtr->line = bodyLines[i+1];		/* TIP #280 */
-	envPtr->clNext = bodyContLines[i+1];	/* TIP #280 */
 	TclCompileCmdWord(interp, bodyToken[i+1], 1, envPtr);
 
 	/*
 	 * Compile a jump in to the end of the command if this body is
 	 * anything other than a user-supplied default arm (to either skip
@@ -1831,11 +1724,11 @@
 
     /*
      * Clean up all our temporary space and return.
      */
 
-    TclStackFree(interp, finalFixups);
+    ckfree(finalFixups);
     envPtr->currStackDepth = savedStackDepth + 1;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -1942,11 +1835,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     Tcl_Token *tokenPtr = parsePtr->tokenPtr;
     int i;
 
     if (parsePtr->numWords < 2 || parsePtr->numWords > 256
 	    || envPtr->procPtr == NULL) {
@@ -1986,11 +1878,10 @@
 				 * created by Tcl_ParseCommand. */
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
-    DefineLineInformation;	/* TIP #280 */
     int numWords = parsePtr->numWords;
     int savedStackDepth = envPtr->currStackDepth;
     Tcl_Token *codeToken, *msgToken;
     Tcl_Obj *objPtr;
 
@@ -2119,12 +2010,10 @@
     if (numWords == 2) {
 	/*
 	 * No handlers or finally; do nothing beyond evaluating the body.
 	 */
 
-	DefineLineInformation;	/* TIP #280 */
-	SetLineInformation(1);
 	CompileBody(envPtr, bodyToken, interp);
 	return TCL_OK;
     }
 
     numWords -= 2;
@@ -2135,16 +2024,16 @@
      */
 
     numHandlers = numWords >> 2;
     numWords -= numHandlers * 4;
     if (numHandlers > 0) {
-	handlerTokens = TclStackAlloc(interp, sizeof(Tcl_Token*)*numHandlers);
-	matchClauses = TclStackAlloc(interp, sizeof(Tcl_Obj *) * numHandlers);
+	handlerTokens = ckalloc(sizeof(Tcl_Token*)*numHandlers);
+	matchClauses = ckalloc(sizeof(Tcl_Obj *) * numHandlers);
 	memset(matchClauses, 0, sizeof(Tcl_Obj *) * numHandlers);
-	matchCodes = TclStackAlloc(interp, sizeof(int) * numHandlers);
-	resultVarIndices = TclStackAlloc(interp, sizeof(int) * numHandlers);
-	optionVarIndices = TclStackAlloc(interp, sizeof(int) * numHandlers);
+	matchCodes = ckalloc(sizeof(int) * numHandlers);
+	resultVarIndices = ckalloc(sizeof(int) * numHandlers);
+	optionVarIndices = ckalloc(sizeof(int) * numHandlers);
 
 	for (i=0 ; i<numHandlers ; i++) {
 	    Tcl_Obj *tmpObj, **objv;
 	    int objc;
 
@@ -2299,15 +2188,15 @@
 	for (i=0 ; i<numHandlers ; i++) {
 	    if (matchClauses[i]) {
 		TclDecrRefCount(matchClauses[i]);
 	    }
 	}
-	TclStackFree(interp, optionVarIndices);
-	TclStackFree(interp, resultVarIndices);
-	TclStackFree(interp, matchCodes);
-	TclStackFree(interp, matchClauses);
-	TclStackFree(interp, handlerTokens);
+	ckfree(optionVarIndices);
+	ckfree(resultVarIndices);
+	ckfree(matchCodes);
+	ckfree(matchClauses);
+	ckfree(handlerTokens);
     }
     return result;
 }
 
 /*
@@ -2335,11 +2224,10 @@
     Tcl_Obj **matchClauses,
     int *resultVars,
     int *optionVars,
     Tcl_Token **handlerTokens)
 {
-    DefineLineInformation;	/* TIP #280 */
     int range, resultVar, optionsVar;
     int savedStackDepth = envPtr->currStackDepth;
     int i, j, len, forwardsNeedFixing = 0;
     int *addrsToFix, *forwardsToFix, notCodeJumpSource, notECJumpSource;
     char buf[TCL_INTEGER_SPACE];
@@ -2380,12 +2268,12 @@
      * For us to be here, there must be at least one handler.
      *
      * Slight overallocation, but reduces size of this function.
      */
 
-    addrsToFix = TclStackAlloc(interp, sizeof(int)*numHandlers);
-    forwardsToFix = TclStackAlloc(interp, sizeof(int)*numHandlers);
+    addrsToFix = ckalloc(sizeof(int)*numHandlers);
+    forwardsToFix = ckalloc(sizeof(int)*numHandlers);
 
     for (i=0 ; i<numHandlers ; i++) {
 	sprintf(buf, "%d", matchCodes[i]);
 	OP(				DUP);
 	PUSH(				buf);
@@ -2470,12 +2358,12 @@
      */
 
     for (i=0 ; i<numHandlers ; i++) {
 	FIXJUMP(addrsToFix[i]);
     }
-    TclStackFree(interp, forwardsToFix);
-    TclStackFree(interp, addrsToFix);
+    ckfree(forwardsToFix);
+    ckfree(addrsToFix);
     envPtr->currStackDepth = savedStackDepth + 1;
     return TCL_OK;
 }
 
 static int
@@ -2489,11 +2377,10 @@
     int *resultVars,
     int *optionVars,
     Tcl_Token **handlerTokens,
     Tcl_Token *finallyToken)	/* Not NULL */
 {
-    DefineLineInformation;	/* TIP #280 */
     int savedStackDepth = envPtr->currStackDepth;
     int range, resultVar, optionsVar, i, j, len, forwardsNeedFixing = 0;
     int *addrsToFix, *forwardsToFix, notCodeJumpSource, notECJumpSource;
     char buf[TCL_INTEGER_SPACE];
 
@@ -2535,12 +2422,12 @@
     if (numHandlers) {
 	/*
 	 * Slight overallocation, but reduces size of this function.
 	 */
 
-	addrsToFix = TclStackAlloc(interp, sizeof(int)*numHandlers);
-	forwardsToFix = TclStackAlloc(interp, sizeof(int)*numHandlers);
+	addrsToFix = ckalloc(sizeof(int)*numHandlers);
+	forwardsToFix = ckalloc(sizeof(int)*numHandlers);
 
 	for (i=0 ; i<numHandlers ; i++) {
 	    sprintf(buf, "%d", matchCodes[i]);
 	    OP(				DUP);
 	    PUSH(			buf);
@@ -2670,12 +2557,12 @@
 	 */
 
 	for (i=0 ; i<numHandlers-1 ; i++) {
 	    FIXJUMP(addrsToFix[i]);
 	}
-	TclStackFree(interp, forwardsToFix);
-	TclStackFree(interp, addrsToFix);
+	ckfree(forwardsToFix);
+	ckfree(addrsToFix);
     }
 
     /*
      * Drop the result code.
      */
@@ -2729,11 +2616,10 @@
     CompileEnv *envPtr)		/* Holds resulting instructions. */
 {
     Tcl_Token *varTokenPtr;
     int isScalar, simpleVarName, localIndex, numWords, flags, i;
     Tcl_Obj *leadingWord;
-    DefineLineInformation;	/* TIP #280 */
 
     numWords = parsePtr->numWords-1;
     flags = 1;
     varTokenPtr = TokenAfter(parsePtr->tokenPtr);
     leadingWord = Tcl_NewObj();
@@ -2767,12 +2653,12 @@
 	 * frame slot (entry in the array of local vars) if we are compiling a
 	 * procedure body and if the name is simple text that does not include
 	 * namespace qualifiers.
 	 */
 
-	PushVarNameWord(interp, varTokenPtr, envPtr, 0,
-		&localIndex, &simpleVarName, &isScalar, 1);
+	PushVarName(interp, varTokenPtr, envPtr, 0,
+		&localIndex, &simpleVarName, &isScalar);
 
 	/*
 	 * Emit instructions to unset the variable.
 	 */
 
@@ -2830,11 +2716,10 @@
     int testCodeOffset, bodyCodeOffset, jumpDist, range, code, boolVal;
     int savedStackDepth = envPtr->currStackDepth;
     int loopMayEnd = 1;		/* This is set to 0 if it is recognized as an
 				 * infinite loop. */
     Tcl_Obj *boolObj;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 3) {
 	return TCL_ERROR;
     }
 
@@ -2918,11 +2803,10 @@
 
     /*
      * Compile the loop body.
      */
 
-    SetLineInformation(2);
     bodyCodeOffset = ExceptionRangeStarts(envPtr, range);
     CompileBody(envPtr, bodyTokenPtr, interp);
     ExceptionRangeEnds(envPtr, range);
     envPtr->currStackDepth = savedStackDepth + 1;
     OP(		POP);
@@ -2938,11 +2822,10 @@
 	if (TclFixupForwardJump(envPtr, &jumpEvalCondFixup, jumpDist, 127)) {
 	    bodyCodeOffset += 3;
 	    testCodeOffset += 3;
 	}
 	envPtr->currStackDepth = savedStackDepth;
-	SetLineInformation(1);
 	TclCompileExprWords(interp, testTokenPtr, 1, envPtr);
 	envPtr->currStackDepth = savedStackDepth + 1;
 
 	jumpDist = CurrentOffset(envPtr) - bodyCodeOffset;
 	if (jumpDist > 127) {
@@ -3009,11 +2892,10 @@
     }
 
     if (parsePtr->numWords == 1) {
 	PushLiteral(envPtr, "", 0);
     } else {
-	DefineLineInformation;	/* TIP #280 */
 	Tcl_Token *valueTokenPtr = TokenAfter(parsePtr->tokenPtr);
 
 	CompileWord(envPtr, valueTokenPtr, interp, 1);
     }
     OP(		YIELD);
@@ -3045,14 +2927,11 @@
     Tcl_Token *varTokenPtr,	/* Points to a variable token. */
     CompileEnv *envPtr,		/* Holds resulting instructions. */
     int flags,			/* TCL_NO_LARGE_INDEX. */
     int *localIndexPtr,		/* Must not be NULL. */
     int *simpleVarNamePtr,	/* Must not be NULL. */
-    int *isScalarPtr,		/* Must not be NULL. */
-    int line,			/* Line the token starts on. */
-    int *clNext)		/* Reference to offset of next hidden cont.
-				 * line. */
+    int *isScalarPtr)		/* Must not be NULL. */
 {
     register const char *p;
     const char *name, *elName;
     register int i, n;
     Tcl_Token *elemTokenPtr = NULL;
@@ -3109,11 +2988,11 @@
 		/*
 		 * An array element, the element name is a simple string:
 		 * assemble the corresponding token.
 		 */
 
-		elemTokenPtr = TclStackAlloc(interp, sizeof(Tcl_Token));
+		elemTokenPtr = ckalloc(sizeof(Tcl_Token));
 		allocedTokens = 1;
 		elemTokenPtr->type = TCL_TOKEN_TEXT;
 		elemTokenPtr->start = elName;
 		elemTokenPtr->size = elNameChars;
 		elemTokenPtr->numComponents = 0;
@@ -3162,11 +3041,11 @@
 		/*
 		 * Make a first token with the extra characters in the first
 		 * token.
 		 */
 
-		elemTokenPtr = TclStackAlloc(interp, n * sizeof(Tcl_Token));
+		elemTokenPtr = ckalloc(n * sizeof(Tcl_Token));
 		allocedTokens = 1;
 		elemTokenPtr->type = TCL_TOKEN_TEXT;
 		elemTokenPtr->start = elName;
 		elemTokenPtr->size = remainingChars;
 		elemTokenPtr->numComponents = 0;
@@ -3228,12 +3107,10 @@
 	 * Compile the element script, if any.
 	 */
 
 	if (elName != NULL) {
 	    if (elNameChars) {
-		envPtr->line = line;
-		envPtr->clNext = clNext;
 		TclCompileTokens(interp, elemTokenPtr, elemTokenCount,
 			envPtr);
 	    } else {
 		PushLiteral(envPtr, "", 0);
 	    }
@@ -3241,20 +3118,18 @@
     } else {
 	/*
 	 * The var name isn't simple: compile and push it.
 	 */
 
-	envPtr->line = line;
-	envPtr->clNext = clNext;
 	CompileTokens(envPtr, varTokenPtr, interp);
     }
 
     if (removedParen) {
 	varTokenPtr[removedParen].size++;
     }
     if (allocedTokens) {
-	TclStackFree(interp, elemTokenPtr);
+	ckfree(elemTokenPtr);
     }
     *localIndexPtr = localIndex;
     *simpleVarNamePtr = simpleVarName;
     *isScalarPtr = (elName == NULL);
     return TCL_OK;
@@ -3284,11 +3159,10 @@
     Tcl_Parse *parsePtr,
     int instruction,
     CompileEnv *envPtr)
 {
     Tcl_Token *tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords != 2) {
 	return TCL_ERROR;
     }
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
@@ -3326,11 +3200,10 @@
     const char *identity,
     int instruction,
     CompileEnv *envPtr)
 {
     Tcl_Token *tokenPtr = parsePtr->tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     int words;
 
     for (words=1 ; words<parsePtr->numWords ; words++) {
 	tokenPtr = TokenAfter(tokenPtr);
 	CompileWord(envPtr, tokenPtr, interp, words);
@@ -3410,11 +3283,10 @@
     Tcl_Parse *parsePtr,
     int instruction,
     CompileEnv *envPtr)
 {
     Tcl_Token *tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
 
     if (parsePtr->numWords < 3) {
 	PushLiteral(envPtr, "1", 1);
     } else if (parsePtr->numWords == 3) {
 	tokenPtr = TokenAfter(parsePtr->tokenPtr);
@@ -3576,11 +3448,10 @@
      * This one has its own implementation because the ** operator is the only
      * one with right associativity.
      */
 
     Tcl_Token *tokenPtr = parsePtr->tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     int words;
 
     for (words=1 ; words<parsePtr->numWords ; words++) {
 	tokenPtr = TokenAfter(tokenPtr);
 	CompileWord(envPtr, tokenPtr, interp, words);
@@ -3746,11 +3617,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)
 {
     Tcl_Token *tokenPtr = parsePtr->tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     int words;
 
     if (parsePtr->numWords == 1) {
 	/*
 	 * Fallback to direct eval to report syntax error.
@@ -3791,11 +3661,10 @@
     Command *cmdPtr,		/* Points to defintion of command being
 				 * compiled. */
     CompileEnv *envPtr)
 {
     Tcl_Token *tokenPtr = parsePtr->tokenPtr;
-    DefineLineInformation;	/* TIP #280 */
     int words;
 
     if (parsePtr->numWords == 1) {
 	/*
 	 * Fallback to direct eval to report syntax error.

Index: generic/tclCompExpr.c
==================================================================
--- generic/tclCompExpr.c
+++ generic/tclCompExpr.c
@@ -915,11 +915,11 @@
 		scanned = tokenPtr->size;
 		break;
 
 	    case SCRIPT: {
 		Tcl_Parse *nestedPtr =
-			TclStackAlloc(interp, sizeof(Tcl_Parse));
+			ckalloc(sizeof(Tcl_Parse));
 
 		tokenPtr = parsePtr->tokenPtr + parsePtr->numTokens;
 		tokenPtr->type = TCL_TOKEN_COMMAND;
 		tokenPtr->start = start;
 		tokenPtr->numComponents = 0;
@@ -950,11 +950,11 @@
 			code = TCL_ERROR;
 			errCode = "UNBALANCED";
 			break;
 		    }
 		}
-		TclStackFree(interp, nestedPtr);
+		ckfree(nestedPtr);
 		end = start;
 		start = tokenPtr->start;
 		scanned = end - start;
 		tokenPtr->size = scanned;
 		parsePtr->numTokens++;
@@ -1833,11 +1833,11 @@
 {
     int code;
     OpNode *opTree = NULL;	/* Will point to the tree of operators. */
     Tcl_Obj *litList = Tcl_NewObj();	/* List to hold the literals. */
     Tcl_Obj *funcList = Tcl_NewObj();	/* List to hold the functon names. */
-    Tcl_Parse *exprParsePtr = TclStackAlloc(interp, sizeof(Tcl_Parse));
+    Tcl_Parse *exprParsePtr = ckalloc(sizeof(Tcl_Parse));
 				/* Holds the Tcl_Tokens of substitutions. */
 
     if (numBytes < 0) {
 	numBytes = (start ? strlen(start) : 0);
     }
@@ -1855,11 +1855,11 @@
 	parsePtr->term = exprParsePtr->term;
 	parsePtr->errorType = exprParsePtr->errorType;
     }
 
     Tcl_FreeParse(exprParsePtr);
-    TclStackFree(interp, exprParsePtr);
+    ckfree(exprParsePtr);
     ckfree(opTree);
     return code;
 }
 
 /*
@@ -2125,11 +2125,11 @@
     int optimize)		/* 0 for one-off expressions. */
 {
     OpNode *opTree = NULL;	/* Will point to the tree of operators */
     Tcl_Obj *litList = Tcl_NewObj();	/* List to hold the literals */
     Tcl_Obj *funcList = Tcl_NewObj();	/* List to hold the functon names*/
-    Tcl_Parse *parsePtr = TclStackAlloc(interp, sizeof(Tcl_Parse));
+    Tcl_Parse *parsePtr = ckalloc(sizeof(Tcl_Parse));
 				/* Holds the Tcl_Tokens of substitutions */
 
     int code = ParseExpr(interp, script, numBytes, &opTree, litList,
 	    funcList, parsePtr, 0 /* parseOnly */);
 
@@ -2140,24 +2140,20 @@
 
 	int objc;
 	Tcl_Obj *const *litObjv;
 	Tcl_Obj **funcObjv;
 
-	/* TIP #280 : Track Lines within the expression */
-	TclAdvanceLines(&envPtr->line, script,
-		script + TclParseAllWhiteSpace(script, numBytes));
-
 	TclListObjGetElements(NULL, litList, &objc, (Tcl_Obj ***)&litObjv);
 	TclListObjGetElements(NULL, funcList, &objc, &funcObjv);
 	CompileExprTree(interp, opTree, 0, &litObjv, funcObjv,
 		parsePtr->tokenPtr, envPtr, optimize);
     } else {
 	TclCompileSyntaxError(interp, envPtr);
     }
 
     Tcl_FreeParse(parsePtr);
-    TclStackFree(interp, parsePtr);
+    ckfree(parsePtr);
     Tcl_DecrRefCount(funcList);
     Tcl_DecrRefCount(litList);
     ckfree(opTree);
 }
 
@@ -2196,19 +2192,19 @@
      * Note we are compiling an expression with literal arguments. This means
      * there can be no [info frame] calls when we execute the resulting
      * bytecode, so there's no need to tend to TIP 280 issues.
      */
 
-    envPtr = TclStackAlloc(interp, sizeof(CompileEnv));
-    TclInitCompileEnv(interp, envPtr, NULL, 0, NULL, 0);
+    envPtr = ckalloc(sizeof(CompileEnv));
+    TclInitCompileEnv(interp, envPtr, NULL, 0);
     CompileExprTree(interp, nodes, index, litObjvPtr, NULL, NULL, envPtr,
 	    0 /* optimize */);
     TclEmitOpcode(INST_DONE, envPtr);
     Tcl_IncrRefCount(byteCodeObj);
     TclInitByteCodeObj(byteCodeObj, envPtr);
     TclFreeCompileEnv(envPtr);
-    TclStackFree(interp, envPtr);
+    ckfree(envPtr);
     byteCodePtr = byteCodeObj->internalRep.otherValuePtr;
     TclNRExecuteByteCode(interp, byteCodePtr);
     code = TclNRRunCallbacks(interp, TCL_OK, rootPtr);
     Tcl_DecrRefCount(byteCodeObj);
     return code;
@@ -2261,28 +2257,28 @@
 	if (nodePtr->mark == MARK_LEFT) {
 	    next = nodePtr->left;
 
 	    switch (nodePtr->lexeme) {
 	    case QUESTION:
-		newJump = TclStackAlloc(interp, sizeof(JumpList));
+		newJump = ckalloc(sizeof(JumpList));
 		newJump->next = jumpPtr;
 		jumpPtr = newJump;
-		newJump = TclStackAlloc(interp, sizeof(JumpList));
+		newJump = ckalloc(sizeof(JumpList));
 		newJump->next = jumpPtr;
 		jumpPtr = newJump;
 		jumpPtr->depth = envPtr->currStackDepth;
 		convert = 1;
 		break;
 	    case AND:
 	    case OR:
-		newJump = TclStackAlloc(interp, sizeof(JumpList));
+		newJump = ckalloc(sizeof(JumpList));
 		newJump->next = jumpPtr;
 		jumpPtr = newJump;
-		newJump = TclStackAlloc(interp, sizeof(JumpList));
+		newJump = ckalloc(sizeof(JumpList));
 		newJump->next = jumpPtr;
 		jumpPtr = newJump;
-		newJump = TclStackAlloc(interp, sizeof(JumpList));
+		newJump = ckalloc(sizeof(JumpList));
 		newJump->next = jumpPtr;
 		jumpPtr = newJump;
 		jumpPtr->depth = envPtr->currStackDepth;
 		break;
 	    }
@@ -2384,14 +2380,14 @@
 			jumpPtr->offset - jumpPtr->jump.codeOffset, 127);
 		convert |= jumpPtr->convert;
 		envPtr->currStackDepth = jumpPtr->depth + 1;
 		freePtr = jumpPtr;
 		jumpPtr = jumpPtr->next;
-		TclStackFree(interp, freePtr);
+		ckfree(freePtr);
 		freePtr = jumpPtr;
 		jumpPtr = jumpPtr->next;
-		TclStackFree(interp, freePtr);
+		ckfree(freePtr);
 		break;
 	    case AND:
 	    case OR:
 		CLANG_ASSERT(jumpPtr);
 		TclEmitForwardJump(envPtr, (nodePtr->lexeme == AND)
@@ -2411,17 +2407,17 @@
 			127);
 		convert = 0;
 		envPtr->currStackDepth = jumpPtr->depth + 1;
 		freePtr = jumpPtr;
 		jumpPtr = jumpPtr->next;
-		TclStackFree(interp, freePtr);
+		ckfree(freePtr);
 		freePtr = jumpPtr;
 		jumpPtr = jumpPtr->next;
-		TclStackFree(interp, freePtr);
+		ckfree(freePtr);
 		freePtr = jumpPtr;
 		jumpPtr = jumpPtr->next;
-		TclStackFree(interp, freePtr);
+		ckfree(freePtr);
 		break;
 	    default:
 		TclEmitOpcode(instruction[nodePtr->lexeme], envPtr);
 		convert = 0;
 		break;
@@ -2621,13 +2617,12 @@
 
     if (objc < 3) {
 	Tcl_SetObjResult(interp, Tcl_NewBooleanObj(1));
     } else {
 	TclOpCmdClientData *occdPtr = clientData;
-	Tcl_Obj **litObjv = TclStackAlloc(interp,
-		2 * (objc-2) * sizeof(Tcl_Obj *));
-	OpNode *nodes = TclStackAlloc(interp, 2 * (objc-2) * sizeof(OpNode));
+	Tcl_Obj **litObjv = ckalloc(2 * (objc-2) * sizeof(Tcl_Obj *));
+	OpNode *nodes = ckalloc(2 * (objc-2) * sizeof(OpNode));
 	unsigned char lexeme;
 	int i, lastAnd = 1;
 	Tcl_Obj *const *litObjPtrPtr = litObjv;
 
 	ParseLexeme(occdPtr->op, strlen(occdPtr->op), &lexeme, NULL);
@@ -2663,12 +2658,12 @@
 	nodes[0].right = lastAnd;
 	nodes[lastAnd].p.parent = 0;
 
 	code = ExecConstantExprTree(interp, nodes, 0, &litObjPtrPtr);
 
-	TclStackFree(interp, nodes);
-	TclStackFree(interp, litObjv);
+	ckfree(nodes);
+	ckfree(litObjv);
     }
     return code;
 }
 
 /*
@@ -2750,11 +2745,11 @@
 
 	Tcl_DecrRefCount(litObjv[decrMe]);
 	return code;
     } else {
 	Tcl_Obj *const *litObjv = objv + 1;
-	OpNode *nodes = TclStackAlloc(interp, (objc-1) * sizeof(OpNode));
+	OpNode *nodes = ckalloc((objc-1) * sizeof(OpNode));
 	int i, lastOp = OT_LITERAL;
 
 	nodes[0].lexeme = START;
 	nodes[0].mark = MARK_RIGHT;
 	if (lexeme == EXPON) {
@@ -2783,11 +2778,11 @@
 	nodes[0].right = lastOp;
 	nodes[lastOp].p.parent = 0;
 
 	code = ExecConstantExprTree(interp, nodes, 0, &litObjv);
 
-	TclStackFree(interp, nodes);
+	ckfree(nodes);
 	return code;
     }
 }
 
 /*

Index: generic/tclCompile.c
==================================================================
--- generic/tclCompile.c
+++ generic/tclCompile.c
@@ -563,19 +563,10 @@
 			    const unsigned char *pc, Tcl_Obj *bufferObj);
 static void		PrintSourceToObj(Tcl_Obj *appendObj,
 			    const char *stringPtr, int maxChars);
 static void		UpdateStringOfInstName(Tcl_Obj *objPtr);
 
-/*
- * TIP #280: Helper for building the per-word line information of all compiled
- * commands.
- */
-static void		EnterCmdWordData(ExtCmdLoc *eclPtr, int srcOffset,
-			    Tcl_Token *tokenPtr, const char *cmd, int len,
-			    int numWords, int line, int *clNext, int **lines,
-			    CompileEnv *envPtr);
-
 /*
  * The structure below defines the bytecode Tcl object type by means of
  * procedures that can be invoked by generic object code.
  */
 
@@ -645,19 +636,17 @@
 				 * compiled. Must not be NULL. */
     Tcl_Obj *objPtr,		/* The object to make a ByteCode object. */
     CompileHookProc *hookProc,	/* Procedure to invoke after compilation. */
     ClientData clientData)	/* Hook procedure private data. */
 {
-    Interp *iPtr = (Interp *) interp;
     CompileEnv compEnv;		/* Compilation environment structure allocated
 				 * in frame. */
     register const AuxData *auxDataPtr;
     LiteralEntry *entryPtr;
     register int i;
     int length, result = TCL_OK;
     const char *stringPtr;
-    ContLineLoc *clLocPtr;
 
 #ifdef TCL_COMPILE_DEBUG
     if (!traceInitialized) {
 	if (Tcl_LinkVar(interp, "tcl_traceCompile",
 		(char *) &tclTraceCompile, TCL_LINK_INT) != TCL_OK) {
@@ -667,18 +656,11 @@
     }
 #endif
 
     stringPtr = TclGetStringFromObj(objPtr, &length);
 
-    /*
-     * TIP #280: Pick up the CmdFrame in which the BC compiler was invoked and
-     * use to initialize the tracking in the compiler. This information was
-     * stored by TclCompEvalObj and ProcCompileProc.
-     */
-
-    TclInitCompileEnv(interp, &compEnv, stringPtr, length,
-	    iPtr->invokeCmdFramePtr, iPtr->invokeWord);
+    TclInitCompileEnv(interp, &compEnv, stringPtr, length);
 
     /*
      * Now we check if we have data about invisible continuation lines for the
      * script, and make it available to the compile environment, if so.
      *
@@ -688,17 +670,10 @@
      * lock on it. We release this lock in the function TclFreeCompileEnv(),
      * found in this file. The "lineCLPtr" hashtable is managed in the file
      * "tclObj.c".
      */
 
-    clLocPtr = TclContinuationsGet(objPtr);
-    if (clLocPtr) {
-	compEnv.clLoc = clLocPtr;
-	compEnv.clNext = &compEnv.clLoc->loc[0];
-	Tcl_Preserve(compEnv.clLoc);
-    }
-
     TclCompileScript(interp, stringPtr, length, &compEnv);
 
     /*
      * Successful compilation. Add a "done" instruction at the end.
      */
@@ -739,11 +714,11 @@
 	for (i = 0;  i < compEnv.literalArrayNext;  i++) {
 	    TclReleaseLiteral(interp, entryPtr->objPtr);
 	    entryPtr++;
 	}
 #ifdef TCL_COMPILE_DEBUG
-	TclVerifyGlobalLiteralTable(iPtr);
+	TclVerifyGlobalLiteralTable((Interp *)interp);
 #endif /*TCL_COMPILE_DEBUG*/
 
 	auxDataPtr = compEnv.auxDataArrayPtr;
 	for (i = 0;  i < compEnv.auxDataArrayNext;  i++) {
 	    if (auxDataPtr->type->freeProc != NULL) {
@@ -877,11 +852,10 @@
 void
 TclCleanupByteCode(
     register ByteCode *codePtr)	/* Points to the ByteCode to free. */
 {
     Tcl_Interp *interp = (Tcl_Interp *) *codePtr->interpHandle;
-    Interp *iPtr = (Interp *) interp;
     int numLitObjects = codePtr->numLitObjects;
     int numAuxDataItems = codePtr->numAuxDataItems;
     register Tcl_Obj **objArrayPtr, *objPtr;
     register const AuxData *auxDataPtr;
     int i;
@@ -890,11 +864,11 @@
     if (interp != NULL) {
 	ByteCodeStats *statsPtr;
 	Tcl_Time destroyTime;
 	int lifetimeSec, lifetimeMicroSec, log2;
 
-	statsPtr = &iPtr->stats;
+	statsPtr = &((Interp *)interp)->stats;
 
 	statsPtr->numByteCodesFreed++;
 	statsPtr->currentSrcBytes -= (double) codePtr->numSrcBytes;
 	statsPtr->currentByteCodeBytes -= (double) codePtr->structureSize;
 
@@ -975,43 +949,10 @@
     for (i = 0;  i < numAuxDataItems;  i++) {
 	if (auxDataPtr->type->freeProc != NULL) {
 	    auxDataPtr->type->freeProc(auxDataPtr->clientData);
 	}
 	auxDataPtr++;
-    }
-
-    /*
-     * TIP #280. Release the location data associated with this byte code
-     * structure, if any. NOTE: The interp we belong to may be gone already,
-     * and the data with it.
-     *
-     * See also tclBasic.c, DeleteInterpProc
-     */
-
-    if (iPtr) {
-	Tcl_HashEntry *hePtr = Tcl_FindHashEntry(iPtr->lineBCPtr,
-		(char *) codePtr);
-
-	if (hePtr) {
-	    ExtCmdLoc *eclPtr = Tcl_GetHashValue(hePtr);
-
-	    if (eclPtr->type == TCL_LOCATION_SOURCE) {
-		Tcl_DecrRefCount(eclPtr->path);
-	    }
-	    for (i=0 ; i<eclPtr->nuloc ; i++) {
-		ckfree(eclPtr->loc[i].line);
-	    }
-
-	    if (eclPtr->loc != NULL) {
-		ckfree(eclPtr->loc);
-	    }
-
-	    Tcl_DeleteHashTable(&eclPtr->litInfo);
-
-	    ckfree(eclPtr);
-	    Tcl_DeleteHashEntry(hePtr);
-	}
     }
 
     if (codePtr->localCachePtr && (--codePtr->localCachePtr->refCount == 0)) {
 	TclFreeLocalCache(interp, codePtr->localCachePtr);
     }
@@ -1132,14 +1073,13 @@
     if (objPtr->typePtr != &substCodeType) {
 	CompileEnv compEnv;
 	int numBytes;
 	const char *bytes = Tcl_GetStringFromObj(objPtr, &numBytes);
 
-	/* TODO: Check for more TIP 280 */
-	TclInitCompileEnv(interp, &compEnv, bytes, numBytes, NULL, 0);
+	TclInitCompileEnv(interp, &compEnv, bytes, numBytes);
 
-	TclSubstCompile(interp, bytes, numBytes, flags, 1, &compEnv);
+	TclSubstCompile(interp, bytes, numBytes, flags, &compEnv);
 
 	TclEmitOpcode(INST_DONE, &compEnv);
 	TclInitByteCodeObj(objPtr, &compEnv);
 	objPtr->typePtr = &substCodeType;
 	TclFreeCompileEnv(&compEnv);
@@ -1212,14 +1152,11 @@
     Tcl_Interp *interp,		/* The interpreter for which a CompileEnv
 				 * structure is initialized. */
     register CompileEnv *envPtr,/* Points to the CompileEnv structure to
 				 * initialize. */
     const char *stringPtr,	/* The source string to be compiled. */
-    int numBytes,		/* Number of bytes in source string. */
-    const CmdFrame *invoker,	/* Location context invoking the bcc */
-    int word)			/* Index of the word in that context getting
-				 * compiled */
+    int numBytes)		/* Number of bytes in source string. */
 {
     Interp *iPtr = (Interp *) interp;
 
     envPtr->iPtr = iPtr;
     envPtr->source = stringPtr;
@@ -1251,142 +1188,10 @@
     envPtr->cmdMapPtr = envPtr->staticCmdMapSpace;
     envPtr->cmdMapEnd = COMPILEENV_INIT_CMD_MAP_SIZE;
     envPtr->mallocedCmdMap = 0;
     envPtr->atCmdStart = 1;
 
-    /*
-     * TIP #280: Set up the extended command location information, based on
-     * the context invoking the byte code compiler. This structure is used to
-     * keep the per-word line information for all compiled commands.
-     *
-     * See also tclBasic.c, TclEvalObjEx, for the equivalent code in the
-     * non-compiling evaluator
-     */
-
-    envPtr->extCmdMapPtr = ckalloc(sizeof(ExtCmdLoc));
-    envPtr->extCmdMapPtr->loc = NULL;
-    envPtr->extCmdMapPtr->nloc = 0;
-    envPtr->extCmdMapPtr->nuloc = 0;
-    envPtr->extCmdMapPtr->path = NULL;
-    Tcl_InitHashTable(&envPtr->extCmdMapPtr->litInfo, TCL_ONE_WORD_KEYS);
-
-    if ((invoker == NULL) || (invoker->type == TCL_LOCATION_EVAL_LIST)) {
-	/*
-	 * Initialize the compiler for relative counting in case of a
-	 * dynamic context.
-	 */
-
-	envPtr->line = 1;
-	if (iPtr->evalFlags & TCL_EVAL_FILE) {
-	    iPtr->evalFlags &= ~TCL_EVAL_FILE;
-	    envPtr->extCmdMapPtr->type = TCL_LOCATION_SOURCE;
-
-	    if (iPtr->scriptFile) {
-		/*
-		 * Normalization here, to have the correct pwd. Should have
-		 * negligible impact on performance, as the norm should have
-		 * been done already by the 'source' invoking us, and it
-		 * caches the result.
-		 */
-
-		Tcl_Obj *norm =
-			Tcl_FSGetNormalizedPath(interp, iPtr->scriptFile);
-
-		if (norm == NULL) {
-		    /*
-		     * Error message in the interp result. No place to put it.
-		     * And no place to serve the error itself to either. Fake
-		     * a path, empty string.
-		     */
-
-		    TclNewLiteralStringObj(envPtr->extCmdMapPtr->path, "");
-		} else {
-		    envPtr->extCmdMapPtr->path = norm;
-		}
-	    } else {
-		TclNewLiteralStringObj(envPtr->extCmdMapPtr->path, "");
-	    }
-
-	    Tcl_IncrRefCount(envPtr->extCmdMapPtr->path);
-	} else {
-	    envPtr->extCmdMapPtr->type =
-		(envPtr->procPtr ? TCL_LOCATION_PROC : TCL_LOCATION_BC);
-	}
-    } else {
-	/*
-	 * Initialize the compiler using the context, making counting absolute
-	 * to that context. Note that the context can be byte code execution.
-	 * In that case we have to fill out the missing pieces (line, path,
-	 * ...) which may make change the type as well.
-	 */
-
-	CmdFrame *ctxPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-	int pc = 0;
-
-	*ctxPtr = *invoker;
-	if (invoker->type == TCL_LOCATION_BC) {
-	    /*
-	     * Note: Type BC => ctx.data.eval.path    is not used.
-	     *			ctx.data.tebc.codePtr is used instead.
-	     */
-
-	    TclGetSrcInfoForPc(ctxPtr);
-	    pc = 1;
-	}
-
-	if ((ctxPtr->nline <= word) || (ctxPtr->line[word] < 0)) {
-	    /*
-	     * Word is not a literal, relative counting.
-	     */
-
-	    envPtr->line = 1;
-	    envPtr->extCmdMapPtr->type =
-		    (envPtr->procPtr ? TCL_LOCATION_PROC : TCL_LOCATION_BC);
-
-	    if (pc && (ctxPtr->type == TCL_LOCATION_SOURCE)) {
-		/*
-		 * The reference made by 'TclGetSrcInfoForPc' is dead.
-		 */
-
-		Tcl_DecrRefCount(ctxPtr->data.eval.path);
-	    }
-	} else {
-	    envPtr->line = ctxPtr->line[word];
-	    envPtr->extCmdMapPtr->type = ctxPtr->type;
-
-	    if (ctxPtr->type == TCL_LOCATION_SOURCE) {
-		envPtr->extCmdMapPtr->path = ctxPtr->data.eval.path;
-
-		if (pc) {
-		    /*
-		     * The reference 'TclGetSrcInfoForPc' made is transfered.
-		     */
-
-		    ctxPtr->data.eval.path = NULL;
-		} else {
-		    /*
-		     * We have a new reference here.
-		     */
-
-		    Tcl_IncrRefCount(envPtr->extCmdMapPtr->path);
-		}
-	    }
-	}
-
-	TclStackFree(interp, ctxPtr);
-    }
-
-    envPtr->extCmdMapPtr->start = envPtr->line;
-
-    /*
-     * Initialize the data about invisible continuation lines as empty, i.e.
-     * not used. The caller (TclSetByteCodeFromAny) will set this up, if such
-     * data is available.
-     */
-
-    envPtr->clLoc = NULL;
-    envPtr->clNext = NULL;
 
     envPtr->auxDataArrayPtr = envPtr->staticAuxDataArraySpace;
     envPtr->auxDataArrayNext = 0;
     envPtr->auxDataArrayEnd = COMPILEENV_INIT_AUX_DATA_SIZE;
     envPtr->mallocedAuxDataArray = 0;
@@ -1435,23 +1240,10 @@
 	ckfree(envPtr->cmdMapPtr);
     }
     if (envPtr->mallocedAuxDataArray) {
 	ckfree(envPtr->auxDataArrayPtr);
     }
-    if (envPtr->extCmdMapPtr) {
-	ckfree(envPtr->extCmdMapPtr);
-    }
-
-    /*
-     * If we used data about invisible continuation lines, then now is the
-     * time to release on our hold on it. The lock was set in function
-     * TclSetByteCodeFromAny(), found in this file.
-     */
-
-    if (envPtr->clLoc) {
-	Tcl_Release(envPtr->clLoc);
-    }
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -1573,14 +1365,11 @@
     Namespace *cmdNsPtr;
     Command *cmdPtr;
     Tcl_Token *tokenPtr;
     int bytesLeft, isFirstCmd, wordIdx, currCmdIndex, commandLength, objIndex;
     Tcl_DString ds;
-    /* TIP #280 */
-    ExtCmdLoc *eclPtr = envPtr->extCmdMapPtr;
-    int *wlines, wlineat, cmdLine, *clNext;
-    Tcl_Parse *parsePtr = TclStackAlloc(interp, sizeof(Tcl_Parse));
+    Tcl_Parse *parsePtr = ckalloc(sizeof(Tcl_Parse));
 
     Tcl_DStringInit(&ds);
 
     if (numBytes < 0) {
 	numBytes = strlen(script);
@@ -1599,12 +1388,10 @@
      * from the script.
      */
 
     p = script;
     bytesLeft = numBytes;
-    cmdLine = envPtr->line;
-    clNext = envPtr->clNext;
     do {
 	if (Tcl_ParseCommand(interp, p, bytesLeft, 0, parsePtr) != TCL_OK) {
 	    /*
 	     * Compile bytecodes to report the parse error at runtime.
 	     */
@@ -1616,22 +1403,10 @@
 		    parsePtr->commandSize - 1 : parsePtr->commandSize);
 	    TclCompileSyntaxError(interp, envPtr);
 	    break;
 	}
 
-	/*
-	 * TIP #280: We have to count newlines before the command even in the
-	 * degenerate case when the command has no words. (See test
-	 * info-30.33).
-	 * So make that counting here, and not in the (numWords > 0) branch
-	 * below.
-	 */
-
-	TclAdvanceLines(&cmdLine, p, parsePtr->commandStart);
-	TclAdvanceContinuations(&cmdLine, &clNext,
-		parsePtr->commandStart - envPtr->source);
-
 	if (parsePtr->numWords > 0) {
 	    int expand = 0;	/* Set if there are dynamic expansions to
 				 * handle */
 
 	    /*
@@ -1704,35 +1479,19 @@
 
 	    if (expand) {
 		TclEmitOpcode(INST_EXPAND_START, envPtr);
 	    }
 
-	    /*
-	     * TIP #280. Scan the words and compute the extended location
-	     * information. The map first contain full per-word line
-	     * information for use by the compiler. This is later replaced by
-	     * a reduced form which signals non-literal words, stored in
-	     * 'wlines'.
-	     */
-
-	    EnterCmdWordData(eclPtr, parsePtr->commandStart - envPtr->source,
-		    parsePtr->tokenPtr, parsePtr->commandStart,
-		    parsePtr->commandSize, parsePtr->numWords, cmdLine,
-		    clNext, &wlines, envPtr);
-	    wlineat = eclPtr->nuloc - 1;
-
 	    /*
 	     * Each iteration of the following loop compiles one word from the
 	     * command.
 	     */
 
 	    for (wordIdx = 0, tokenPtr = parsePtr->tokenPtr;
 		    wordIdx < parsePtr->numWords; wordIdx++,
 		    tokenPtr += tokenPtr->numComponents + 1) {
 
-		envPtr->line = eclPtr->loc[wlineat].line[wordIdx];
-		envPtr->clNext = eclPtr->loc[wlineat].next[wordIdx];
 		if (tokenPtr->type != TCL_TOKEN_SIMPLE_WORD) {
 		    /*
 		     * The word is not a simple string of characters.
 		     */
 
@@ -1905,17 +1664,10 @@
 		     * which already allows absolute counting.
 		     */
 
 		    objIndex = TclRegisterNewLiteral(envPtr,
 			    tokenPtr[1].start, tokenPtr[1].size);
-
-		    if (envPtr->clNext) {
-			TclContinuationsEnterDerived(
-				envPtr->literalArrayPtr[objIndex].objPtr,
-				tokenPtr[1].start - envPtr->source,
-				eclPtr->loc[wlineat].next[wordIdx]);
-		    }
 		}
 		TclEmitPush(objIndex, envPtr);
 	    } /* for loop */
 
 	    /*
@@ -1941,20 +1693,10 @@
 		 */
 
 		TclEmitOpcode(INST_INVOKE_EXPANDED, envPtr);
 		TclAdjustStackDepth((1-wordIdx), envPtr);
 	    } else if (wordIdx > 0) {
-		/*
-		 * Save PC -> command map for the TclArgumentBC* functions.
-		 */
-
-		int isnew;
-		Tcl_HashEntry *hePtr = Tcl_CreateHashEntry(&eclPtr->litInfo,
-			INT2PTR(envPtr->codeNext - envPtr->codeStart),
-			&isnew);
-
-		Tcl_SetHashValue(hePtr, INT2PTR(wlineat));
 		if (wordIdx <= 255) {
 		    TclEmitInstInt1(INST_INVOKE_STK1, wordIdx, envPtr);
 		} else {
 		    TclEmitInstInt4(INST_INVOKE_STK4, wordIdx, envPtr);
 		}
@@ -1968,46 +1710,22 @@
 	finishCommand:
 	    EnterCmdExtentData(envPtr, currCmdIndex, commandLength,
 		    (envPtr->codeNext-envPtr->codeStart) - startCodeOffset);
 	    isFirstCmd = 0;
 
-	    /*
-	     * TIP #280: Free full form of per-word line data and insert the
-	     * reduced form now
-	     */
-
-	    ckfree(eclPtr->loc[wlineat].line);
-	    ckfree(eclPtr->loc[wlineat].next);
-	    eclPtr->loc[wlineat].line = wlines;
-	    eclPtr->loc[wlineat].next = NULL;
 	} /* end if parsePtr->numWords > 0 */
 
 	/*
 	 * Advance to the next command in the script.
 	 */
 
 	next = parsePtr->commandStart + parsePtr->commandSize;
 	bytesLeft -= next - p;
 	p = next;
-
-	/*
-	 * TIP #280: Track lines in the just compiled command.
-	 */
-
-	TclAdvanceLines(&cmdLine, parsePtr->commandStart, p);
-	TclAdvanceContinuations(&cmdLine, &clNext, p - envPtr->source);
 	Tcl_FreeParse(parsePtr);
     } while (bytesLeft > 0);
 
-    /*
-     * TIP #280: Bring the line counts in the CompEnv up to date.
-     *	See tests info-30.33,34,35 .
-     */
-
-    envPtr->line = cmdLine;
-    envPtr->clNext = clNext;
-
     /*
      * If the source script yielded no instructions (e.g., if it was empty),
      * push an empty string as the command's result.
      */
 
@@ -2014,11 +1732,11 @@
     if (envPtr->codeNext == entryCodeNext) {
 	TclEmitPush(TclRegisterNewLiteral(envPtr, "", 0), envPtr);
     }
 
     envPtr->numSrcBytes = p - script;
-    TclStackFree(interp, parsePtr);
+    ckfree(parsePtr);
     Tcl_DStringFree(&ds);
 }
 
 /*
  *----------------------------------------------------------------------
@@ -2086,13 +1804,10 @@
 
     /*
      * Emit instructions to load the variable.
      */
 
-    TclAdvanceLines(&envPtr->line, tokenPtr[1].start,
-	    tokenPtr[1].start + tokenPtr[1].size);
-
     if (tokenPtr->numComponents == 1) {
 	if (localVar < 0) {
 	    TclEmitOpcode(INST_LOAD_SCALAR_STK, envPtr);
 	} else if (localVar <= 255) {
 	    TclEmitInstInt1(INST_LOAD_SCALAR1, localVar, envPtr);
@@ -2121,90 +1836,28 @@
     CompileEnv *envPtr)		/* Holds the resulting instructions. */
 {
     Tcl_DString textBuffer;	/* Holds concatenated chars from adjacent
 				 * TCL_TOKEN_TEXT, TCL_TOKEN_BS tokens. */
     char buffer[TCL_UTF_MAX];
-    int i, numObjsToConcat, length;
+    int numObjsToConcat, length;
     unsigned char *entryCodeNext = envPtr->codeNext;
-#define NUM_STATIC_POS 20
-    int isLiteral, maxNumCL, numCL;
-    int *clPosition = NULL;
-
-    /*
-     * For the handling of continuation lines in literals we first check if
-     * this is actually a literal. For if not we can forego the additional
-     * processing. Otherwise we pre-allocate a small table to store the
-     * locations of all continuation lines we find in this literal, if any.
-     * The table is extended if needed.
-     *
-     * Note: Different to the equivalent code in function 'TclSubstTokens()'
-     * (see file "tclParse.c") we do not seem to need the 'adjust' variable.
-     * We also do not seem to need code which merges continuation line
-     * information of multiple words which concat'd at runtime. Either that or
-     * I have not managed to find a test case for these two possibilities yet.
-     * It might be a difference between compile- versus run-time processing.
-     */
-
-    numCL = 0;
-    maxNumCL = 0;
-    isLiteral = 1;
-    for (i=0 ; i < count; i++) {
-	if ((tokenPtr[i].type != TCL_TOKEN_TEXT)
-		&& (tokenPtr[i].type != TCL_TOKEN_BS)) {
-	    isLiteral = 0;
-	    break;
-	}
-    }
-
-    if (isLiteral) {
-	maxNumCL = NUM_STATIC_POS;
-	clPosition = ckalloc(maxNumCL * sizeof(int));
-    }
 
     Tcl_DStringInit(&textBuffer);
     numObjsToConcat = 0;
     for ( ;  count > 0;  count--, tokenPtr++) {
 	switch (tokenPtr->type) {
 	case TCL_TOKEN_TEXT:
 	    TclDStringAppendToken(&textBuffer, tokenPtr);
-	    TclAdvanceLines(&envPtr->line, tokenPtr->start,
-		    tokenPtr->start + tokenPtr->size);
 	    break;
 
 	case TCL_TOKEN_BS:
 	    length = TclParseBackslash(tokenPtr->start, tokenPtr->size,
 		    NULL, buffer);
 	    Tcl_DStringAppend(&textBuffer, buffer, length);
 
-	    /*
-	     * If the backslash sequence we found is in a literal, and
-	     * represented a continuation line, we compute and store its
-	     * location (as char offset to the beginning of the _result_
-	     * script). We may have to extend the table of locations.
-	     *
-	     * Note that the continuation line information is relevant even if
-	     * the word we are processing is not a literal, as it can affect
-	     * nested commands. See the branch for TCL_TOKEN_COMMAND below,
-	     * where the adjustment we are tracking here is taken into
-	     * account. The good thing is that we do not need a table of
-	     * everything, just the number of lines we have to add as
-	     * correction.
-	     */
-
 	    if ((length == 1) && (buffer[0] == ' ') &&
 		(tokenPtr->start[1] == '\n')) {
-		if (isLiteral) {
-		    int clPos = Tcl_DStringLength(&textBuffer);
-
-		    if (numCL >= maxNumCL) {
-			maxNumCL *= 2;
-			clPosition = ckrealloc(clPosition,
-                                maxNumCL * sizeof(int));
-		    }
-		    clPosition[numCL] = clPos;
-		    numCL ++;
-		}
 	    }
 	    break;
 
 	case TCL_TOKEN_COMMAND:
 	    /*
@@ -2215,17 +1868,10 @@
 		int literal = TclRegisterDStringLiteral(envPtr, &textBuffer);
 
 		TclEmitPush(literal, envPtr);
 		numObjsToConcat++;
 		Tcl_DStringFree(&textBuffer);
-
-		if (numCL) {
-		    TclContinuationsEnter(
-			    envPtr->literalArrayPtr[literal].objPtr, numCL,
-			    clPosition);
-		}
-		numCL = 0;
 	    }
 
 	    TclCompileScript(interp, tokenPtr->start+1,
 		    tokenPtr->size-2, envPtr);
 	    numObjsToConcat++;
@@ -2264,15 +1910,10 @@
     if (Tcl_DStringLength(&textBuffer) > 0) {
 	int literal = TclRegisterDStringLiteral(envPtr, &textBuffer);
 
 	TclEmitPush(literal, envPtr);
 	numObjsToConcat++;
-	if (numCL) {
-	    TclContinuationsEnter(envPtr->literalArrayPtr[literal].objPtr,
-		    numCL, clPosition);
-	}
-	numCL = 0;
     }
 
     /*
      * If necessary, concatenate the parts of the word.
      */
@@ -2291,19 +1932,10 @@
 
     if (envPtr->codeNext == entryCodeNext) {
 	TclEmitPush(TclRegisterNewLiteral(envPtr, "", 0), envPtr);
     }
     Tcl_DStringFree(&textBuffer);
-
-    /*
-     * Release the temp table we used to collect the locations of continuation
-     * lines, if any.
-     */
-
-    if (maxNumCL) {
-	ckfree(clPosition);
-    }
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -2509,11 +2141,11 @@
 #ifdef TCL_COMPILE_DEBUG
     unsigned char *nextPtr;
 #endif
     int numLitObjects = envPtr->literalArrayNext;
     Namespace *namespacePtr;
-    int i, isNew;
+    int i;
     Interp *iPtr;
 
     iPtr = envPtr->iPtr;
 
     codeBytes = envPtr->codeNext - envPtr->codeStart;
@@ -2640,19 +2272,10 @@
 
     TclFreeIntRep(objPtr);
     objPtr->internalRep.otherValuePtr = codePtr;
     objPtr->typePtr = &tclByteCodeType;
 
-    /*
-     * TIP #280. Associate the extended per-word line information with the
-     * byte code object (internal rep), for use with the bc compiler.
-     */
-
-    Tcl_SetHashValue(Tcl_CreateHashEntry(iPtr->lineBCPtr, codePtr,
-	    &isNew), envPtr->extCmdMapPtr);
-    envPtr->extCmdMapPtr = NULL;
-
     codePtr->localCachePtr = NULL;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -2955,90 +2578,10 @@
 
     cmdLocPtr = &envPtr->cmdMapPtr[cmdIndex];
     cmdLocPtr->numSrcBytes = numSrcBytes;
     cmdLocPtr->numCodeBytes = numCodeBytes;
 }
-
-/*
- *----------------------------------------------------------------------
- * TIP #280
- *
- * EnterCmdWordData --
- *
- *	Registers the lines for the words of a command. This information is
- *	used at runtime by 'info frame'.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	Inserts word location information into the compilation environment
- *	envPtr for the command at index cmdIndex. The compilation
- *	environment's ExtCmdLoc.ECL array is grown if necessary.
- *
- *----------------------------------------------------------------------
- */
-
-static void
-EnterCmdWordData(
-    ExtCmdLoc *eclPtr,		/* Points to the map environment structure in
-				 * which to enter command location
-				 * information. */
-    int srcOffset,		/* Offset of first char of the command. */
-    Tcl_Token *tokenPtr,
-    const char *cmd,
-    int len,
-    int numWords,
-    int line,
-    int *clNext,
-    int **wlines,
-    CompileEnv *envPtr)
-{
-    ECL *ePtr;
-    const char *last;
-    int wordIdx, wordLine, *wwlines, *wordNext;
-
-    if (eclPtr->nuloc >= eclPtr->nloc) {
-	/*
-	 * Expand the ECL array by allocating more storage from the heap. The
-	 * currently allocated ECL entries are stored from eclPtr->loc[0] up
-	 * to eclPtr->loc[eclPtr->nuloc-1] (inclusive).
-	 */
-
-	size_t currElems = eclPtr->nloc;
-	size_t newElems = (currElems ? 2*currElems : 1);
-	size_t newBytes = newElems * sizeof(ECL);
-
-	eclPtr->loc = ckrealloc(eclPtr->loc, newBytes);
-	eclPtr->nloc = newElems;
-    }
-
-    ePtr = &eclPtr->loc[eclPtr->nuloc];
-    ePtr->srcOffset = srcOffset;
-    ePtr->line = ckalloc(numWords * sizeof(int));
-    ePtr->next = ckalloc(numWords * sizeof(int *));
-    ePtr->nline = numWords;
-    wwlines = ckalloc(numWords * sizeof(int));
-
-    last = cmd;
-    wordLine = line;
-    wordNext = clNext;
-    for (wordIdx=0 ; wordIdx<numWords;
-	    wordIdx++, tokenPtr += tokenPtr->numComponents + 1) {
-	TclAdvanceLines(&wordLine, last, tokenPtr->start);
-	TclAdvanceContinuations(&wordLine, &wordNext,
-		tokenPtr->start - envPtr->source);
-	wwlines[wordIdx] =
-		(TclWordKnownAtCompileTime(tokenPtr, NULL) ? wordLine : -1);
-	ePtr->line[wordIdx] = wordLine;
-	ePtr->next[wordIdx] = wordNext;
-	last = tokenPtr->start;
-    }
-
-    *wlines = wwlines;
-    eclPtr->nuloc ++;
-}
 
 /*
  *----------------------------------------------------------------------
  *
  * TclCreateExceptRange --
@@ -3466,74 +3009,10 @@
 	default:
 	    Tcl_Panic("TclFixupForwardJump: bad ExceptionRange type %d",
 		    rangePtr->type);
 	}
     }
-
-    /*
-     * TIP #280: Adjust the mapping from PC values to the per-command
-     * information about arguments and their line numbers.
-     *
-     * Note: We cannot simply remove an out-of-date entry and then reinsert
-     * with the proper PC, because then we might overwrite another entry which
-     * was at that location. Therefore we pull (copy + delete) all effected
-     * entries (beyond the fixed PC) into an array, update them there, and at
-     * last reinsert them all.
-     */
-
-    {
-	ExtCmdLoc* eclPtr = envPtr->extCmdMapPtr;
-
-	/* A helper structure */
-
-	typedef struct {
-	    int pc;
-	    int cmd;
-	} MAP;
-
-	/*
-	 * And the helper array. At most the whole hashtable is placed into
-	 * this.
-	 */
-
-	MAP *map = (MAP*) ckalloc (sizeof(MAP) * eclPtr->litInfo.numEntries);
-
-	Tcl_HashSearch hSearch;
-	Tcl_HashEntry* hPtr;
-	int n, k, isnew;
-
-	/*
-	 * Phase I: Locate the affected entries, and save them in adjusted
-	 * form to the array. This removes them from the hash.
-	 */
-
-	for (n = 0, hPtr = Tcl_FirstHashEntry(&eclPtr->litInfo, &hSearch);
-	     hPtr != NULL;
-	     hPtr = Tcl_NextHashEntry(&hSearch)) {
-
-	    map [n].cmd = PTR2INT(Tcl_GetHashValue(hPtr));
-	    map [n].pc  = PTR2INT(Tcl_GetHashKey (&eclPtr->litInfo,hPtr));
-
-	    if (map[n].pc >= (jumpFixupPtr->codeOffset + 2)) {
-		Tcl_DeleteHashEntry(hPtr);
-		map [n].pc += 3;
-		n++;
-	    }
-	}
-
-	/*
-	 * Phase II: Re-insert the modified entries into the hash.
-	 */
-
-	for (k=0;k<n;k++) {
-	    hPtr = Tcl_CreateHashEntry(&eclPtr->litInfo, INT2PTR(map[k].pc), &isnew);
-	    Tcl_SetHashValue(hPtr, INT2PTR(map[k].cmd));
-	}
-
-	ckfree (map);
-    }
-
     return 1;			/* the jump was grown */
 }
 
 /*
  *----------------------------------------------------------------------

Index: generic/tclCompile.h
==================================================================
--- generic/tclCompile.h
+++ generic/tclCompile.h
@@ -112,50 +112,10 @@
     int numCodeBytes;		/* Number of bytes for command's code. */
     int srcOffset;		/* Offset of first char of the command. */
     int numSrcBytes;		/* Number of command source chars. */
 } CmdLocation;
 
-/*
- * TIP #280
- * Structure to record additional location information for byte code. This
- * information is internal and not saved. i.e. tbcload'ed code will not have
- * this information. It records the lines for all words of all commands found
- * in the byte code. The association with a ByteCode structure BC is done
- * through the 'lineBCPtr' HashTable in Interp, keyed by the address of BC.
- * Also recorded is information coming from the context, i.e. type of the
- * frame and associated information, like the path of a sourced file.
- */
-
-typedef struct ECL {
-    int srcOffset;		/* Command location to find the entry. */
-    int nline;			/* Number of words in the command */
-    int *line;			/* Line information for all words in the
-				 * command. */
-    int **next;			/* Transient information used by the compiler
-				 * for tracking of hidden continuation
-				 * lines. */
-} ECL;
-
-typedef struct ExtCmdLoc {
-    int type;			/* Context type. */
-    int start;			/* Starting line for compiled script. Needed
-				 * for the extended recompile check in
-				 * tclCompileObj. */
-    Tcl_Obj *path;		/* Path of the sourced file the command is
-				 * in. */
-    ECL *loc;			/* Command word locations (lines). */
-    int nloc;			/* Number of allocated entries in 'loc'. */
-    int nuloc;			/* Number of used entries in 'loc'. */
-    Tcl_HashTable litInfo;	/* Indexed by bytecode 'PC', to have the
-				 * information accessible per command and
-				 * argument, not per whole bytecode. Value is
-				 * index of command in 'loc', giving us the
-				 * literals to associate with line information
-				 * as command argument, see
-				 * TclArgumentBCEnter() */
-} ExtCmdLoc;
-
 /*
  * CompileProcs need the ability to record information during compilation that
  * can be used by bytecode instructions during execution. The AuxData
  * structure provides this "auxiliary data" mechanism. An arbitrary number of
  * these structures can be stored in the ByteCode record (during compilation
@@ -298,27 +258,14 @@
 				/* Initial ExceptionRange array storage. */
     CmdLocation staticCmdMapSpace[COMPILEENV_INIT_CMD_MAP_SIZE];
 				/* Initial storage for cmd location map. */
     AuxData staticAuxDataArraySpace[COMPILEENV_INIT_AUX_DATA_SIZE];
 				/* Initial storage for aux data array. */
-    /* TIP #280 */
-    ExtCmdLoc *extCmdMapPtr;	/* Extended command location information for
-				 * 'info frame'. */
-    int line;			/* First line of the script, based on the
-				 * invoking context, then the line of the
-				 * command currently compiled. */
     int atCmdStart;		/* Flag to say whether an INST_START_CMD
 				 * should be issued; they should never be
 				 * issued repeatedly, as that is significantly
 				 * inefficient. */
-    ContLineLoc *clLoc;		/* If not NULL, the table holding the
-				 * locations of the invisible continuation
-				 * lines in the input script, to adjust the
-				 * line counter. */
-    int *clNext;		/* If not NULL, it refers to the next slot in
-				 * clLoc to check for an invisible
-				 * continuation line. */
 } CompileEnv;
 
 /*
  * The structure defining the bytecode instructions resulting from compiling a
  * Tcl script. Note that this structure is variable length: a single heap
@@ -904,12 +851,11 @@
  *----------------------------------------------------------------
  * Procedures exported by the engine to be used by tclBasic.c
  *----------------------------------------------------------------
  */
 
-MODULE_SCOPE ByteCode *	TclCompileObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
-			    const CmdFrame *invoker, int word);
+MODULE_SCOPE ByteCode *	TclCompileObj(Tcl_Interp *interp, Tcl_Obj *objPtr);
 
 /*
  *----------------------------------------------------------------
  * Procedures shared among Tcl bytecode compilation and execution modules but
  * not used outside:
@@ -968,11 +914,11 @@
 MODULE_SCOPE void	TclInitByteCodeObj(Tcl_Obj *objPtr,
 			    CompileEnv *envPtr);
 MODULE_SCOPE void	TclInitCompilation(void);
 MODULE_SCOPE void	TclInitCompileEnv(Tcl_Interp *interp,
 			    CompileEnv *envPtr, const char *string,
-			    int numBytes, const CmdFrame *invoker, int word);
+			    int numBytes);
 MODULE_SCOPE void	TclInitJumpFixupArray(JumpFixupArray *fixupArrayPtr);
 MODULE_SCOPE void	TclInitLiteralTable(LiteralTable *tablePtr);
 #ifdef TCL_COMPILE_STATS
 MODULE_SCOPE char *	TclLiteralStats(LiteralTable *tablePtr);
 MODULE_SCOPE int	TclLog2(int value);

Index: generic/tclDictObj.c
==================================================================
--- generic/tclDictObj.c
+++ generic/tclDictObj.c
@@ -2375,11 +2375,10 @@
     ClientData dummy,
     Tcl_Interp *interp,
     int objc,
     Tcl_Obj *const *objv)
 {
-    Interp *iPtr = (Interp *) interp;
     Tcl_Obj *scriptObj, *keyVarObj, *valueVarObj;
     Tcl_Obj **varv, *keyObj, *valueObj;
     Tcl_DictSearch *searchPtr;
     int varc, done;
 
@@ -2399,18 +2398,18 @@
     if (varc != 2) {
 	Tcl_SetObjResult(interp, Tcl_NewStringObj(
 		"must have exactly two variable names", -1));
 	return TCL_ERROR;
     }
-    searchPtr = TclStackAlloc(interp, sizeof(Tcl_DictSearch));
+    searchPtr = ckalloc(sizeof(Tcl_DictSearch));
     if (Tcl_DictObjFirst(interp, objv[2], searchPtr, &keyObj, &valueObj,
 	    &done) != TCL_OK) {
-	TclStackFree(interp, searchPtr);
+	ckfree(searchPtr);
 	return TCL_ERROR;
     }
     if (done) {
-	TclStackFree(interp, searchPtr);
+	ckfree(searchPtr);
 	return TCL_OK;
     }
     TclListObjGetElements(NULL, objv[1], &varc, &varv);
     keyVarObj = varv[0];
     valueVarObj = varv[1];
@@ -2445,11 +2444,11 @@
      * Run the script.
      */
 
     TclNRAddCallback(interp, DictForLoopCallback, searchPtr, keyVarObj,
 	    valueVarObj, scriptObj);
-    return TclNREvalObjEx(interp, scriptObj, 0, iPtr->cmdFramePtr, 3);
+    return TclNREvalObjEx(interp, scriptObj, 0);
 
     /*
      * For unwinding everything on error.
      */
 
@@ -2456,21 +2455,20 @@
   error:
     TclDecrRefCount(keyVarObj);
     TclDecrRefCount(valueVarObj);
     TclDecrRefCount(scriptObj);
     Tcl_DictObjDone(searchPtr);
-    TclStackFree(interp, searchPtr);
+    ckfree(searchPtr);
     return TCL_ERROR;
 }
 
 static int
 DictForLoopCallback(
     ClientData data[],
     Tcl_Interp *interp,
     int result)
 {
-    Interp *iPtr = (Interp *) interp;
     Tcl_DictSearch *searchPtr = data[0];
     Tcl_Obj *keyVarObj = data[1];
     Tcl_Obj *valueVarObj = data[2];
     Tcl_Obj *scriptObj = data[3];
     Tcl_Obj *keyObj, *valueObj;
@@ -2527,11 +2525,11 @@
      * Run the script.
      */
 
     TclNRAddCallback(interp, DictForLoopCallback, searchPtr, keyVarObj,
 	    valueVarObj, scriptObj);
-    return TclNREvalObjEx(interp, scriptObj, 0, iPtr->cmdFramePtr, 3);
+    return TclNREvalObjEx(interp, scriptObj, 0);
 
     /*
      * For unwinding everything once the iterating is done.
      */
 
@@ -2538,11 +2536,11 @@
   done:
     TclDecrRefCount(keyVarObj);
     TclDecrRefCount(valueVarObj);
     TclDecrRefCount(scriptObj);
     Tcl_DictObjDone(searchPtr);
-    TclStackFree(interp, searchPtr);
+    ckfree(searchPtr);
     return result;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -2567,11 +2565,10 @@
     ClientData dummy,
     Tcl_Interp *interp,
     int objc,
     Tcl_Obj *const *objv)
 {
-    Interp *iPtr = (Interp *) interp;
     Tcl_Obj **varv, *keyObj, *valueObj;
     DictMapStorage *storagePtr;
     int varc, done;
 
     if (objc != 4) {
@@ -2590,24 +2587,24 @@
     if (varc != 2) {
 	Tcl_SetObjResult(interp, Tcl_NewStringObj(
 		"must have exactly two variable names", -1));
 	return TCL_ERROR;
     }
-    storagePtr = TclStackAlloc(interp, sizeof(DictMapStorage));
+    storagePtr = ckalloc(sizeof(DictMapStorage));
     if (Tcl_DictObjFirst(interp, objv[2], &storagePtr->search, &keyObj,
 	    &valueObj, &done) != TCL_OK) {
-	TclStackFree(interp, storagePtr);
+	ckfree(storagePtr);
 	return TCL_ERROR;
     }
     if (done) {
 	/*
 	 * Note that this exit leaves an empty value in the result (due to
 	 * command calling conventions) but that is OK since an empty value is
 	 * an empty dictionary.
 	 */
 
-	TclStackFree(interp, storagePtr);
+	ckfree(storagePtr);
 	return TCL_OK;
     }
     TclNewObj(storagePtr->accumulatorObj);
     TclListObjGetElements(NULL, objv[1], &varc, &varv);
     storagePtr->keyVarObj = varv[0];
@@ -2646,12 +2643,11 @@
     /*
      * Run the script.
      */
 
     TclNRAddCallback(interp, DictMapLoopCallback, storagePtr, NULL,NULL,NULL);
-    return TclNREvalObjEx(interp, storagePtr->scriptObj, 0,
-	    iPtr->cmdFramePtr, 3);
+    return TclNREvalObjEx(interp, storagePtr->scriptObj, 0);
 
     /*
      * For unwinding everything on error.
      */
 
@@ -2659,21 +2655,20 @@
     TclDecrRefCount(storagePtr->keyVarObj);
     TclDecrRefCount(storagePtr->valueVarObj);
     TclDecrRefCount(storagePtr->scriptObj);
     TclDecrRefCount(storagePtr->accumulatorObj);
     Tcl_DictObjDone(&storagePtr->search);
-    TclStackFree(interp, storagePtr);
+    ckfree(storagePtr);
     return TCL_ERROR;
 }
 
 static int
 DictMapLoopCallback(
     ClientData data[],
     Tcl_Interp *interp,
     int result)
 {
-    Interp *iPtr = (Interp *) interp;
     DictMapStorage *storagePtr = data[0];
     Tcl_Obj *keyObj, *valueObj;
     int done;
 
     /*
@@ -2736,12 +2731,11 @@
     /*
      * Run the script.
      */
 
     TclNRAddCallback(interp, DictMapLoopCallback, storagePtr, NULL,NULL,NULL);
-    return TclNREvalObjEx(interp, storagePtr->scriptObj, 0,
-	    iPtr->cmdFramePtr, 3);
+    return TclNREvalObjEx(interp, storagePtr->scriptObj, 0);
 
     /*
      * For unwinding everything once the iterating is done.
      */
 
@@ -2749,11 +2743,11 @@
     TclDecrRefCount(storagePtr->keyVarObj);
     TclDecrRefCount(storagePtr->valueVarObj);
     TclDecrRefCount(storagePtr->scriptObj);
     TclDecrRefCount(storagePtr->accumulatorObj);
     Tcl_DictObjDone(&storagePtr->search);
-    TclStackFree(interp, storagePtr);
+    ckfree(storagePtr);
     return result;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -2897,11 +2891,10 @@
     ClientData dummy,
     Tcl_Interp *interp,
     int objc,
     Tcl_Obj *const *objv)
 {
-    Interp *iPtr = (Interp *) interp;
     static const char *const filters[] = {
 	"key", "script", "value", NULL
     };
     enum FilterTypes {
 	FILTER_KEYS, FILTER_SCRIPT, FILTER_VALUES
@@ -3081,15 +3074,11 @@
 			TclGetString(valueVarObj)));
 		result = TCL_ERROR;
 		goto abnormalResult;
 	    }
 
-	    /*
-	     * TIP #280. Make invoking context available to loop body.
-	     */
-
-	    result = TclEvalObjEx(interp, scriptObj, 0, iPtr->cmdFramePtr, 4);
+	    result = Tcl_EvalObjEx(interp, scriptObj, 0);
 	    switch (result) {
 	    case TCL_OK:
 		boolObj = Tcl_GetObjResult(interp);
 		Tcl_IncrRefCount(boolObj);
 		Tcl_ResetResult(interp);
@@ -3184,11 +3173,10 @@
     ClientData clientData,
     Tcl_Interp *interp,
     int objc,
     Tcl_Obj *const *objv)
 {
-    Interp *iPtr = (Interp *) interp;
     Tcl_Obj *dictPtr, *objPtr;
     int i, dummy;
 
     if (objc < 5 || !(objc & 1)) {
 	Tcl_WrongNumArgs(interp, 1, objv,
@@ -3228,11 +3216,11 @@
     objPtr = Tcl_NewListObj(objc-3, objv+2);
     Tcl_IncrRefCount(objPtr);
     Tcl_IncrRefCount(objv[1]);
     TclNRAddCallback(interp, FinalizeDictUpdate, objv[1], objPtr, NULL,NULL);
 
-    return TclNREvalObjEx(interp, objv[objc-1], 0, iPtr->cmdFramePtr, objc-1);
+    return TclNREvalObjEx(interp, objv[objc-1], 0);
 }
 
 static int
 FinalizeDictUpdate(
     ClientData data[],
@@ -3343,11 +3331,10 @@
     ClientData dummy,
     Tcl_Interp *interp,
     int objc,
     Tcl_Obj *const *objv)
 {
-    Interp *iPtr = (Interp *) interp;
     Tcl_Obj *dictPtr, *keysPtr, *pathPtr;
 
     if (objc < 3) {
 	Tcl_WrongNumArgs(interp, 1, objv, "dictVar ?key ...? script");
 	return TCL_ERROR;
@@ -3367,12 +3354,11 @@
 	return TCL_ERROR;
     }
     Tcl_IncrRefCount(keysPtr);
 
     /*
-     * Execute the body, while making the invoking context available to the
-     * loop body (TIP#280) and postponing the cleanup until later (NRE).
+     * Execute the body, while postponing the cleanup until later (NRE).
      */
 
     pathPtr = NULL;
     if (objc > 3) {
 	pathPtr = Tcl_NewListObj(objc-3, objv+2);
@@ -3380,11 +3366,11 @@
     }
     Tcl_IncrRefCount(objv[1]);
     TclNRAddCallback(interp, FinalizeDictWith, objv[1], keysPtr, pathPtr,
 	    NULL);
 
-    return TclNREvalObjEx(interp, objv[objc-1], 0, iPtr->cmdFramePtr, objc-1);
+    return TclNREvalObjEx(interp, objv[objc-1], 0);
 }
 
 static int
 FinalizeDictWith(
     ClientData data[],

Index: generic/tclEnsemble.c
==================================================================
--- generic/tclEnsemble.c
+++ generic/tclEnsemble.c
@@ -86,20 +86,10 @@
     DupEnsembleCmdRep,		/* dupIntRepProc */
     StringOfEnsembleCmdRep,	/* updateStringProc */
     NULL			/* setFromAnyProc */
 };
 
-/*
- * Copied from tclCompCmds.c
- */
-
-#define DefineLineInformation \
-    ExtCmdLoc *mapPtr = envPtr->extCmdMapPtr;				\
-    int eclIndex = mapPtr->nuloc - 1
-#define SetLineInformation(word) \
-    envPtr->line = mapPtr->loc[eclIndex].line[(word)];			\
-    envPtr->clNext = mapPtr->loc[eclIndex].next[(word)]
 
 static inline Tcl_Obj *
 NewNsObj(
     Tcl_Namespace *namespacePtr)
 {
@@ -1913,11 +1903,11 @@
 	/*
 	 * Hand off to the target command.
 	 */
 
 	iPtr->evalFlags |= TCL_EVAL_REDIRECT;
-	return TclNREvalObjEx(interp, copyPtr, TCL_EVAL_INVOKE, NULL,INT_MIN);
+	return TclNREvalObjEx(interp, copyPtr, TCL_EVAL_INVOKE);
     }
 
   unknownOrAmbiguousSubcommand:
     /*
      * Have not been able to match the subcommand asked for with a real
@@ -3132,16 +3122,13 @@
 {
     Tcl_Token *tokPtr;
     Tcl_Obj *objPtr, **words;
     char *bytes;
     int length, i, numWords, cmdLit;
-    DefineLineInformation;
 
     /*
-     * Push the words of the command. Take care; the command words may be
-     * scripts that have backslashes in them, and [info frame 0] can see the
-     * difference. Hence the call to TclContinuationsEnterDerived...
+     * Push the words of the command.
      */
 
     Tcl_ListObjGetElements(NULL, replacements, &numWords, &words);
     for (i=0,tokPtr=parsePtr->tokenPtr ; i<parsePtr->numWords ; i++) {
 	if (i > 0 && i < numWords+1) {
@@ -3149,21 +3136,12 @@
 	    PushLiteral(envPtr, bytes, length);
 	} else if (tokPtr->type == TCL_TOKEN_SIMPLE_WORD) {
 	    int literal = TclRegisterNewLiteral(envPtr,
 		    tokPtr[1].start, tokPtr[1].size);
 
-	    if (envPtr->clNext) {
-		TclContinuationsEnterDerived(
-			envPtr->literalArrayPtr[literal].objPtr,
-			tokPtr[1].start - envPtr->source,
-			mapPtr->loc[eclIndex].next[i]);
-	    }
 	    TclEmitPush(literal, envPtr);
 	} else {
-	    if (envPtr->clNext) {
-		SetLineInformation(i);
-	    }
 	    CompileTokens(envPtr, tokPtr, interp);
 	}
 	tokPtr = TokenAfter(tokPtr);
     }
 
@@ -3212,11 +3190,10 @@
 {
     Tcl_Token *tokenPtr;
     Tcl_Obj *objPtr;
     char *bytes;
     int length, i, literal;
-    DefineLineInformation;
 
     /*
      * Push the name of the command we're actually dispatching to as part of
      * the implementation.
      */
@@ -3233,13 +3210,10 @@
      * Push the words of the command.
      */
 
     tokenPtr = TokenAfter(parsePtr->tokenPtr);
     for (i=1 ; i<parsePtr->numWords ; i++) {
-	if (envPtr->clNext) {
-	    SetLineInformation(i);
-	}
 	if (tokenPtr->type == TCL_TOKEN_SIMPLE_WORD) {
 	    PushLiteral(envPtr, tokenPtr[1].start, tokenPtr[1].size);
 	} else {
 	    CompileTokens(envPtr, tokenPtr, interp);
 	}

Index: generic/tclEvent.c
==================================================================
--- generic/tclEvent.c
+++ generic/tclEvent.c
@@ -1041,15 +1041,13 @@
 	     * Initialize locks used by the memory allocators before anything
 	     * interesting happens so we can use the allocators in the
 	     * implementation of self-initializing locks.
 	     */
 
+	    TclInitAlloc();		/* Process wide allocator init */
 	    TclInitThreadStorage();     /* Creates master hash table for
 					 * thread local storage */
-#if USE_TCLALLOC
-	    TclInitAlloc();		/* Process wide mutex init */
-#endif
 #ifdef TCL_MEM_DEBUG
 	    TclInitDbCkalloc();		/* Process wide mutex init */
 #endif
 
 	    TclpInitPlatform();		/* Creates signal handler(s) */
@@ -1218,18 +1216,10 @@
      * alive at this moment.
      */
 
     TclFinalizeSynchronization();
 
-    /*
-     * Close down the thread-specific object allocator.
-     */
-
-#if defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
-    TclFinalizeThreadAlloc();
-#endif
-
     /*
      * We defer unloading of packages until very late to avoid memory access
      * issues. Both exit callbacks and synchronization variables may be stored
      * in packages.
      *
@@ -1249,10 +1239,18 @@
     /*
      * At this point, there should no longer be any ckalloc'ed memory.
      */
 
     TclFinalizeMemorySubsystem();
+
+    /*
+     * Close down the thread-specific object allocator.
+     */
+
+    TclFinalizeAlloc();
+
+
 
   alreadyFinalized:
     TclFinalizeLock();
 }
 

Index: generic/tclExecute.c
==================================================================
--- generic/tclExecute.c
+++ generic/tclExecute.c
@@ -172,34 +172,35 @@
  */
 
 typedef struct TEBCdata {
     ByteCode *codePtr;		/* Constant until the BC returns */
 				/* -----------------------------------------*/
+    Tcl_Obj **tosPtr;
     const unsigned char *pc;	/* These fields are used on return TO this */
-    ptrdiff_t *catchTop;	/* this level: they record the state when a */
+    unsigned long catchDepth;	        /* this level: they record the state when a */
     int cleanup;		/* new codePtr was received for NR */
     Tcl_Obj *auxObjList;	/* execution. */
     int checkInterp;
-    CmdFrame cmdFrame;
+    unsigned int capacity;
     void *stack[1];		/* Start of the actual combined catch and obj
 				 * stacks; the struct will be expanded as
 				 * necessary */
 } TEBCdata;
 
 #define TEBC_YIELD() \
     do {								\
-	esPtr->tosPtr = tosPtr;						\
+	TD->tosPtr = tosPtr;						\
 	TD->pc = pc;							\
 	TD->cleanup = cleanup;						\
 	TclNRAddCallback(interp, TEBCresume, TD, INT2PTR(1), NULL, NULL); \
     } while (0)
 
 #define TEBC_DATA_DIG() \
     do {					\
 	pc = TD->pc;				\
 	cleanup = TD->cleanup;			\
-	tosPtr = esPtr->tosPtr;			\
+	tosPtr = TD->tosPtr;			\
     } while (0)
 
 #define PUSH_TAUX_OBJ(objPtr) \
     do {							\
 	objPtr->internalRep.ptrAndLongRep.ptr = auxObjList;	\
@@ -309,24 +310,10 @@
 	} else {						\
 	    goto cleanupV;					\
 	}							\
     } while (0)
 
-/*
- * Macros used to cache often-referenced Tcl evaluation stack information
- * in local variables. Note that a DECACHE_STACK_INFO()-CACHE_STACK_INFO()
- * pair must surround any call inside TclNRExecuteByteCode (and a few other
- * procedures that use this scheme) that could result in a recursive call
- * to TclNRExecuteByteCode.
- */
-
-#define CACHE_STACK_INFO() \
-    checkInterp = 1
-
-#define DECACHE_STACK_INFO() \
-    esPtr->tosPtr = tosPtr
-
 /*
  * Macros used to access items on the Tcl evaluation stack. PUSH_OBJECT
  * increments the object's ref count since it makes the stack have another
  * reference pointing to the object. However, POP_OBJECT does not decrement
  * the ref count. This is because the stack may hold the only reference to the
@@ -697,11 +684,10 @@
 static void		ValidatePcAndStackTop(ByteCode *codePtr,
 			    const unsigned char *pc, int stackTop,
 			    int stackLowerBound, int checkStack);
 #endif /* TCL_COMPILE_DEBUG */
 static ByteCode *	CompileExprObj(Tcl_Interp *interp, Tcl_Obj *objPtr);
-static void		DeleteExecStack(ExecStack *esPtr);
 static void		DupExprCodeInternalRep(Tcl_Obj *srcPtr,
 			    Tcl_Obj *copyPtr);
 MODULE_SCOPE int	TclCompareTwoNumbers(Tcl_Obj *valuePtr,
 			    Tcl_Obj *value2Ptr);
 static Tcl_Obj *	ExecuteExtendedBinaryMathOp(Tcl_Interp *interp,
@@ -713,20 +699,14 @@
 static ExceptionRange *	GetExceptRangeForPc(const unsigned char *pc,
 			    int catchOnly, ByteCode *codePtr);
 static const char *	GetSrcInfoForPc(const unsigned char *pc,
 			    ByteCode *codePtr, int *lengthPtr,
 			    const unsigned char **pcBeg);
-static Tcl_Obj **	GrowEvaluationStack(ExecEnv *eePtr, int growth,
-			    int move);
 static void		IllegalExprOperandType(Tcl_Interp *interp,
 			    const unsigned char *pc, Tcl_Obj *opndPtr);
 static void		InitByteCodeExecution(Tcl_Interp *interp);
-static inline int	OFFSET(void *ptr);
 static void		ReleaseDictIterator(Tcl_Obj *objPtr);
-/* Useful elsewhere, make available in tclInt.h or stubs? */
-static Tcl_Obj **	StackAllocWords(Tcl_Interp *interp, int numWords);
-static Tcl_Obj **	StackReallocWords(Tcl_Interp *interp, int numWords);
 static Tcl_NRPostProc	CopyCallback;
 static Tcl_NRPostProc	ExprObjCallback;
 
 static Tcl_NRPostProc   TEBCresume;
 
@@ -790,10 +770,39 @@
     dictPtr = objPtr->internalRep.twoPtrValue.ptr2;
     TclDecrRefCount(dictPtr);
 
     objPtr->typePtr = NULL;
 }
+
+static void UpdateStringOfBcSource(Tcl_Obj *objPtr);
+
+static const Tcl_ObjType bcSourceType = {
+    "bcSource",			/* name */
+    NULL,			/* freeIntRepProc */
+    NULL,			/* dupIntRepProc */
+    UpdateStringOfBcSource,	/* updateStringProc */
+    NULL			/* setFromAnyProc */
+};
+
+static void
+UpdateStringOfBcSource(
+    Tcl_Obj *objPtr)
+{
+    int len;
+    const char *bytes;
+    unsigned char *pc = objPtr->internalRep.twoPtrValue.ptr1;
+    ByteCode *codePtr = objPtr->internalRep.twoPtrValue.ptr2;
+
+    bytes = GetSrcInfoForPc(pc, codePtr, &len, NULL);
+    objPtr->bytes = (char *) ckalloc((unsigned) len + 1);
+    memcpy(objPtr->bytes, bytes, len);
+    objPtr->bytes[len] = '\0';
+    objPtr->length = len;
+}
+
+
+
 
 /*
  *----------------------------------------------------------------------
  *
  * InitByteCodeExecution --
@@ -859,29 +868,20 @@
 				 * environment is being created. */
     int size)			/* The initial stack size, in number of words
 				 * [sizeof(Tcl_Obj*)] */
 {
     ExecEnv *eePtr = ckalloc(sizeof(ExecEnv));
-    ExecStack *esPtr = ckalloc(sizeof(ExecStack)
-	    + (size_t) (size-1) * sizeof(Tcl_Obj *));
 
-    eePtr->execStackPtr = esPtr;
     TclNewBooleanObj(eePtr->constants[0], 0);
     Tcl_IncrRefCount(eePtr->constants[0]);
     TclNewBooleanObj(eePtr->constants[1], 1);
     Tcl_IncrRefCount(eePtr->constants[1]);
     eePtr->interp = interp;
     eePtr->callbackPtr = NULL;
     eePtr->corPtr = NULL;
     eePtr->rewind = 0;
 
-    esPtr->prevPtr = NULL;
-    esPtr->nextPtr = NULL;
-    esPtr->markerPtr = NULL;
-    esPtr->endPtr = &esPtr->stackWords[size-1];
-    esPtr->tosPtr = &esPtr->stackWords[-1];
-
     Tcl_MutexLock(&execMutex);
     if (!execInitialized) {
 	TclInitAuxDataTypeTable();
 	InitByteCodeExecution(interp);
 	execInitialized = 1;
@@ -906,48 +906,20 @@
  *	stack) is freed.
  *
  *----------------------------------------------------------------------
  */
 
-static void
-DeleteExecStack(
-    ExecStack *esPtr)
-{
-    if (esPtr->markerPtr && !cachedInExit) {
-	Tcl_Panic("freeing an execStack which is still in use");
-    }
-
-    if (esPtr->prevPtr) {
-	esPtr->prevPtr->nextPtr = esPtr->nextPtr;
-    }
-    if (esPtr->nextPtr) {
-	esPtr->nextPtr->prevPtr = esPtr->prevPtr;
-    }
-    ckfree(esPtr);
-}
-
 void
 TclDeleteExecEnv(
     ExecEnv *eePtr)		/* Execution environment to free. */
 {
-    ExecStack *esPtr = eePtr->execStackPtr, *tmpPtr;
-
 	cachedInExit = TclInExit();
 
     /*
      * Delete all stacks in this exec env.
      */
 
-    while (esPtr->nextPtr) {
-	esPtr = esPtr->nextPtr;
-    }
-    while (esPtr) {
-	tmpPtr = esPtr;
-	esPtr = tmpPtr->prevPtr;
-	DeleteExecStack(tmpPtr);
-    }
-
     TclDecrRefCount(eePtr->constants[0]);
     TclDecrRefCount(eePtr->constants[1]);
     if (eePtr->callbackPtr && !cachedInExit) {
 	Tcl_Panic("Deleting execEnv with pending TEOV callbacks!");
     }
@@ -981,355 +953,10 @@
     Tcl_MutexLock(&execMutex);
     execInitialized = 0;
     Tcl_MutexUnlock(&execMutex);
     TclFinalizeAuxDataTypeTable();
 }
-
-/*
- * Auxiliary code to insure that GrowEvaluationStack always returns correctly
- * aligned memory.
- *
- * WALLOCALIGN represents the alignment reqs in words, just as TCL_ALLOCALIGN
- * represents the reqs in bytes. This assumes that TCL_ALLOCALIGN is a
- * multiple of the wordsize 'sizeof(Tcl_Obj *)'.
- */
-
-#define WALLOCALIGN \
-    (TCL_ALLOCALIGN/sizeof(Tcl_Obj *))
-
-/*
- * OFFSET computes how many words have to be skipped until the next aligned
- * word. Note that we are only interested in the low order bits of ptr, so
- * that any possible information loss in PTR2INT is of no consequence.
- */
-
-static inline int
-OFFSET(
-    void *ptr)
-{
-    int mask = TCL_ALLOCALIGN-1;
-    int base = PTR2INT(ptr) & mask;
-    return (TCL_ALLOCALIGN - base)/sizeof(Tcl_Obj *);
-}
-
-/*
- * Given a marker, compute where the following aligned memory starts.
- */
-
-#define MEMSTART(markerPtr) \
-    ((markerPtr) + OFFSET(markerPtr))
-
-/*
- *----------------------------------------------------------------------
- *
- * GrowEvaluationStack --
- *
- *	This procedure grows a Tcl evaluation stack stored in an ExecEnv,
- *	copying over the words since the last mark if so requested. A mark is
- *	set at the beginning of the new area when no copying is requested.
- *
- * Results:
- *	Returns a pointer to the first usable word in the (possibly) grown
- *	stack.
- *
- * Side effects:
- *	The size of the evaluation stack may be grown, a marker is set
- *
- *----------------------------------------------------------------------
- */
-
-static Tcl_Obj **
-GrowEvaluationStack(
-    ExecEnv *eePtr,		/* Points to the ExecEnv with an evaluation
-				 * stack to enlarge. */
-    int growth,			/* How much larger than the current used
-				 * size. */
-    int move)			/* 1 if move words since last marker. */
-{
-    ExecStack *esPtr = eePtr->execStackPtr, *oldPtr = NULL;
-    int newBytes, newElems, currElems;
-    int needed = growth - (esPtr->endPtr - esPtr->tosPtr);
-    Tcl_Obj **markerPtr = esPtr->markerPtr, **memStart;
-    int moveWords = 0;
-
-    if (move) {
-	if (!markerPtr) {
-	    Tcl_Panic("STACK: Reallocating with no previous alloc");
-	}
-	if (needed <= 0) {
-	    return MEMSTART(markerPtr);
-	}
-    } else {
-#ifndef PURIFY
-	Tcl_Obj **tmpMarkerPtr = esPtr->tosPtr + 1;
-	int offset = OFFSET(tmpMarkerPtr);
-
-	if (needed + offset < 0) {
-	    /*
-	     * Put a marker pointing to the previous marker in this stack, and
-	     * store it in esPtr as the current marker. Return a pointer to
-	     * the start of aligned memory.
-	     */
-
-	    esPtr->markerPtr = tmpMarkerPtr;
-	    memStart = tmpMarkerPtr + offset;
-	    esPtr->tosPtr = memStart - 1;
-	    *esPtr->markerPtr = (Tcl_Obj *) markerPtr;
-	    return memStart;
-	}
-#endif
-    }
-
-    /*
-     * Reset move to hold the number of words to be moved to new stack (if
-     * any) and growth to hold the complete stack requirements: add one for
-     * the marker, (WALLOCALIGN-1) for the maximal possible offset.
-     */
-
-    if (move) {
-	moveWords = esPtr->tosPtr - MEMSTART(markerPtr) + 1;
-    }
-    needed = growth + moveWords + WALLOCALIGN - 1;
-
-    
-    /*
-     * Check if there is enough room in the next stack (if there is one, it
-     * should be both empty and the last one!)
-     */
-
-    if (esPtr->nextPtr) {
-	oldPtr = esPtr;
-	esPtr = oldPtr->nextPtr;
-	currElems = esPtr->endPtr - &esPtr->stackWords[-1];
-	if (esPtr->markerPtr || (esPtr->tosPtr != &esPtr->stackWords[-1])) {
-	    Tcl_Panic("STACK: Stack after current is in use");
-	}
-	if (esPtr->nextPtr) {
-	    Tcl_Panic("STACK: Stack after current is not last");
-	}
-	if (needed <= currElems) {
-	    goto newStackReady;
-	}
-	DeleteExecStack(esPtr);
-	esPtr = oldPtr;
-    } else {
-	currElems = esPtr->endPtr - &esPtr->stackWords[-1];
-    }
-
-    /*
-     * We need to allocate a new stack! It needs to store 'growth' words,
-     * including the elements to be copied over and the new marker.
-     */
-
-#ifndef PURIFY
-    newElems = 2*currElems;
-    while (needed > newElems) {
-	newElems *= 2;
-    }
-#else
-    newElems = needed;
-#endif
-    
-    newBytes = sizeof(ExecStack) + (newElems-1) * sizeof(Tcl_Obj *);
-
-    oldPtr = esPtr;
-    esPtr = ckalloc(newBytes);
-
-    oldPtr->nextPtr = esPtr;
-    esPtr->prevPtr = oldPtr;
-    esPtr->nextPtr = NULL;
-    esPtr->endPtr = &esPtr->stackWords[newElems-1];
-
-  newStackReady:
-    eePtr->execStackPtr = esPtr;
-
-    /*
-     * Store a NULL marker at the beginning of the stack, to indicate that
-     * this is the first marker in this stack and that rewinding to here
-     * should actually be a return to the previous stack.
-     */
-
-    esPtr->stackWords[0] = NULL;
-    esPtr->markerPtr = &esPtr->stackWords[0];
-    memStart = MEMSTART(esPtr->markerPtr);
-    esPtr->tosPtr = memStart - 1;
-
-    if (move) {
-	memcpy(memStart, MEMSTART(markerPtr), moveWords*sizeof(Tcl_Obj *));
-	esPtr->tosPtr += moveWords;
-	oldPtr->markerPtr = (Tcl_Obj **) *markerPtr;
-	oldPtr->tosPtr = markerPtr-1;
-    }
-
-    /*
-     * Free the old stack if it is now unused.
-     */
-
-    if (!oldPtr->markerPtr) {
-	DeleteExecStack(oldPtr);
-    }
-
-    return memStart;
-}
-
-/*
- *--------------------------------------------------------------
- *
- * TclStackAlloc, TclStackRealloc, TclStackFree --
- *
- *	Allocate memory from the execution stack; it has to be returned later
- *	with a call to TclStackFree.
- *
- * Results:
- *	A pointer to the first byte allocated, or panics if the allocation did
- *	not succeed.
- *
- * Side effects:
- *	The execution stack may be grown.
- *
- *--------------------------------------------------------------
- */
-
-static Tcl_Obj **
-StackAllocWords(
-    Tcl_Interp *interp,
-    int numWords)
-{
-    /*
-     * Note that GrowEvaluationStack sets a marker in the stack. This marker
-     * is read when rewinding, e.g., by TclStackFree.
-     */
-
-    Interp *iPtr = (Interp *) interp;
-    ExecEnv *eePtr = iPtr->execEnvPtr;
-    Tcl_Obj **resPtr = GrowEvaluationStack(eePtr, numWords, 0);
-
-    eePtr->execStackPtr->tosPtr += numWords;
-    return resPtr;
-}
-
-static Tcl_Obj **
-StackReallocWords(
-    Tcl_Interp *interp,
-    int numWords)
-{
-    Interp *iPtr = (Interp *) interp;
-    ExecEnv *eePtr = iPtr->execEnvPtr;
-    Tcl_Obj **resPtr = GrowEvaluationStack(eePtr, numWords, 1);
-
-    eePtr->execStackPtr->tosPtr += numWords;
-    return resPtr;
-}
-
-void
-TclStackFree(
-    Tcl_Interp *interp,
-    void *freePtr)
-{
-    Interp *iPtr = (Interp *) interp;
-    ExecEnv *eePtr;
-    ExecStack *esPtr;
-    Tcl_Obj **markerPtr, *marker;
-
-    if (iPtr == NULL || iPtr->execEnvPtr == NULL) {
-	ckfree((char *) freePtr);
-	return;
-    }
-
-    /*
-     * Rewind the stack to the previous marker position. The current marker,
-     * as set in the last call to GrowEvaluationStack, contains a pointer to
-     * the previous marker.
-     */
-
-    eePtr = iPtr->execEnvPtr;
-    esPtr = eePtr->execStackPtr;
-    markerPtr = esPtr->markerPtr;
-    marker = *markerPtr;
-
-    if ((freePtr != NULL) && (MEMSTART(markerPtr) != (Tcl_Obj **)freePtr)) {
-	Tcl_Panic("TclStackFree: incorrect freePtr (%p != %p). Call out of sequence?",
-		freePtr, MEMSTART(markerPtr));
-    }
-
-    esPtr->tosPtr = markerPtr - 1;
-    esPtr->markerPtr = (Tcl_Obj **) marker;
-    if (marker) {
-	return;
-    }
-
-    /*
-     * Return to previous active stack. Note that repeated expansions or
-     * reallocs could have generated several unused intervening stacks: free
-     * them too.
-     */
-
-    while (esPtr->nextPtr) {
-	esPtr = esPtr->nextPtr;
-    }
-    esPtr->tosPtr = &esPtr->stackWords[-1];
-    while (esPtr->prevPtr) {
-	ExecStack *tmpPtr = esPtr->prevPtr;
-	if (tmpPtr->tosPtr == &tmpPtr->stackWords[-1]) {
-	    DeleteExecStack(tmpPtr);
-	} else {
-	    break;
-	}
-    }
-    if (esPtr->prevPtr) {
-	eePtr->execStackPtr = esPtr->prevPtr;
-#ifdef PURIFY
-	eePtr->execStackPtr->nextPtr = NULL;
-	DeleteExecStack(esPtr);
-#endif
-    } else {
-	eePtr->execStackPtr = esPtr;
-    }
-}
-
-void *
-TclStackAlloc(
-    Tcl_Interp *interp,
-    int numBytes)
-{
-    Interp *iPtr = (Interp *) interp;
-    int numWords = (numBytes + (sizeof(Tcl_Obj *) - 1))/sizeof(Tcl_Obj *);
-
-    if (iPtr == NULL || iPtr->execEnvPtr == NULL) {
-	return (void *) ckalloc(numBytes);
-    }
-
-    return (void *) StackAllocWords(interp, numWords);
-}
-
-void *
-TclStackRealloc(
-    Tcl_Interp *interp,
-    void *ptr,
-    int numBytes)
-{
-    Interp *iPtr = (Interp *) interp;
-    ExecEnv *eePtr;
-    ExecStack *esPtr;
-    Tcl_Obj **markerPtr;
-    int numWords;
-
-    if (iPtr == NULL || iPtr->execEnvPtr == NULL) {
-	return (void *) ckrealloc((char *) ptr, numBytes);
-    }
-
-    eePtr = iPtr->execEnvPtr;
-    esPtr = eePtr->execStackPtr;
-    markerPtr = esPtr->markerPtr;
-
-    if (MEMSTART(markerPtr) != (Tcl_Obj **)ptr) {
-	Tcl_Panic("TclStackRealloc: incorrect ptr. Call out of sequence?");
-    }
-
-    numWords = (numBytes + (sizeof(Tcl_Obj *) - 1))/sizeof(Tcl_Obj *);
-    return (void *) StackReallocWords(interp, numWords);
-}
 
 /*
  *--------------------------------------------------------------
  *
  * Tcl_ExprObj --
@@ -1498,18 +1125,14 @@
 		|| (codePtr->localCachePtr != iPtr->varFramePtr->localCachePtr)) {
 	    FreeExprCodeInternalRep(objPtr);
 	}
     }
     if (objPtr->typePtr != &exprCodeType) {
-	/*
-	 * TIP #280: No invoker (yet) - Expression compilation.
-	 */
-
 	int length;
 	const char *string = TclGetStringFromObj(objPtr, &length);
 
-	TclInitCompileEnv(interp, &compEnv, string, length, NULL, 0);
+	TclInitCompileEnv(interp, &compEnv, string, length);
 	TclCompileExpr(interp, string, length, &compEnv, 0);
 
 	/*
 	 * Successful compilation. If the expression yielded no instructions,
 	 * push an zero object as the expression's result.
@@ -1629,13 +1252,11 @@
  */
 
 ByteCode *
 TclCompileObj(
     Tcl_Interp *interp,
-    Tcl_Obj *objPtr,
-    const CmdFrame *invoker,
-    int word)
+    Tcl_Obj *objPtr)
 {
     register Interp *iPtr = (Interp *) interp;
     register ByteCode *codePtr;	/* Tcl Internal type of bytecode. */
     Namespace *namespacePtr = iPtr->varFramePtr->nsPtr;
 
@@ -1685,114 +1306,17 @@
 	if (!(codePtr->flags & TCL_BYTECODE_PRECOMPILED) &&
 		(codePtr->procPtr == NULL) &&
 		(codePtr->localCachePtr != iPtr->varFramePtr->localCachePtr)){
 	    goto recompileObj;
 	}
-
-	/*
-	 * #280.
-	 * Literal sharing fix. This part of the fix is not required by 8.4
-	 * nor 8.5, because they eval-direct any literals, so just saving the
-	 * argument locations per command in bytecode is enough, embedded
-	 * 'eval' commands, etc. get the correct information.
-	 *
-	 * But in 8.6 all the embedded script are compiled, and the resulting
-	 * bytecode stored in the literal. Now the shared literal has bytecode
-	 * with location data for _one_ particular location this literal is
-	 * found at. If we get executed from a different location the bytecode
-	 * has to be recompiled to get the correct locations. Not doing this
-	 * will execute the saved bytecode with data for a different location,
-	 * causing 'info frame' to point to the wrong place in the sources.
-	 *
-	 * Future optimizations ...
-	 * (1) Save the location data (ExtCmdLoc) keyed by start line. In that
-	 *     case we recompile once per location of the literal, but not
-	 *     continously, because the moment we have all locations we do not
-	 *     need to recompile any longer.
-	 *
-	 * (2) Alternative: Do not recompile, tell the execution engine the
-	 *     offset between saved starting line and actual one. Then modify
-	 *     the users to adjust the locations they have by this offset.
-	 *
-	 * (3) Alternative 2: Do not fully recompile, adjust just the location
-	 *     information.
-	 */
-
-	if (invoker == NULL) {
-	    return codePtr;
-	} else {
-	    Tcl_HashEntry *hePtr =
-		    Tcl_FindHashEntry(iPtr->lineBCPtr, codePtr);
-	    ExtCmdLoc *eclPtr;
-	    CmdFrame *ctxCopyPtr;
-	    int redo;
-
-	    if (!hePtr) {
-		return codePtr;
-	    }
-
-	    eclPtr = Tcl_GetHashValue(hePtr);
-	    redo = 0;
-	    ctxCopyPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-	    *ctxCopyPtr = *invoker;
-
-	    if (invoker->type == TCL_LOCATION_BC) {
-		/*
-		 * Note: Type BC => ctx.data.eval.path    is not used.
-		 *		    ctx.data.tebc.codePtr used instead
-		 */
-
-		TclGetSrcInfoForPc(ctxCopyPtr);
-		if (ctxCopyPtr->type == TCL_LOCATION_SOURCE) {
-		    /*
-		     * The reference made by 'TclGetSrcInfoForPc' is dead.
-		     */
-
-		    Tcl_DecrRefCount(ctxCopyPtr->data.eval.path);
-		    ctxCopyPtr->data.eval.path = NULL;
-		}
-	    }
-
-	    if (word < ctxCopyPtr->nline) {
-		/*
-		 * Note: We do not care if the line[word] is -1. This is a
-		 * difference and requires a recompile (location changed from
-		 * absolute to relative, literal is used fixed and through
-		 * variable)
-		 *
-		 * Example:
-		 * test info-32.0 using literal of info-24.8
-		 *     (dict with ... vs           set body ...).
-		 */
-
-		redo = ((eclPtr->type == TCL_LOCATION_SOURCE)
-			    && (eclPtr->start != ctxCopyPtr->line[word]))
-			|| ((eclPtr->type == TCL_LOCATION_BC)
-			    && (ctxCopyPtr->type == TCL_LOCATION_SOURCE));
-	    }
-
-	    TclStackFree(interp, ctxCopyPtr);
-	    if (!redo) {
-		return codePtr;
-	    }
-	}
+	return codePtr;
     }
 
   recompileObj:
     iPtr->errorLine = 1;
 
-    /*
-     * TIP #280. Remember the invoker for a moment in the interpreter
-     * structures so that the byte code compiler can pick it up when
-     * initializing the compilation environment, i.e. the extended location
-     * information.
-     */
-
-    iPtr->invokeCmdFramePtr = invoker;
-    iPtr->invokeWord = word;
     TclSetByteCodeFromAny(interp, objPtr, NULL, NULL);
-    iPtr->invokeCmdFramePtr = NULL;
     codePtr = objPtr->internalRep.otherValuePtr;
     if (iPtr->varFramePtr->localCachePtr) {
 	codePtr->localCachePtr = iPtr->varFramePtr->localCachePtr;
 	codePtr->localCachePtr->refCount++;
     }
@@ -1941,73 +1465,56 @@
  * Side effects:
  *	Almost certainly, depending on the ByteCode's instructions.
  *
  *----------------------------------------------------------------------
  */
-#define	bcFramePtr	(&TD->cmdFrame)
-#define	initCatchTop	((ptrdiff_t *) (&TD->stack[-1]))
-#define	initTosPtr	((Tcl_Obj **) (initCatchTop+codePtr->maxExceptDepth))
-#define esPtr		(iPtr->execEnvPtr->execStackPtr)
+#define	catchStack	(TD->stack)
+#define	initTosPtr	((Tcl_Obj **) &TD->stack[codePtr->maxExceptDepth - 1])
+
+/*
+ * The execution uses a unified stack: first a TEBCdata, immediately
+ * above it the catch stack, then the execution stack.
+ *
+ * Make sure the catch stack is large enough to hold the maximum number of
+ * catch commands that could ever be executing at the same time (this will
+ * be no more than the exception range array's depth). Make sure the
+ * execution stack is large enough to execute this ByteCode.
+ */
+
+// FIXME! The "+1" should not be necessary, temporary until we fix BC issues
+
+#define capacity2size(cap)						\
+    (offsetof(TEBCdata, stack) + sizeof(void *)*(cap + codePtr->maxExceptDepth + 1))
 
 int
 TclNRExecuteByteCode(
     Tcl_Interp *interp,		/* Token for command interpreter. */
     ByteCode *codePtr)		/* The bytecode sequence to interpret. */
 {
     Interp *iPtr = (Interp *) interp;
     TEBCdata *TD;
-    int size = sizeof(TEBCdata) - 1
-	    + (codePtr->maxStackDepth + codePtr->maxExceptDepth)
-		* sizeof(void *);
-    int numWords = (size + sizeof(Tcl_Obj *) - 1) / sizeof(Tcl_Obj *);
-
+    
     if (iPtr->execEnvPtr->rewind) {
 	return TCL_ERROR;
     }
 
     codePtr->refCount++;
 
     /*
      * Reserve the stack, setup the TEBCdataPtr (TD) and CallFrame
-     *
-     * The execution uses a unified stack: first a TEBCdata, immediately
-     * above it a CmdFrame, then the catch stack, then the execution stack.
-     *
-     * Make sure the catch stack is large enough to hold the maximum number of
-     * catch commands that could ever be executing at the same time (this will
-     * be no more than the exception range array's depth). Make sure the
-     * execution stack is large enough to execute this ByteCode.
      */
 
-    TD = (TEBCdata *) GrowEvaluationStack(iPtr->execEnvPtr, numWords, 0);
-    esPtr->tosPtr = initTosPtr;
+    TD = ckalloc(capacity2size(codePtr->maxStackDepth));
 
     TD->codePtr     = codePtr;
-    TD->pc	    = codePtr->codeStart;
-    TD->catchTop    = initCatchTop;
+    TD->tosPtr = initTosPtr;
+    TD->pc          = codePtr->codeStart;
+    TD->catchDepth  = -1;
     TD->cleanup     = 0;
     TD->auxObjList  = NULL;
     TD->checkInterp = 0;
-
-    /*
-     * TIP #280: Initialize the frame. Do not push it yet: it will be pushed
-     * every time that we call out from this TD, popped when we return to it.
-     */
-
-    bcFramePtr->type = ((codePtr->flags & TCL_BYTECODE_PRECOMPILED)
-	    ? TCL_LOCATION_PREBC : TCL_LOCATION_BC);
-    bcFramePtr->level = (iPtr->cmdFramePtr ? iPtr->cmdFramePtr->level+1 : 1);
-    bcFramePtr->numLevels = iPtr->numLevels;
-    bcFramePtr->framePtr = iPtr->framePtr;
-    bcFramePtr->nextPtr = iPtr->cmdFramePtr;
-    bcFramePtr->nline = 0;
-    bcFramePtr->line = NULL;
-    bcFramePtr->litarg = NULL;
-    bcFramePtr->data.tebc.codePtr = codePtr;
-    bcFramePtr->data.tebc.pc = NULL;
-    bcFramePtr->cmd.str.cmd = NULL;
-    bcFramePtr->cmd.str.len = 0;
+    TD->capacity = codePtr->maxStackDepth;
 
 #ifdef TCL_COMPILE_STATS
     iPtr->stats.numExecutions++;
 #endif
 
@@ -2068,15 +1575,15 @@
      * used too frequently
      */
 
     TEBCdata *TD = data[0];
 #define auxObjList	(TD->auxObjList)
-#define catchTop	(TD->catchTop)
+#define catchDepth	(TD->catchDepth)
 #define codePtr		(TD->codePtr)
 #define checkInterp	(TD->checkInterp)
-			/* Indicates when a check of interp readyness is
-			 * necessary. Set by CACHE_STACK_INFO() */
+                        /* Indicates when a check of interp readyness
+			 * is necessary. Set by checkInterp = 1 */
 
     /*
      * Globals: variables that store state, must remain valid at all times.
      */
 
@@ -2108,11 +1615,10 @@
 #endif
 
 #ifdef TCL_COMPILE_DEBUG
     traceInstructions = (tclTraceExec == 3);
 #endif
-
     TEBC_DATA_DIG();
 
 #ifdef TCL_COMPILE_DEBUG
     if (!data[1] && (tclTraceExec >= 2)) {
 	PrintByteCodeInfo(codePtr);
@@ -2123,21 +1629,16 @@
 
     if (data[1] /* resume from invocation */) {
 	if (iPtr->execEnvPtr->rewind) {
 	    result = TCL_ERROR;
 	}
-	NRE_ASSERT(iPtr->cmdFramePtr == bcFramePtr);
-	iPtr->cmdFramePtr = bcFramePtr->nextPtr;
-	if (iPtr->flags & INTERP_DEBUG_FRAME) {
-	    TclArgumentBCRelease((Tcl_Interp *) iPtr, bcFramePtr);
-	}
 	if (codePtr->flags & TCL_BYTECODE_RECOMPILE) {
 	    iPtr->flags |= ERR_ALREADY_LOGGED;
 	    codePtr->flags &= ~TCL_BYTECODE_RECOMPILE;
 	}
 
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	if (result == TCL_OK) {
 #ifndef TCL_COMPILE_DEBUG
 	    if (*pc == INST_POP) {
 		NEXT_INST_V(1, cleanup, 0);
 	    }
@@ -2271,33 +1772,32 @@
      * Check for asynchronous handlers [Bug 746722]; we do the check every
      * ASYNC_CHECK_COUNT_MASK instruction, of the form (2**n-1).
      */
 
     if ((instructionCount++ & ASYNC_CHECK_COUNT_MASK) == 0) {
-	DECACHE_STACK_INFO();
 	if (TclAsyncReady(iPtr)) {
 	    result = Tcl_AsyncInvoke(interp, result);
 	    if (result == TCL_ERROR) {
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 		goto gotError;
 	    }
 	}
 
 	if (TclCanceled(iPtr)) {
 	    if (Tcl_Canceled(interp, TCL_LEAVE_ERR_MSG) == TCL_ERROR) {
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 		goto gotError;
 	    }
 	}
 
 	if (TclLimitReady(iPtr->limit)) {
 	    if (Tcl_LimitCheck(interp) == TCL_ERROR) {
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 		goto gotError;
 	    }
 	}
-	CACHE_STACK_INFO();
+	checkInterp = 1;
     }
 
     TCL_DTRACE_INST_NEXT();
 
     /*
@@ -2372,21 +1872,10 @@
 	TRACE_WITH_OBJ(("yield, result="), iPtr->objResultPtr);
 	if (traceInstructions) {
 	    fprintf(stdout, "\n");
 	}
 #endif
-	/* TIP #280: Record the last piece of info needed by
-	 * 'TclGetSrcInfoForPc', and push the frame.
-	 */
-	
-	bcFramePtr->data.tebc.pc = (char *) pc;
-	iPtr->cmdFramePtr = bcFramePtr;
-
-	if (iPtr->flags & INTERP_DEBUG_FRAME) {
-	    TclArgumentBCEnter((Tcl_Interp *) iPtr, objv, objc,
-		    codePtr, bcFramePtr, pc - codePtr->codeStart);
-	}
 
 	pc++;
 	cleanup = 1;
 	TEBC_YIELD();
 	
@@ -2755,11 +2244,11 @@
 	PUSH_TAUX_OBJ(objPtr);
 	NEXT_INST_F(1, 0, 0);
 
     case INST_EXPAND_STKTOP: {
 	int i;
-	ptrdiff_t moved;
+	unsigned int reqWords;
 
 	/*
 	 * Make sure that the element at stackTop is a list; if not, just
 	 * leave with an error. Note that the element from the expand list
 	 * will be removed at checkForCatch.
@@ -2769,35 +2258,35 @@
 	if (TclListObjGetElements(interp, objPtr, &objc, &objv) != TCL_OK) {
 	    TRACE_WITH_OBJ(("%.30s => ERROR: ", O2S(objPtr)),
 		    Tcl_GetObjResult(interp));
 	    goto gotError;
 	}
-	(void) POP_OBJECT();
 
 	/*
 	 * Make sure there is enough room in the stack to expand this list
 	 * *and* process the rest of the command (at least up to the next
 	 * argument expansion or command end). The operand is the current
 	 * stack depth, as seen by the compiler.
 	 */
 
-	length = objc + (codePtr->maxStackDepth - TclGetInt4AtPtr(pc+1));
-	DECACHE_STACK_INFO();
-	moved = GrowEvaluationStack(iPtr->execEnvPtr, length, 1)
-		- (Tcl_Obj **) TD;
-	if (moved) {
-	    /*
-	     * Change the global data to point to the new stack: move the
-	     * TEBCdataPtr TD, recompute the position of every other
-	     * stack-allocated parameter, update the stack pointers.
-	     */
+	reqWords =
+	    /* how many were needed originally */
+	    codePtr->maxStackDepth
+	    /* plus how many we already consumed in previous expansions */
+	    + (CURR_DEPTH - TclGetInt4AtPtr(pc+1))
+	    /* plus how many are needed for this expansion */
+	    + objc - 1;
 
-	    esPtr = iPtr->execEnvPtr->execStackPtr;
-	    TD = (TEBCdata *) (((Tcl_Obj **)TD) + moved);
+	(void) POP_OBJECT();
+	if (reqWords > TD->capacity) {
+	    ptrdiff_t depth;
+	    unsigned int size = capacity2size(reqWords);
 
-	    catchTop += moved;
-	    tosPtr += moved;
+	    depth = tosPtr - initTosPtr;
+	    TD = ckrealloc(TD, size);
+	    TD->capacity = reqWords;
+	    tosPtr = initTosPtr + depth;
 	}
 
 	/*
 	 * Expand the list at stacktop onto the stack; free the list. Knowing
 	 * that it has a freeIntRepProc we use Tcl_DecrRefCount().
@@ -2812,15 +2301,12 @@
     }
 
     case INST_EXPR_STK: {
 	ByteCode *newCodePtr;
 
-	bcFramePtr->data.tebc.pc = (char *) pc;
-	iPtr->cmdFramePtr = bcFramePtr;
-	DECACHE_STACK_INFO();
 	newCodePtr = CompileExprObj(interp, OBJ_AT_TOS);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	cleanup = 1;
 	pc++;
 	TEBC_YIELD();
 	return TclNRExecuteByteCode(interp, newCodePtr);
     }
@@ -2829,17 +2315,14 @@
 	 * INVOCATION BLOCK
 	 */
 
     instEvalStk:
     case INST_EVAL_STK:
-	bcFramePtr->data.tebc.pc = (char *) pc;
-	iPtr->cmdFramePtr = bcFramePtr;
-
 	cleanup = 1;
 	pc += 1;
 	TEBC_YIELD();
-	return TclNREvalObjEx(interp, OBJ_AT_TOS, 0, NULL, 0);
+	return TclNREvalObjEx(interp, OBJ_AT_TOS, 0);
 
     case INST_INVOKE_EXPANDED:
 	CLANG_ASSERT(auxObjList);
 	objc = CURR_DEPTH - auxObjList->internalRep.ptrAndLongRep.value;
 	POP_TAUX_OBJ();
@@ -2888,25 +2371,19 @@
 	}
 #endif /*TCL_COMPILE_DEBUG*/
 
 	/*
 	 * Finally, let TclEvalObjv handle the command.
-	 *
-	 * TIP #280: Record the last piece of info needed by
-	 * 'TclGetSrcInfoForPc', and push the frame.
 	 */
 
-	bcFramePtr->data.tebc.pc = (char *) pc;
-	iPtr->cmdFramePtr = bcFramePtr;
-
-	if (iPtr->flags & INTERP_DEBUG_FRAME) {
-	    TclArgumentBCEnter((Tcl_Interp *) iPtr, objv, objc,
-		    codePtr, bcFramePtr, pc - codePtr->codeStart);
+	if (!(codePtr->flags & TCL_BYTECODE_PRECOMPILED)) {
+	    Tcl_Obj *srcPtr = iPtr->cmdSourcePtr;
+	    srcPtr->typePtr = &bcSourceType;
+	    srcPtr->internalRep.twoPtrValue.ptr1 = (unsigned char *) pc;
+	    srcPtr->internalRep.twoPtrValue.ptr2 = codePtr;
 	}
 
-	DECACHE_STACK_INFO();
-
 	pc += pcAdjustment;
 	TEBC_YIELD();
 	return TclNREvalObjv(interp, objc, objv,
 		TCL_EVAL_NOERR, NULL);
 
@@ -3040,26 +2517,19 @@
 	    for (i=1 ; i<objc-opnd+1 ; i++) {
 		Tcl_IncrRefCount(copyObjv[i]);
 	    }
 	    objPtr = copyPtr;
 	}
-	bcFramePtr->data.tebc.pc = (char *) pc;
-	iPtr->cmdFramePtr = bcFramePtr;
-	if (iPtr->flags & INTERP_DEBUG_FRAME) {
-	    TclArgumentBCEnter((Tcl_Interp *) iPtr, objv, objc,
-		    codePtr, bcFramePtr, pc - codePtr->codeStart);
-	}
 	iPtr->ensembleRewrite.sourceObjs = objv;
 	iPtr->ensembleRewrite.numRemovedObjs = opnd;
 	iPtr->ensembleRewrite.numInsertedObjs = 1;
-	DECACHE_STACK_INFO();
 	pc += 6;
 	TEBC_YIELD();
 	TclNRAddCallback(interp, TclClearRootEnsemble, NULL,NULL,NULL,NULL);
 	iPtr->evalFlags |= TCL_EVAL_REDIRECT;
-	return TclNREvalObjEx(interp, objPtr, TCL_EVAL_INVOKE, NULL, INT_MIN);
-
+	return TclNREvalObjEx(interp, objPtr, TCL_EVAL_INVOKE);
+	
     /*
      * -----------------------------------------------------------------
      *	   Start of INST_LOAD instructions.
      *
      * WARNING: more 'goto' here than your doctor recommended! The different
@@ -3190,14 +2660,13 @@
 	/*
 	 * There are either errors or the variable is traced: call
 	 * TclPtrGetVar to process fully.
 	 */
 
-	DECACHE_STACK_INFO();
 	objResultPtr = TclPtrGetVar(interp, varPtr, arrayPtr,
 		part1Ptr, part2Ptr, TCL_LEAVE_ERR_MSG, opnd);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	if (!objResultPtr) {
 	    TRACE_APPEND(("ERROR: %.30s\n", O2S(Tcl_GetObjResult(interp))));
 	    goto gotError;
 	}
 	TRACE_APPEND(("%.30s\n", O2S(objResultPtr)));
@@ -3437,14 +2906,13 @@
 	cleanup = 1;
 	arrayPtr = NULL;
 	part1Ptr = part2Ptr = NULL;
 
     doCallPtrSetVar:
-	DECACHE_STACK_INFO();
 	objResultPtr = TclPtrSetVar(interp, varPtr, arrayPtr,
 		part1Ptr, part2Ptr, valuePtr, storeFlags, opnd);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	if (!objResultPtr) {
 	    TRACE_APPEND(("ERROR: %.30s\n", O2S(Tcl_GetObjResult(interp))));
 	    goto gotError;
 	}
 #ifndef TCL_COMPILE_DEBUG
@@ -3701,14 +3169,13 @@
 			O2S(Tcl_GetObjResult(interp))));
 		goto gotError;
 	    }
 	    Tcl_DecrRefCount(incrPtr);
 	} else {
-	    DECACHE_STACK_INFO();
 	    objResultPtr = TclPtrIncrObjVar(interp, varPtr, arrayPtr,
 		    part1Ptr, part2Ptr, incrPtr, TCL_LEAVE_ERR_MSG, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    Tcl_DecrRefCount(incrPtr);
 	    if (objResultPtr == NULL) {
 		TRACE_APPEND(("ERROR: %.30s\n",
 			O2S(Tcl_GetObjResult(interp))));
 		goto gotError;
@@ -3736,14 +3203,13 @@
 	while (TclIsVarLink(varPtr)) {
 	    varPtr = varPtr->value.linkPtr;
 	}
 	TRACE(("%u => ", opnd));
 	if (ReadTraced(varPtr)) {
-	    DECACHE_STACK_INFO();
 	    TclObjCallVarTraces(iPtr, NULL, varPtr, NULL, NULL,
 		    TCL_TRACE_READS, 0, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    if (TclIsVarUndefined(varPtr)) {
 		TclCleanupVar(varPtr, NULL);
 		varPtr = NULL;
 	    }
 	}
@@ -3772,14 +3238,13 @@
 	}
 	varPtr = TclLookupArrayElement(interp, NULL, part2Ptr, 0, "access",
 		0, 1, arrayPtr, opnd);
 	if (varPtr) {
 	    if (ReadTraced(varPtr) || (arrayPtr && ReadTraced(arrayPtr))) {
-		DECACHE_STACK_INFO();
 		TclObjCallVarTraces(iPtr, arrayPtr, varPtr, NULL, part2Ptr,
 			TCL_TRACE_READS, 0, opnd);
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 	    }
 	    if (TclIsVarUndefined(varPtr)) {
 		TclCleanupVar(varPtr, arrayPtr);
 		varPtr = NULL;
 	    }
@@ -3805,14 +3270,13 @@
     doExistStk:
 	varPtr = TclObjLookupVarEx(interp, part1Ptr, part2Ptr, 0, "access",
 		/*createPart1*/0, /*createPart2*/1, &arrayPtr);
 	if (varPtr) {
 	    if (ReadTraced(varPtr) || (arrayPtr && ReadTraced(arrayPtr))) {
-		DECACHE_STACK_INFO();
 		TclObjCallVarTraces(iPtr, arrayPtr, varPtr, part1Ptr,part2Ptr,
 			TCL_TRACE_READS, 0, -1);
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 	    }
 	    if (TclIsVarUndefined(varPtr)) {
 		TclCleanupVar(varPtr, arrayPtr);
 		varPtr = NULL;
 	    }
@@ -3852,16 +3316,15 @@
 	    varPtr->value.objPtr = NULL;
 	    NEXT_INST_F(6, 0, 0);
 	}
 
     slowUnsetScalar:
-	DECACHE_STACK_INFO();
 	if (TclPtrUnsetVar(interp, varPtr, NULL, NULL, NULL, flags,
 		opnd) != TCL_OK && flags) {
 	    goto errorInUnset;
 	}
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	NEXT_INST_F(6, 0, 0);
 
     case INST_UNSET_ARRAY:
 	flags = TclGetUInt1AtPtr(pc+1) ? TCL_LEAVE_ERR_MSG : 0;
 	opnd = TclGetUInt4AtPtr(pc+2);
@@ -3894,11 +3357,10 @@
 
 		NEXT_INST_F(6, 1, 0);
 	    }
 	}
     slowUnsetArray:
-	DECACHE_STACK_INFO();
 	varPtr = TclLookupArrayElement(interp, NULL, part2Ptr, flags, "unset",
 		0, 0, arrayPtr, opnd);
 	if (!varPtr) {
 	    if (flags & TCL_LEAVE_ERR_MSG) {
 		goto errorInUnset;
@@ -3905,11 +3367,11 @@
 	    }
 	} else if (TclPtrUnsetVar(interp, varPtr, arrayPtr, NULL, part2Ptr,
 		flags, opnd) != TCL_OK && (flags & TCL_LEAVE_ERR_MSG)) {
 	    goto errorInUnset;
 	}
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	NEXT_INST_F(6, 1, 0);
 
     case INST_UNSET_ARRAY_STK:
 	flags = TclGetUInt1AtPtr(pc+1) ? TCL_LEAVE_ERR_MSG : 0;
 	cleanup = 2;
@@ -3925,20 +3387,19 @@
 	part2Ptr = NULL;
 	part1Ptr = OBJ_AT_TOS;		/* variable name */
 	TRACE(("%s \"%.30s\"\n", (flags?"normal":"noerr"), O2S(part1Ptr)));
 
     doUnsetStk:
-	DECACHE_STACK_INFO();
 	if (TclObjUnsetVar2(interp, part1Ptr, part2Ptr, flags) != TCL_OK
 		&& (flags & TCL_LEAVE_ERR_MSG)) {
 	    goto errorInUnset;
 	}
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	NEXT_INST_V(2, cleanup, 0);
 
     errorInUnset:
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	TRACE_APPEND(("ERROR: %.30s\n", O2S(Tcl_GetObjResult(interp))));
 	goto gotError;
 
 	/*
 	 * This is really an unset operation these days. Do not issue.
@@ -3955,13 +3416,12 @@
 	    if (!TclIsVarUndefined(varPtr)) {
 		TclDecrRefCount(varPtr->value.objPtr);
 	    }
 	    varPtr->value.objPtr = NULL;
 	} else {
-	    DECACHE_STACK_INFO();
 	    TclPtrUnsetVar(interp, varPtr, NULL, NULL, NULL, 0, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	}
 	NEXT_INST_F(5, 0, 0);
     }
 
     /*
@@ -3991,15 +3451,13 @@
 	varPtr = TclObjLookupVarEx(interp, part1Ptr, NULL, 0, NULL,
 		/*createPart1*/0, /*createPart2*/0, &arrayPtr);
     doArrayExists:
 	if (varPtr && (varPtr->flags & VAR_TRACED_ARRAY)
 		&& (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
-	    DECACHE_STACK_INFO();
 	    result = TclObjCallVarTraces(iPtr, arrayPtr, varPtr, part1Ptr,
 		    NULL, (TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY|
 		    TCL_GLOBAL_ONLY|TCL_TRACE_ARRAY), 1, opnd);
-	    CACHE_STACK_INFO();
 	    if (result == TCL_ERROR) {
 		TRACE_APPEND(("ERROR: %.30s\n",
 			O2S(Tcl_GetObjResult(interp))));
 		goto gotError;
 	    }
@@ -4296,22 +3754,20 @@
 	value2Ptr = OBJ_AT_TOS;
 	valuePtr = OBJ_UNDER_TOS;
 	if (TclGetBooleanFromObj(NULL, valuePtr, &i1) != TCL_OK) {
 	    TRACE(("\"%.20s\" => ILLEGAL TYPE %s \n", O2S(valuePtr),
 		    (valuePtr->typePtr? valuePtr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, valuePtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;	    
 	    goto gotError;
 	}
 
 	if (TclGetBooleanFromObj(NULL, value2Ptr, &i2) != TCL_OK) {
 	    TRACE(("\"%.20s\" => ILLEGAL TYPE %s \n", O2S(value2Ptr),
 		    (value2Ptr->typePtr? value2Ptr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, value2Ptr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;	    
 	    goto gotError;
 	}
 
 	if (*pc == INST_LOR) {
 	    iResult = (i1 || i2);
@@ -5406,24 +4862,22 @@
 	if ((GetNumberFromObj(NULL, valuePtr, &ptr1, &type1) != TCL_OK)
 		|| (type1==TCL_NUMBER_DOUBLE) || (type1==TCL_NUMBER_NAN)) {
 	    TRACE(("%.20s %.20s => ILLEGAL 1st TYPE %s\n", O2S(valuePtr),
 		    O2S(value2Ptr), (valuePtr->typePtr?
 		    valuePtr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, valuePtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 
 	if ((GetNumberFromObj(NULL, value2Ptr, &ptr2, &type2) != TCL_OK)
 		|| (type2==TCL_NUMBER_DOUBLE) || (type2==TCL_NUMBER_NAN)) {
 	    TRACE(("%.20s %.20s => ILLEGAL 2nd TYPE %s\n", O2S(valuePtr),
 		    O2S(value2Ptr), (value2Ptr->typePtr?
 		    value2Ptr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, value2Ptr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 
 	/*
 	 * Check for common, simple case.
@@ -5477,15 +4931,14 @@
 	    case INST_RSHIFT:
 		if (l2 < 0) {
 		    Tcl_SetObjResult(interp, Tcl_NewStringObj(
 			    "negative shift argument", -1));
 #if 0
-		    DECACHE_STACK_INFO();
 		    Tcl_SetErrorCode(interp, "ARITH", "DOMAIN",
 			    "domain error: argument not in valid range",
 			    NULL);
-		    CACHE_STACK_INFO();
+		    checkInterp = 1;
 #endif
 		    goto gotError;
 		} else if (l1 == 0) {
 		    TRACE(("%s %s => ", O2S(valuePtr), O2S(value2Ptr)));
 		    objResultPtr = TCONST(0);
@@ -5525,15 +4978,14 @@
 	    case INST_LSHIFT:
 		if (l2 < 0) {
 		    Tcl_SetObjResult(interp, Tcl_NewStringObj(
 			    "negative shift argument", -1));
 #if 0
-		    DECACHE_STACK_INFO();
 		    Tcl_SetErrorCode(interp, "ARITH", "DOMAIN",
 			    "domain error: argument not in valid range",
 			    NULL);
-		    CACHE_STACK_INFO();
+		    checkInterp = 1;
 #endif
 		    goto gotError;
 		} else if (l1 == 0) {
 		    TRACE(("%s %s => ", O2S(valuePtr), O2S(value2Ptr)));
 		    objResultPtr = TCONST(0);
@@ -5548,14 +5000,13 @@
 		     */
 
 		    Tcl_SetObjResult(interp, Tcl_NewStringObj(
 			    "integer value too large to represent", -1));
 #if 0
-		    DECACHE_STACK_INFO();
 		    Tcl_SetErrorCode(interp, "ARITH", "IOVERFLOW",
 			    "integer value too large to represent", NULL);
-		    CACHE_STACK_INFO();
+		    checkInterp = 1;
 #endif
 		    goto gotError;
 		} else {
 		    int shift = (int) l2;
 
@@ -5634,13 +5085,12 @@
 	if ((GetNumberFromObj(NULL, valuePtr, &ptr1, &type1) != TCL_OK)
 		|| IsErroringNaNType(type1)) {
 	    TRACE(("%.20s %.20s => ILLEGAL 1st TYPE %s\n",
 		    O2S(value2Ptr), O2S(valuePtr),
 		    (valuePtr->typePtr? valuePtr->typePtr->name: "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, valuePtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 
 #ifdef ACCEPT_NAN
 	if (type1 == TCL_NUMBER_NAN) {
@@ -5655,13 +5105,12 @@
 	if ((GetNumberFromObj(NULL, value2Ptr, &ptr2, &type2) != TCL_OK)
 		|| IsErroringNaNType(type2)) {
 	    TRACE(("%.20s %.20s => ILLEGAL 2nd TYPE %s\n",
 		    O2S(value2Ptr), O2S(valuePtr),
 		    (value2Ptr->typePtr? value2Ptr->typePtr->name: "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, value2Ptr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 
 #ifdef ACCEPT_NAN
 	if (type2 == TCL_NUMBER_NAN) {
@@ -5804,13 +5253,12 @@
 	/* TODO - check claim that taking address of b harms performance */
 	/* TODO - consider optimization search for constants */
 	if (TclGetBooleanFromObj(NULL, valuePtr, &b) != TCL_OK) {
 	    TRACE(("\"%.20s\" => ILLEGAL TYPE %s\n", O2S(valuePtr),
 		    (valuePtr->typePtr? valuePtr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, valuePtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 	/* TODO: Consider peephole opt. */
 	objResultPtr = TCONST(!b);
 	NEXT_INST_F(1, 1, 1);
@@ -5824,13 +5272,12 @@
 	     * ... ~$NonInteger => raise an error.
 	     */
 
 	    TRACE(("\"%.20s\" => ILLEGAL TYPE %s \n", O2S(valuePtr),
 		    (valuePtr->typePtr? valuePtr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, valuePtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 	if (type1 == TCL_NUMBER_LONG) {
 	    l1 = *((const long *) ptr1);
 	    if (Tcl_IsShared(valuePtr)) {
@@ -5851,13 +5298,12 @@
 	valuePtr = OBJ_AT_TOS;
 	if ((GetNumberFromObj(NULL, valuePtr, &ptr1, &type1) != TCL_OK)
 		|| IsErroringNaNType(type1)) {
 	    TRACE(("\"%.20s\" => ILLEGAL TYPE %s \n", O2S(valuePtr),
 		    (valuePtr->typePtr? valuePtr->typePtr->name : "null")));
-	    DECACHE_STACK_INFO();
 	    IllegalExprOperandType(interp, pc, valuePtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    goto gotError;
 	}
 	switch (type1) {
 	case TCL_NUMBER_NAN:
 	    /* -NaN => NaN */
@@ -5897,13 +5343,12 @@
 		 * ... +$NonNumeric => raise an error.
 		 */
 
 		TRACE(("\"%.20s\" => ILLEGAL TYPE %s \n", O2S(valuePtr),
 			(valuePtr->typePtr? valuePtr->typePtr->name:"null")));
-		DECACHE_STACK_INFO();
 		IllegalExprOperandType(interp, pc, valuePtr);
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 		goto gotError;
 	    }
 
 	    /* ... TryConvertToNumeric($NonNumeric) is acceptable */
 	    TRACE(("\"%.20s\" => not numeric\n", O2S(valuePtr)));
@@ -5915,23 +5360,21 @@
 		 * ... +$NonNumeric => raise an error.
 		 */
 
 		TRACE(("\"%.20s\" => ILLEGAL TYPE %s \n", O2S(valuePtr),
 			(valuePtr->typePtr? valuePtr->typePtr->name:"null")));
-		DECACHE_STACK_INFO();
 		IllegalExprOperandType(interp, pc, valuePtr);
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 	    } else {
 		/*
 		 * Numeric conversion of NaN -> error.
 		 */
 
 		TRACE(("\"%.20s\" => IEEE FLOATING PT ERROR\n",
 			O2S(objResultPtr)));
-		DECACHE_STACK_INFO();
 		TclExprFloatError(interp, *((const double *) ptr1));
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 	    }
 	    goto gotError;
 	}
 
 	/*
@@ -5972,23 +5415,21 @@
      * -----------------------------------------------------------------
      */
 
     case INST_BREAK:
 	/*
-	DECACHE_STACK_INFO();
 	Tcl_ResetResult(interp);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	*/
 	result = TCL_BREAK;
 	cleanup = 0;
 	goto processExceptionReturn;
 
     case INST_CONTINUE:
 	/*
-	DECACHE_STACK_INFO();
 	Tcl_ResetResult(interp);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	*/
 	result = TCL_CONTINUE;
 	cleanup = 0;
 	goto processExceptionReturn;
 
@@ -6117,21 +5558,20 @@
 			    }
 			    varPtr->value.objPtr = valuePtr;
 			    Tcl_IncrRefCount(valuePtr);
 			}
 		    } else {
-			DECACHE_STACK_INFO();
 			if (TclPtrSetVar(interp, varPtr, NULL, NULL, NULL,
 				valuePtr, TCL_LEAVE_ERR_MSG, varIndex)==NULL){
-			    CACHE_STACK_INFO();
+			    checkInterp = 1;
 			    TRACE_WITH_OBJ((
 				    "%u => ERROR init. index temp %d: ",
 				    opnd,varIndex), Tcl_GetObjResult(interp));
 			    TclDecrRefCount(listPtr);
 			    goto gotError;
 			}
-			CACHE_STACK_INFO();
+			checkInterp = 1;
 		    }
 		    valIndex++;
 		}
 		TclDecrRefCount(listPtr);
 		listTmpIndex++;
@@ -6159,23 +5599,22 @@
 	 * Record start of the catch command with exception range index equal
 	 * to the operand. Push the current stack depth onto the special catch
 	 * stack.
 	 */
 
-	*(++catchTop) = CURR_DEPTH;
-	TRACE(("%u => catchTop=%d, stackTop=%d\n",
-		TclGetUInt4AtPtr(pc+1), (int) (catchTop - initCatchTop - 1),
+	catchStack[++catchDepth] = INT2PTR(CURR_DEPTH);
+	TRACE(("%u => catchDepth=%d, stackTop=%d\n",
+		TclGetUInt4AtPtr(pc+1), (int) (catchDepth),
 		(int) CURR_DEPTH));
 	NEXT_INST_F(5, 0, 0);
 
     case INST_END_CATCH:
-	catchTop--;
-	DECACHE_STACK_INFO();
+	catchDepth--;
 	Tcl_ResetResult(interp);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	result = TCL_OK;
-	TRACE(("=> catchTop=%d\n", (int) (catchTop - initCatchTop - 1)));
+	TRACE(("=> catchDepth=%d\n", (int) (catchDepth)));
 	NEXT_INST_F(1, 0, 0);
 
     case INST_PUSH_RESULT:
 	objResultPtr = Tcl_GetObjResult(interp);
 	TRACE_WITH_OBJ(("=> "), objResultPtr);
@@ -6193,13 +5632,12 @@
 	TclNewIntObj(objResultPtr, result);
 	TRACE(("=> %u\n", result));
 	NEXT_INST_F(1, 0, 1);
 
     case INST_PUSH_RETURN_OPTIONS:
-	DECACHE_STACK_INFO();
 	objResultPtr = Tcl_GetReturnOptions(interp, result);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 	TRACE_WITH_OBJ(("=> "), objResultPtr);
 	NEXT_INST_F(1, 0, 1);
 
     case INST_RETURN_CODE_BRANCH: {
 	int code;
@@ -6272,17 +5710,16 @@
 	    }
 	    if (objResultPtr) {
 		TRACE_APPEND(("%.30s\n", O2S(objResultPtr)));
 		NEXT_INST_V(5, opnd+1, 1);
 	    }
-	    DECACHE_STACK_INFO();
 	    Tcl_SetObjResult(interp, Tcl_ObjPrintf(
 		    "key \"%s\" not known in dictionary",
 		    TclGetString(OBJ_AT_TOS)));
 	    Tcl_SetErrorCode(interp, "TCL", "LOOKUP", "DICT",
 		    TclGetString(OBJ_AT_TOS), NULL);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    TRACE_WITH_OBJ(("%u => ERROR ", opnd), Tcl_GetObjResult(interp));
 	} else {
 	    if (*pc == INST_DICT_EXISTS) {
 	    dictNotExists:
 		objResultPtr = TCONST(0);
@@ -6308,13 +5745,12 @@
 	}
 	TRACE(("%u %u => ", opnd, opnd2));
 	if (TclIsVarDirectReadable(varPtr)) {
 	    dictPtr = varPtr->value.objPtr;
 	} else {
-	    DECACHE_STACK_INFO();
 	    dictPtr = TclPtrGetVar(interp, varPtr, NULL,NULL,NULL, 0, opnd2);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	}
 	if (dictPtr == NULL) {
 	    TclNewObj(dictPtr);
 	    allocateDict = 1;
 	} else {
@@ -6382,14 +5818,13 @@
 		varPtr->value.objPtr = dictPtr;
 	    }
 	    objResultPtr = dictPtr;
 	} else {
 	    Tcl_IncrRefCount(dictPtr);
-	    DECACHE_STACK_INFO();
 	    objResultPtr = TclPtrSetVar(interp, varPtr, NULL, NULL, NULL,
 		    dictPtr, TCL_LEAVE_ERR_MSG, opnd2);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    TclDecrRefCount(dictPtr);
 	    if (objResultPtr == NULL) {
 		TRACE_APPEND(("ERROR: %.30s\n",
 			O2S(Tcl_GetObjResult(interp))));
 		goto gotError;
@@ -6412,13 +5847,12 @@
 	}
 	TRACE(("%u => ", opnd));
 	if (TclIsVarDirectReadable(varPtr)) {
 	    dictPtr = varPtr->value.objPtr;
 	} else {
-	    DECACHE_STACK_INFO();
 	    dictPtr = TclPtrGetVar(interp, varPtr, NULL, NULL, NULL, 0, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	}
 	if (dictPtr == NULL) {
 	    TclNewObj(dictPtr);
 	    allocateDict = 1;
 	} else {
@@ -6518,14 +5952,13 @@
 		varPtr->value.objPtr = dictPtr;
 	    }
 	    objResultPtr = dictPtr;
 	} else {
 	    Tcl_IncrRefCount(dictPtr);
-	    DECACHE_STACK_INFO();
 	    objResultPtr = TclPtrSetVar(interp, varPtr, NULL, NULL, NULL,
 		    dictPtr, TCL_LEAVE_ERR_MSG, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    TclDecrRefCount(dictPtr);
 	    if (objResultPtr == NULL) {
 		TRACE_APPEND(("ERROR: %.30s\n",
 			O2S(Tcl_GetObjResult(interp))));
 		goto gotError;
@@ -6623,14 +6056,13 @@
 	}
 	TRACE(("%u => ", opnd));
 	if (TclIsVarDirectReadable(varPtr)) {
 	    dictPtr = varPtr->value.objPtr;
 	} else {
-	    DECACHE_STACK_INFO();
 	    dictPtr = TclPtrGetVar(interp, varPtr, NULL, NULL, NULL,
 		    TCL_LEAVE_ERR_MSG, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    if (dictPtr == NULL) {
 		goto gotError;
 	    }
 	}
 	if (TclListObjGetElements(interp, OBJ_AT_TOS, &length,
@@ -6647,22 +6079,21 @@
 	    }
 	    varPtr = LOCAL(duiPtr->varIndices[i]);
 	    while (TclIsVarLink(varPtr)) {
 		varPtr = varPtr->value.linkPtr;
 	    }
-	    DECACHE_STACK_INFO();
 	    if (valuePtr == NULL) {
 		TclObjUnsetVar2(interp,
 			localName(iPtr->varFramePtr, duiPtr->varIndices[i]),
 			NULL, 0);
 	    } else if (TclPtrSetVar(interp, varPtr, NULL, NULL, NULL,
 		    valuePtr, TCL_LEAVE_ERR_MSG,
 		    duiPtr->varIndices[i]) == NULL) {
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 		goto gotError;
 	    }
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	}
 	NEXT_INST_F(9, 0, 0);
 
     case INST_DICT_UPDATE_END:
 	opnd = TclGetUInt4AtPtr(pc+1);
@@ -6674,13 +6105,12 @@
 	}
 	TRACE(("%u => ", opnd));
 	if (TclIsVarDirectReadable(varPtr)) {
 	    dictPtr = varPtr->value.objPtr;
 	} else {
-	    DECACHE_STACK_INFO();
 	    dictPtr = TclPtrGetVar(interp, varPtr, NULL, NULL, NULL, 0, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	}
 	if (dictPtr == NULL) {
 	    NEXT_INST_F(9, 1, 0);
 	}
 	if (Tcl_DictObjSize(interp, dictPtr, &length) != TCL_OK
@@ -6702,14 +6132,13 @@
 		var2Ptr = var2Ptr->value.linkPtr;
 	    }
 	    if (TclIsVarDirectReadable(var2Ptr)) {
 		valuePtr = var2Ptr->value.objPtr;
 	    } else {
-		DECACHE_STACK_INFO();
 		valuePtr = TclPtrGetVar(interp, var2Ptr, NULL, NULL, NULL, 0,
 			duiPtr->varIndices[i]);
-		CACHE_STACK_INFO();
+		checkInterp = 1;
 	    }
 	    if (valuePtr == NULL) {
 		Tcl_DictObjRemove(interp, dictPtr, keyPtrPtr[i]);
 	    } else if (dictPtr == valuePtr) {
 		Tcl_DictObjPut(interp, dictPtr, keyPtrPtr[i],
@@ -6721,14 +6150,13 @@
 	if (TclIsVarDirectWritable(varPtr)) {
 	    Tcl_IncrRefCount(dictPtr);
 	    TclDecrRefCount(varPtr->value.objPtr);
 	    varPtr->value.objPtr = dictPtr;
 	} else {
-	    DECACHE_STACK_INFO();
 	    objResultPtr = TclPtrSetVar(interp, varPtr, NULL, NULL, NULL,
 		    dictPtr, TCL_LEAVE_ERR_MSG, opnd);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	    if (objResultPtr == NULL) {
 		if (allocdict) {
 		    TclDecrRefCount(dictPtr);
 		}
 		goto gotError;
@@ -6769,14 +6197,12 @@
 	if (varPtr == NULL) {
 	    TRACE_APPEND(("ERROR: %.30s\n", O2S(Tcl_GetObjResult(interp))));
 	    TclDecrRefCount(keysPtr);
 	    goto gotError;
 	}
-	DECACHE_STACK_INFO();
 	result = TclDictWithFinish(interp, varPtr,arrayPtr,varNamePtr,NULL,-1,
 		objc, objv, keysPtr);
-	CACHE_STACK_INFO();
 	TclDecrRefCount(keysPtr);
 	if (result != TCL_OK) {
 	    TRACE_APPEND(("ERROR: %.30s\n", O2S(Tcl_GetObjResult(interp))));
 	    goto gotError;
 	}
@@ -6795,14 +6221,12 @@
 	    goto gotError;
 	}
 	while (TclIsVarLink(varPtr)) {
 	    varPtr = varPtr->value.linkPtr;
 	}
-	DECACHE_STACK_INFO();
 	result = TclDictWithFinish(interp, varPtr, NULL, NULL, NULL, opnd,
 		objc, objv, keysPtr);
-	CACHE_STACK_INFO();
 	if (result != TCL_OK) {
 	    TRACE_APPEND(("ERROR: %.30s\n", O2S(Tcl_GetObjResult(interp))));
 	    goto gotError;
 	}
 	TRACE_APPEND(("OK\n"));
@@ -6912,28 +6336,26 @@
 	 * Division by zero in an expression. Control only reaches this point
 	 * by "goto divideByZero".
 	 */
 
     divideByZero:
-	DECACHE_STACK_INFO();
-	Tcl_SetObjResult(interp, Tcl_NewStringObj("divide by zero", -1));
+	Tcl_SetResult(interp, "divide by zero", TCL_STATIC);
 	Tcl_SetErrorCode(interp, "ARITH", "DIVZERO", "divide by zero", NULL);
-	CACHE_STACK_INFO();
+	checkInterp = 1;	
 	goto gotError;
 
 	/*
 	 * Exponentiation of zero by negative number in an expression. Control
 	 * only reaches this point by "goto exponOfZero".
 	 */
 
     exponOfZero:
-	DECACHE_STACK_INFO();
-	Tcl_SetObjResult(interp, Tcl_NewStringObj(
-		"exponentiation of zero by negative power", -1));
+	Tcl_SetResult(interp, "exponentiation of zero by negative power",
+		TCL_STATIC);
 	Tcl_SetErrorCode(interp, "ARITH", "DOMAIN",
 		"exponentiation of zero by negative power", NULL);
-	CACHE_STACK_INFO();
+	checkInterp = 1;
 
 	/*
 	 * Almost all error paths feed through here rather than assigning to
 	 * result themselves (for a small but consistent saving).
 	 */
@@ -6955,26 +6377,24 @@
 	}
 	if ((result == TCL_ERROR) && !(iPtr->flags & ERR_ALREADY_LOGGED)) {
 	    const unsigned char *pcBeg;
 
 	    bytes = GetSrcInfoForPc(pc, codePtr, &length, &pcBeg);
-	    DECACHE_STACK_INFO();
 	    TclLogCommandInfo(interp, codePtr->source, bytes,
 		    bytes ? length : 0, pcBeg, tosPtr);
-	    CACHE_STACK_INFO();
+	    checkInterp = 1;
 	}
 	iPtr->flags &= ~ERR_ALREADY_LOGGED;
 
 	/*
 	 * Clear all expansions that may have started after the last
 	 * INST_BEGIN_CATCH.
 	 */
 
 	while (auxObjList) {
-	    if ((catchTop != initCatchTop)
-		    && (*catchTop > (ptrdiff_t)
-			auxObjList->internalRep.ptrAndLongRep.value)) {
+	    if ((catchDepth >=0) && (PTR2INT(catchStack[catchDepth]) >
+		        PTR2INT(auxObjList->internalRep.twoPtrValue.ptr1))) {
 		break;
 	    }
 	    POP_TAUX_OBJ();
 	}
 
@@ -7010,11 +6430,11 @@
 			StringForResultCode(result));
 	    }
 #endif
 	    goto abnormalReturn;
 	}
-	if (catchTop == initCatchTop) {
+	if (catchDepth == -1) {
 #ifdef TCL_COMPILE_DEBUG
 	    if (traceInstructions) {
 		fprintf(stdout, "   ... no enclosing catch, returning %s\n",
 			StringForResultCode(result));
 	    }
@@ -7045,20 +6465,20 @@
 	 * its catchOffset after unwinding the operand stack to the depth it
 	 * had when starting to execute the range's catch command.
 	 */
 
     processCatch:
-	while (CURR_DEPTH > *catchTop) {
+	while (CURR_DEPTH > PTR2INT(catchStack[catchDepth])) {
 	    valuePtr = POP_OBJECT();
 	    TclDecrRefCount(valuePtr);
 	}
 #ifdef TCL_COMPILE_DEBUG
 	if (traceInstructions) {
-	    fprintf(stdout, "  ... found catch at %d, catchTop=%d, "
+	    fprintf(stdout, "  ... found catch at %d, catchDepth=%d, "
 		    "unwound to %ld, new pc %u\n",
-		    rangePtr->codeOffset, (int) (catchTop - initCatchTop - 1),
-		    (long) *catchTop, (unsigned) rangePtr->catchOffset);
+		    rangePtr->codeOffset, (int) catchDepth,
+		    PTR2INT(catchStack[catchDepth]), (unsigned) rangePtr->catchOffset);
 	}
 #endif
 	pc = (codePtr->codeStart + rangePtr->catchOffset);
 	NEXT_INST_F(0, 0, 0);	/* Restart the execution loop at pc. */
 
@@ -7096,29 +6516,25 @@
 		    "stack top %d < entry stack top %d\n",
 		    (unsigned)(pc - codePtr->codeStart),
 		    (unsigned) CURR_DEPTH, (unsigned) 0);
 	    Tcl_Panic("TclNRExecuteByteCode execution failure: end stack top < start stack top");
 	}
-	CLANG_ASSERT(bcFramePtr);
     }
 
-    iPtr->cmdFramePtr = bcFramePtr->nextPtr;
     if (--codePtr->refCount <= 0) {
 	TclCleanupByteCode(codePtr);
     }
-    TclStackFree(interp, TD);	/* free my stack */
+    ckfree(TD);	/* free my stack */
 
     return result;
 }
 
 #undef codePtr
 #undef iPtr
-#undef bcFramePtr
-#undef initCatchTop
 #undef initTosPtr
 #undef auxObjList
-#undef catchTop
+#undef catchDepth
 #undef TCONST
 
 /*
  *----------------------------------------------------------------------
  *
@@ -8699,80 +8115,10 @@
  *	The CmdFrame at *cfPtr is updated.
  *
  *----------------------------------------------------------------------
  */
 
-const char *
-TclGetSrcInfoForCmd(
-    Interp *iPtr,
-    int *lenPtr)
-{
-    CmdFrame *cfPtr = iPtr->cmdFramePtr;
-    ByteCode *codePtr = (ByteCode *) cfPtr->data.tebc.codePtr;
-
-    return GetSrcInfoForPc((unsigned char *) cfPtr->data.tebc.pc,
-	    codePtr, lenPtr, NULL);
-}
-
-void
-TclGetSrcInfoForPc(
-    CmdFrame *cfPtr)
-{
-    ByteCode *codePtr = (ByteCode *) cfPtr->data.tebc.codePtr;
-
-    if (cfPtr->cmd.str.cmd == NULL) {
-	cfPtr->cmd.str.cmd = GetSrcInfoForPc(
-		(unsigned char *) cfPtr->data.tebc.pc, codePtr,
-		&cfPtr->cmd.str.len, NULL);
-    }
-
-    if (cfPtr->cmd.str.cmd != NULL) {
-	/*
-	 * We now have the command. We can get the srcOffset back and from
-	 * there find the list of word locations for this command.
-	 */
-
-	ExtCmdLoc *eclPtr;
-	ECL *locPtr = NULL;
-	int srcOffset, i;
-	Interp *iPtr = (Interp *) *codePtr->interpHandle;
-	Tcl_HashEntry *hePtr =
-		Tcl_FindHashEntry(iPtr->lineBCPtr, codePtr);
-
-	if (!hePtr) {
-	    return;
-	}
-
-	srcOffset = cfPtr->cmd.str.cmd - codePtr->source;
-	eclPtr = Tcl_GetHashValue(hePtr);
-
-	for (i=0; i < eclPtr->nuloc; i++) {
-	    if (eclPtr->loc[i].srcOffset == srcOffset) {
-		locPtr = eclPtr->loc+i;
-		break;
-	    }
-	}
-	if (locPtr == NULL) {
-	    Tcl_Panic("LocSearch failure");
-	}
-
-	cfPtr->line = locPtr->line;
-	cfPtr->nline = locPtr->nline;
-	cfPtr->type = eclPtr->type;
-
-	if (eclPtr->type == TCL_LOCATION_SOURCE) {
-	    cfPtr->data.eval.path = eclPtr->path;
-	    Tcl_IncrRefCount(cfPtr->data.eval.path);
-	}
-
-	/*
-	 * Do not set cfPtr->data.eval.path NULL for non-SOURCE. Needed for
-	 * cfPtr->data.tebc.codePtr.
-	 */
-    }
-}
-
 static const char *
 GetSrcInfoForPc(
     const unsigned char *pc,	/* The program counter value for which to
 				 * return the closest command's source info.
 				 * This points within a bytecode instruction

Index: generic/tclFCmd.c
==================================================================
--- generic/tclFCmd.c
+++ generic/tclFCmd.c
@@ -1005,11 +1005,11 @@
 
 	if (Tcl_ListObjLength(interp, objStrings, &numObjStrings) != TCL_OK) {
 	    goto end;
 	}
 	attributeStringsAllocated = (const char **)
-		TclStackAlloc(interp, (1+numObjStrings) * sizeof(char *));
+		ckalloc((1+numObjStrings) * sizeof(char *));
 	for (index = 0; index < numObjStrings; index++) {
 	    Tcl_ListObjIndex(interp, objStrings, index, &objPtr);
 	    attributeStringsAllocated[index] = TclGetString(objPtr);
 	}
 	attributeStringsAllocated[index] = NULL;
@@ -1136,11 +1136,11 @@
      * attribute names issued by the filesystem.
      */
 
   end:
     if (attributeStringsAllocated != NULL) {
-	TclStackFree(interp, (void *) attributeStringsAllocated);
+	ckfree((void *) attributeStringsAllocated);
     }
     if (objStrings != NULL) {
 	Tcl_DecrRefCount(objStrings);
     }
     return result;

Index: generic/tclFileName.c
==================================================================
--- generic/tclFileName.c
+++ generic/tclFileName.c
@@ -1447,11 +1447,11 @@
 
 	Tcl_ListObjLength(interp, typePtr, &length);
 	if (length <= 0) {
 	    goto skipTypes;
 	}
-	globTypes = TclStackAlloc(interp, sizeof(Tcl_GlobTypeData));
+	globTypes = ckalloc(sizeof(Tcl_GlobTypeData));
 	globTypes->type = 0;
 	globTypes->perm = 0;
 	globTypes->macType = NULL;
 	globTypes->macCreator = NULL;
 
@@ -1667,11 +1667,11 @@
 	    Tcl_DecrRefCount(globTypes->macType);
 	}
 	if (globTypes->macCreator != NULL) {
 	    Tcl_DecrRefCount(globTypes->macCreator);
 	}
-	TclStackFree(interp, globTypes);
+	ckfree(globTypes);
     }
     return result;
 }
 
 /*

Index: generic/tclIOCmd.c
==================================================================
--- generic/tclIOCmd.c
+++ generic/tclIOCmd.c
@@ -929,11 +929,11 @@
      * Create the string argument array "argv". Make sure argv is large enough
      * to hold the argc arguments plus 1 extra for the zero end-of-argv word.
      */
 
     argc = objc - skip;
-    argv = TclStackAlloc(interp, (unsigned)(argc + 1) * sizeof(char *));
+    argv = ckalloc((unsigned)(argc + 1) * sizeof(char *));
 
     /*
      * Copy the string conversions of each (post option) object into the
      * argument vector.
      */
@@ -947,11 +947,11 @@
 
     /*
      * Free the argv array.
      */
 
-    TclStackFree(interp, (void *) argv);
+    ckfree((void *) argv);
 
     if (chan == NULL) {
 	return TCL_ERROR;
     }
 

Index: generic/tclIOUtil.c
==================================================================
--- generic/tclIOUtil.c
+++ generic/tclIOUtil.c
@@ -1802,16 +1802,12 @@
     oldScriptFile = iPtr->scriptFile;
     iPtr->scriptFile = pathPtr;
     Tcl_IncrRefCount(iPtr->scriptFile);
     string = Tcl_GetStringFromObj(objPtr, &length);
 
-    /*
-     * TIP #280 Force the evaluator to open a frame for a sourced file.
-     */
-
     iPtr->evalFlags |= TCL_EVAL_FILE;
-    result = TclEvalEx(interp, string, length, 0, 1, NULL, string);
+    result = Tcl_EvalEx(interp, string, length, 0);
 
     /*
      * Now we have to be careful; the script may have changed the
      * iPtr->scriptFile value, so we must reset it without assuming it still
      * points to 'pathPtr'.
@@ -1938,18 +1934,14 @@
     iPtr = (Interp *) interp;
     oldScriptFile = iPtr->scriptFile;
     iPtr->scriptFile = pathPtr;
     Tcl_IncrRefCount(iPtr->scriptFile);
 
-    /*
-     * TIP #280: Force the evaluator to open a frame for a sourced file.
-     */
-
     iPtr->evalFlags |= TCL_EVAL_FILE;
     TclNRAddCallback(interp, EvalFileCallback, oldScriptFile, pathPtr, objPtr,
 	    NULL);
-    return TclNREvalObjEx(interp, objPtr, 0, NULL, INT_MIN);
+    return TclNREvalObjEx(interp, objPtr, 0);
 }
 
 static int
 EvalFileCallback(
     ClientData data[],

Index: generic/tclIndexObj.c
==================================================================
--- generic/tclIndexObj.c
+++ generic/tclIndexObj.c
@@ -963,17 +963,16 @@
 	    }
 	    flags = 0;
 	    len = TclScanElement(elementStr, elemLen, &flags);
 
 	    if (MAY_QUOTE_WORD && len != elemLen) {
-		char *quotedElementStr = TclStackAlloc(interp,
-			(unsigned)len + 1);
+		char *quotedElementStr = ckalloc((unsigned)len + 1);
 
 		len = TclConvertElement(elementStr, elemLen,
 			quotedElementStr, flags);
 		Tcl_AppendToObj(objPtr, quotedElementStr, len);
-		TclStackFree(interp, quotedElementStr);
+		ckfree(quotedElementStr);
 	    } else {
 		Tcl_AppendToObj(objPtr, elementStr, elemLen);
 	    }
 
 	    AFTER_FIRST_WORD;
@@ -1019,17 +1018,16 @@
 	    elementStr = TclGetStringFromObj(objv[i], &elemLen);
 	    flags = 0;
 	    len = TclScanElement(elementStr, elemLen, &flags);
 
 	    if (MAY_QUOTE_WORD && len != elemLen) {
-		char *quotedElementStr = TclStackAlloc(interp,
-			(unsigned) len + 1);
+		char *quotedElementStr = ckalloc((unsigned) len + 1);
 
 		len = TclConvertElement(elementStr, elemLen,
 			quotedElementStr, flags);
 		Tcl_AppendToObj(objPtr, quotedElementStr, len);
-		TclStackFree(interp, quotedElementStr);
+		ckfree(quotedElementStr);
 	    } else {
 		Tcl_AppendToObj(objPtr, elementStr, elemLen);
 	    }
 	}
 

Index: generic/tclInt.decls
==================================================================
--- generic/tclInt.decls
+++ generic/tclInt.decls
@@ -32,13 +32,13 @@
 #    int TclAccessDeleteProc(TclAccessProc_ *proc)
 #}
 #declare 2 {
 #    int TclAccessInsertProc(TclAccessProc_ *proc)
 #}
-declare 3 {
-    void TclAllocateFreeObjects(void)
-}
+#declare 3 {
+#    void TclAllocateFreeObjects(void)
+#}
 # Replaced by TclpChdir in 8.1:
 #  declare 4 {
 #      int TclChdir(Tcl_Interp *interp, char *dirName)
 #  }
 declare 5 {
@@ -287,13 +287,13 @@
 #}
 # Replaced by Tcl_FSAccess in 8.4:
 #declare 68 {
 #    int TclpAccess(const char *path, int mode)
 #}
-declare 69 {
-    char *TclpAlloc(unsigned int size)
-}
+#declare 69 {
+#    char *TclpAlloc(unsigned int size)
+#}
 #declare 70 {
 #    int TclpCopyFile(const char *source, const char *dest)
 #}
 #declare 71 {
 #    int TclpCopyDirectory(const char *source, const char *dest,
@@ -303,13 +303,13 @@
 #    int TclpCreateDirectory(const char *path)
 #}
 #declare 73 {
 #    int TclpDeleteFile(const char *path)
 #}
-declare 74 {
-    void TclpFree(char *ptr)
-}
+#declare 74 {
+#    void TclpFree(char *ptr)
+#}
 declare 75 {
     unsigned long TclpGetClicks(void)
 }
 declare 76 {
     unsigned long TclpGetSeconds(void)
@@ -330,13 +330,13 @@
 # Replaced by Tcl_FSOpenFileChannel in 8.4:
 #declare 80 {
 #    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName,
 #	    char *modeString, int permissions)
 #}
-declare 81 {
-    char *TclpRealloc(char *ptr, unsigned int size)
-}
+#declare 81 {
+#    char *TclpRealloc(char *ptr, unsigned int size)
+#}
 #declare 82 {
 #    int TclpRemoveDirectory(const char *path, int recursive,
 #	    Tcl_DString *errorPtr)
 #}
 #declare 83 {
@@ -868,16 +868,16 @@
     Tcl_Obj *TclGetObjNameOfExecutable(void)
 }
 declare 214 {
     void TclSetObjNameOfExecutable(Tcl_Obj *name, Tcl_Encoding encoding)
 }
-declare 215 {
-    void *TclStackAlloc(Tcl_Interp *interp, int numBytes)
-}
-declare 216 {
-    void TclStackFree(Tcl_Interp *interp, void *freePtr)
-}
+#declare 215 {
+#    void *TclStackAlloc(Tcl_Interp *interp, unsigned int numBytes)
+#}
+#declare 216 {
+#    void TclStackFree(Tcl_Interp *interp, void *freePtr)
+#}
 declare 217 {
     int TclPushStackFrame(Tcl_Interp *interp, Tcl_CallFrame **framePtrPtr,
             Tcl_Namespace *namespacePtr, int isProcCallFrame)
 }
 declare 218 {
@@ -892,13 +892,13 @@
 #
 declare 225 {
     Tcl_Obj *TclTraceDictPath(Tcl_Interp *interp, Tcl_Obj *rootPtr,
 	    int keyc, Tcl_Obj *const keyv[], int flags)
 }
-declare 226 {
-    int TclObjBeingDeleted(Tcl_Obj *objPtr)
-}
+#declare 226 {
+#    int TclObjBeingDeleted(Tcl_Obj *objPtr)
+#}
 declare 227 {
     void TclSetNsPath(Namespace *nsPtr, int pathLength,
             Tcl_Namespace *pathAry[])
 }
 #  Used to be needed for TclOO-extension; unneeded now that TclOO is in the
@@ -920,17 +920,17 @@
     int	TclGetNamespaceFromObj(Tcl_Interp *interp, Tcl_Obj *objPtr,
 	    Tcl_Namespace **nsPtrPtr)
 }
 
 # Bits and pieces of TIP#280's guts
-declare 232 {
-    int TclEvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr, int flags,
-	    const CmdFrame *invoker, int word)
-}
-declare 233 {
-    void TclGetSrcInfoForPc(CmdFrame *contextPtr)
-}
+#declare 232 {
+#    int TclEvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr, int flags,
+#	    const CmdFrame *invoker, int word)
+#}
+#declare 233 {
+#    void TclGetSrcInfoForPc(CmdFrame *contextPtr)
+#}
 
 # Exports for VarReform compat: Itcl, XOTcl like to peek into our varTables :(
 declare 234 {
     Var *TclVarHashCreateVar(TclVarHashTable *tablePtr, const char *key,
              int *newPtr)
@@ -963,12 +963,11 @@
 declare 240 {
     int TclNRRunCallbacks(Tcl_Interp *interp, int result,
 	      struct NRE_callback *rootPtr)
 }
 declare 241 {
-    int TclNREvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr, int flags,
-	    const CmdFrame *invoker, int word)
+    int TclNREvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr, int flags)
 }
 declare 242 {
     int TclNREvalObjv(Tcl_Interp *interp, int objc,
 	      Tcl_Obj *const objv[], int flags, Command *cmdPtr)
 }

Index: generic/tclInt.h
==================================================================
--- generic/tclInt.h
+++ generic/tclInt.h
@@ -8,11 +8,11 @@
  * Copyright (c) 1994-1998 Sun Microsystems, Inc.
  * Copyright (c) 1998-1999 by Scriptics Corporation.
  * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
  * Copyright (c) 2007 Daniel A. Steffen <das@users.sourceforge.net>
  * Copyright (c) 2006-2008 by Joe Mistachkin.  All rights reserved.
- * Copyright (c) 2008 by Miguel Sofer. All rights reserved.
+ * Copyright (c) 2008-2011 by Miguel Sofer. All rights reserved.
  *
  * See the file "license.terms" for information on usage and redistribution of
  * this file, and for a DISCLAIMER OF ALL WARRANTIES.
  */
 
@@ -1167,196 +1167,10 @@
 				 * the [oo::define] command; the clientData
 				 * field contains an Object reference that has
 				 * been confirmed to refer to a class. Part of
 				 * TIP#257. */
 
-/*
- * TIP #280
- * The structure below defines a command frame. A command frame provides
- * location information for all commands executing a tcl script (source, eval,
- * uplevel, procedure bodies, ...). The runtime structure essentially contains
- * the stack trace as it would be if the currently executing command were to
- * throw an error.
- *
- * For commands where it makes sense it refers to the associated CallFrame as
- * well.
- *
- * The structures are chained in a single list, with the top of the stack
- * anchored in the Interp structure.
- *
- * Instances can be allocated on the C stack, or the heap, the former making
- * cleanup a bit simpler.
- */
-
-typedef struct CmdFrame {
-    /*
-     * General data. Always available.
-     */
-
-    int type;			/* Values see below. */
-    int level;			/* Number of frames in stack, prevent O(n)
-				 * scan of list. */
-    int *line;			/* Lines the words of the command start on. */
-    int nline;
-    CallFrame *framePtr;	/* Procedure activation record, may be
-				 * NULL. */
-    struct CmdFrame *nextPtr;	/* Link to calling frame. */
-    /*
-     * Data needed for Eval vs TEBC
-     *
-     * EXECUTION CONTEXTS and usage of CmdFrame
-     *
-     * Field	  TEBC		  EvalEx	  EvalObjEx
-     * =======	  ====		  ======	  =========
-     * level	  yes		  yes		  yes
-     * type	  BC/PREBC	  SRC/EVAL	  EVAL_LIST
-     * line0	  yes		  yes		  yes
-     * framePtr	  yes		  yes		  yes
-     * =======	  ====		  ======	  =========
-     *
-     * =======	  ====		  ======	  ========= union data
-     * line1	  -		  yes		  -
-     * line3	  -		  yes		  -
-     * path	  -		  yes		  -
-     * -------	  ----		  ------	  ---------
-     * codePtr	  yes		  -		  -
-     * pc	  yes		  -		  -
-     * =======	  ====		  ======	  =========
-     *
-     * =======	  ====		  ======	  ========= | union cmd
-     * listPtr	  -		  -		  yes	    |
-     * -------	  ----		  ------	  --------- |
-     * cmd	  yes		  yes		  -	    |
-     * cmdlen	  yes		  yes		  -	    |
-     * -------	  ----		  ------	  --------- |
-     */
-
-    union {
-	struct {
-	    Tcl_Obj *path;	/* Path of the sourced file the command is
-				 * in. */
-	} eval;
-	struct {
-	    const void *codePtr;/* Byte code currently executed... */
-	    const char *pc;	/* ... and instruction pointer. */
-	} tebc;
-    } data;
-    union {
-	struct {
-	    const char *cmd;	/* The executed command, if possible... */
-	    int len;		/* ... and its length. */
-	} str;
-	Tcl_Obj *listPtr;	/* Tcl_EvalObjEx, cmd list. */
-    } cmd;
-    int numLevels;		/* Value of interp's numLevels when the frame
-				 * was pushed. */
-    const struct CFWordBC *litarg;
-				/* Link to set of literal arguments which have
-				 * ben pushed on the lineLABCPtr stack by
-				 * TclArgumentBCEnter(). These will be removed
-				 * by TclArgumentBCRelease. */
-} CmdFrame;
-
-typedef struct CFWord {
-    CmdFrame *framePtr;		/* CmdFrame to access. */
-    int word;			/* Index of the word in the command. */
-    int refCount;		/* Number of times the word is on the
-				 * stack. */
-} CFWord;
-
-typedef struct CFWordBC {
-    CmdFrame *framePtr;		/* CmdFrame to access. */
-    int pc;			/* Instruction pointer of a command in
-				 * ExtCmdLoc.loc[.] */
-    int word;			/* Index of word in
-				 * ExtCmdLoc.loc[cmd]->line[.] */
-    struct CFWordBC *prevPtr;	/* Previous entry in stack for same Tcl_Obj. */
-    struct CFWordBC *nextPtr;	/* Next entry for same command call. See
-				 * CmdFrame litarg field for the list start. */
-    Tcl_Obj *obj;		/* Back reference to hashtable key */
-} CFWordBC;
-
-/*
- * Structure to record the locations of invisible continuation lines in
- * literal scripts, as character offset from the beginning of the script. Both
- * compiler and direct evaluator use this information to adjust their line
- * counters when tracking through the script, because when it is invoked the
- * continuation line marker as a whole has been removed already, meaning that
- * the \n which was part of it is gone as well, breaking regular line
- * tracking.
- *
- * These structures are allocated and filled by both the function
- * TclSubstTokens() in the file "tclParse.c" and its caller TclEvalEx() in the
- * file "tclBasic.c", and stored in the thread-global hashtable "lineCLPtr" in
- * file "tclObj.c". They are used by the functions TclSetByteCodeFromAny() and
- * TclCompileScript(), both found in the file "tclCompile.c". Their memory is
- * released by the function TclFreeObj(), in the file "tclObj.c", and also by
- * the function TclThreadFinalizeObjects(), in the same file.
- */
-
-#define CLL_END		(-1)
-
-typedef struct ContLineLoc {
-    int num;			/* Number of entries in loc, not counting the
-				 * final -1 marker entry. */
-    int loc[1];			/* Table of locations, as character offsets.
-				 * The table is allocated as part of the
-				 * structure, extending behind the nominal end
-				 * of the structure. An entry containing the
-				 * value -1 is put after the last location, as
-				 * end-marker/sentinel. */
-} ContLineLoc;
-
-/*
- * The following macros define the allowed values for the type field of the
- * CmdFrame structure above. Some of the values occur only in the extended
- * location data referenced via the 'baseLocPtr'.
- *
- * TCL_LOCATION_EVAL	  : Frame is for a script evaluated by EvalEx.
- * TCL_LOCATION_EVAL_LIST : Frame is for a script evaluated by the list
- *			    optimization path of EvalObjEx.
- * TCL_LOCATION_BC	  : Frame is for bytecode.
- * TCL_LOCATION_PREBC	  : Frame is for precompiled bytecode.
- * TCL_LOCATION_SOURCE	  : Frame is for a script evaluated by EvalEx, from a
- *			    sourced file.
- * TCL_LOCATION_PROC	  : Frame is for bytecode of a procedure.
- *
- * A TCL_LOCATION_BC type in a frame can be overridden by _SOURCE and _PROC
- * types, per the context of the byte code in execution.
- */
-
-#define TCL_LOCATION_EVAL	(0) /* Location in a dynamic eval script. */
-#define TCL_LOCATION_EVAL_LIST	(1) /* Location in a dynamic eval script,
-				     * list-path. */
-#define TCL_LOCATION_BC		(2) /* Location in byte code. */
-#define TCL_LOCATION_PREBC	(3) /* Location in precompiled byte code, no
-				     * location. */
-#define TCL_LOCATION_SOURCE	(4) /* Location in a file. */
-#define TCL_LOCATION_PROC	(5) /* Location in a dynamic proc. */
-#define TCL_LOCATION_LAST	(6) /* Number of values in the enum. */
-
-/*
- * Structure passed to describe procedure-like "procedures" that are not
- * procedures (e.g. a lambda) so that their details can be reported correctly
- * by [info frame]. Contains a sub-structure for each extra field.
- */
-
-typedef Tcl_Obj * (GetFrameInfoValueProc)(ClientData clientData);
-typedef struct {
-    const char *name;		/* Name of this field. */
-    GetFrameInfoValueProc *proc;	/* Function to generate a Tcl_Obj* from the
-				 * clientData, or just use the clientData
-				 * directly (after casting) if NULL. */
-    ClientData clientData;	/* Context for above function, or Tcl_Obj* if
-				 * proc field is NULL. */
-} ExtraFrameInfoField;
-typedef struct {
-    int length;			/* Length of array. */
-    ExtraFrameInfoField fields[2];
-				/* Really as long as necessary, but this is
-				 * long enough for nearly anything. */
-} ExtraFrameInfo;
 
 /*
  *----------------------------------------------------------------
  * Data structures and procedures related to TclHandles, which are a very
  * lightweight method of preserving enough information to determine if an
@@ -1391,17 +1205,10 @@
  */
 
 #define TCL_TSD_INIT(keyPtr) \
   (ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))
 
-/*
- *----------------------------------------------------------------
- * Data structures related to bytecode compilation and execution. These are
- * used primarily in tclCompile.c, tclExecute.c, and tclBasic.c.
- *----------------------------------------------------------------
- */
-
 /*
  * Forward declaration to prevent errors when the forward references to
  * Tcl_Parse and CompileEnv are encountered in the procedure type CompileProc
  * declared below.
  */
@@ -1439,23 +1246,10 @@
  */
 
 typedef int (CompileHookProc)(Tcl_Interp *interp,
 	struct CompileEnv *compEnvPtr, ClientData clientData);
 
-/*
- * The data structure for a (linked list of) execution stacks.
- */
-
-typedef struct ExecStack {
-    struct ExecStack *prevPtr;
-    struct ExecStack *nextPtr;
-    Tcl_Obj **markerPtr;
-    Tcl_Obj **endPtr;
-    Tcl_Obj **tosPtr;
-    Tcl_Obj *stackWords[1];
-} ExecStack;
-
 /*
  * The data structure defining the execution environment for ByteCode's.
  * There is one ExecEnv structure per Tcl interpreter. It holds the evaluation
  * stack that holds command operands and results. The stack grows towards
  * increasing addresses. The member stackPtr points to the stackItems of the
@@ -1463,12 +1257,10 @@
  */
 
 typedef struct CorContext {
     struct CallFrame *framePtr;
     struct CallFrame *varFramePtr;
-    struct CmdFrame *cmdFramePtr;  /* See Interp.cmdFramePtr */
-    Tcl_HashTable *lineLABCPtr;    /* See Interp.lineLABCPtr */
 } CorContext;
 
 typedef struct CoroutineData {
     struct Command *cmdPtr;	/* The command handle for the coroutine. */
     struct ExecEnv *eePtr;	/* The special execution environment (stacks,
@@ -1489,12 +1281,10 @@
 				 * coroutine; -2 means "0 or 1" (default), -1
 				 * means "any" */
 } CoroutineData;
 
 typedef struct ExecEnv {
-    ExecStack *execStackPtr;	/* Points to the first item in the evaluation
-				 * stack on the heap. */
     Tcl_Obj *constants[2];	/* Pointers to constant "0" and "1" objs. */
     struct Tcl_Interp *interp;
     struct NRE_callback *callbackPtr;
 				/* Top callback in NRE's stack. */
     struct CoroutineData *corPtr;
@@ -1769,28 +1559,10 @@
 
 enum PkgPreferOptions {
     PKG_PREFER_LATEST, PKG_PREFER_STABLE
 };
 
-/*
- *----------------------------------------------------------------
- * This structure shadows the first few fields of the memory cache for the
- * allocator defined in tclThreadAlloc.c; it has to be kept in sync with the
- * definition there.
- * Some macros require knowledge of some fields in the struct in order to
- * avoid hitting the TSD unnecessarily. In order to facilitate this, a pointer
- * to the relevant fields is kept in the objCache field in struct Interp.
- *----------------------------------------------------------------
- */
-
-typedef struct AllocCache {
-    struct Cache *nextPtr;	/* Linked list of cache entries. */
-    Tcl_ThreadId owner;		/* Which thread's cache is this? */
-    Tcl_Obj *firstObjPtr;	/* List of free objects for thread. */
-    int numObjects;		/* Number of objects for thread. */
-} AllocCache;
-
 /*
  *----------------------------------------------------------------
  * This structure defines an interpreter, which is a collection of commands
  * plus other state information related to interpreting commands, such as
  * variable storage. Primary responsibility for this data structure is in
@@ -2045,58 +1817,10 @@
 				 * This information, if present (chanMsg not
 				 * NULL), takes precedence over a POSIX error
 				 * code returned by a channel operation. */
 
     /*
-     * Source code origin information (TIP #280).
-     */
-
-    CmdFrame *cmdFramePtr;	/* Points to the command frame containing the
-				 * location information for the current
-				 * command. */
-    const CmdFrame *invokeCmdFramePtr;
-				/* Points to the command frame which is the
-				 * invoking context of the bytecode compiler.
-				 * NULL when the byte code compiler is not
-				 * active. */
-    int invokeWord;		/* Index of the word in the command which
-				 * is getting compiled. */
-    Tcl_HashTable *linePBodyPtr;/* This table remembers for each statically
-				 * defined procedure the location information
-				 * for its body. It is keyed by the address of
-				 * the Proc structure for a procedure. The
-				 * values are "struct CmdFrame*". */
-    Tcl_HashTable *lineBCPtr;	/* This table remembers for each ByteCode
-				 * object the location information for its
-				 * body. It is keyed by the address of the
-				 * Proc structure for a procedure. The values
-				 * are "struct ExtCmdLoc*". (See
-				 * tclCompile.h) */
-    Tcl_HashTable *lineLABCPtr;
-    Tcl_HashTable *lineLAPtr;	/* This table remembers for each argument of a
-				 * command on the execution stack the index of
-				 * the argument in the command, and the
-				 * location data of the command. It is keyed
-				 * by the address of the Tcl_Obj containing
-				 * the argument. The values are "struct
-				 * CFWord*" (See tclBasic.c). This allows
-				 * commands like uplevel, eval, etc. to find
-				 * location information for their arguments,
-				 * if they are a proper literal argument to an
-				 * invoking command. Alt view: An index to the
-				 * CmdFrame stack keyed by command argument
-				 * holders. */
-    ContLineLoc *scriptCLLocPtr;/* This table points to the location data for
-				 * invisible continuation lines in the script,
-				 * if any. This pointer is set by the function
-				 * TclEvalObjEx() in file "tclBasic.c", and
-				 * used by function ...() in the same file.
-				 * It does for the eval/direct path of script
-				 * execution what CompileEnv.clLoc does for
-				 * the bytecode compiler.
-				 */
-    /*
      * TIP #268. The currently active selection mode, i.e. the package require
      * preferences.
      */
 
     int packagePrefer;		/* Current package selection mode. */
@@ -2120,14 +1844,10 @@
      * inherit the value.
      *
      * They are used by the macros defined below.
      */
 
-    AllocCache *allocCache;
-    void *pendingObjDataPtr;	/* Pointer to the Cache and PendingObjData
-				 * structs for this interp's thread; see
-				 * tclObj.c and tclThreadAlloc.c */
     int *asyncReadyPtr;		/* Pointer to the asyncReady indicator for
 				 * this interp's thread; see tclAsync.c */
     /*
      * The pointer to the object system root ekeko. c.f. TIP #257.
      */
@@ -2174,10 +1894,11 @@
      */
 
     ByteCodeStats stats;	/* Holds compilation and execution statistics
 				 * for this interpreter. */
 #endif /* TCL_COMPILE_STATS */
+    Tcl_Obj *cmdSourcePtr;      /* Command source obj, used for command traces */
 } Interp;
 
 /*
  * Macros that use the TSD-ekeko.
  */
@@ -2352,21 +2073,10 @@
  * isspace.
  */
 
 #define UCHAR(c) ((unsigned char) (c))
 
-/*
- * This macro is used to properly align the memory allocated by Tcl, giving
- * the same alignment as the native malloc.
- */
-
-#if defined(__APPLE__)
-#define TCL_ALLOCALIGN	16
-#else
-#define TCL_ALLOCALIGN	(2*sizeof(void *))
-#endif
-
 /*
  * This macro is used to determine the offset needed to safely allocate any
  * data structure in memory. Given a starting offset or size, it "rounds up"
  * or "aligns" the offset to the next 8-byte boundary so that any data
  * structure can be placed at the resulting offset without fear of an
@@ -2749,17 +2459,10 @@
 MODULE_SCOPE const Tcl_HashKeyType tclArrayHashKeyType;
 MODULE_SCOPE const Tcl_HashKeyType tclOneWordHashKeyType;
 MODULE_SCOPE const Tcl_HashKeyType tclStringHashKeyType;
 MODULE_SCOPE const Tcl_HashKeyType tclObjHashKeyType;
 
-/*
- * The head of the list of free Tcl objects, and the total number of Tcl
- * objects ever allocated and freed.
- */
-
-MODULE_SCOPE Tcl_Obj *	tclFreeObjList;
-
 #ifdef TCL_COMPILE_STATS
 MODULE_SCOPE long	tclObjsAlloced;
 MODULE_SCOPE long	tclObjsFreed;
 #define TCL_MAX_SHARED_OBJ_STATS 5
 MODULE_SCOPE long	tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
@@ -2806,11 +2509,11 @@
 MODULE_SCOPE Tcl_ObjCmdProc TclNRYieldToObjCmd;
 
 MODULE_SCOPE void  TclSpliceTailcall(Tcl_Interp *interp,
 	               struct NRE_callback *tailcallPtr);
 
-/*
+/* //
  * This structure holds the data for the various iteration callbacks used to
  * NRE the 'for' and 'while' commands. We need a separate structure because we
  * have more than the 4 client data entries we can provide directly thorugh
  * the callback API. It is the 'word' information which puts us over the
  * limit. It is needed because the loop body is argument 4 of 'for' and
@@ -2821,11 +2524,10 @@
 typedef struct ForIterData {
     Tcl_Obj *cond;		/* Loop condition expression. */
     Tcl_Obj *body;		/* Loop body. */
     Tcl_Obj *next;		/* Loop step script, NULL for 'while'. */
     const char *msg;		/* Error message part. */
-    int word;			/* Index of the body script in the command */
 } ForIterData;
 
 /* TIP #357 - Structure doing the bookkeeping of handles for Tcl_LoadFile
  *            and Tcl_FindSymbol. This structure corresponds to an opaque
  *            typedef in tcl.h */
@@ -2880,25 +2582,10 @@
 MODULE_SCOPE void	TclAppendBytesToByteArray(Tcl_Obj *objPtr,
 			    const unsigned char *bytes, int len);
 MODULE_SCOPE int	TclNREvalCmd(Tcl_Interp *interp, Tcl_Obj *objPtr,
 			    int flags);
 MODULE_SCOPE void	TclPushTailcallPoint(Tcl_Interp *interp);
-MODULE_SCOPE void	TclAdvanceContinuations(int *line, int **next,
-			    int loc);
-MODULE_SCOPE void	TclAdvanceLines(int *line, const char *start,
-			    const char *end);
-MODULE_SCOPE void	TclArgumentEnter(Tcl_Interp *interp,
-			    Tcl_Obj *objv[], int objc, CmdFrame *cf);
-MODULE_SCOPE void	TclArgumentRelease(Tcl_Interp *interp,
-			    Tcl_Obj *objv[], int objc);
-MODULE_SCOPE void	TclArgumentBCEnter(Tcl_Interp *interp,
-			    Tcl_Obj *objv[], int objc,
-			    void *codePtr, CmdFrame *cfPtr, int pc);
-MODULE_SCOPE void	TclArgumentBCRelease(Tcl_Interp *interp,
-			    CmdFrame *cfPtr);
-MODULE_SCOPE void	TclArgumentGet(Tcl_Interp *interp, Tcl_Obj *obj,
-			    CmdFrame **cfPtrPtr, int *wordPtr);
 MODULE_SCOPE int	TclArraySet(Tcl_Interp *interp,
 			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj);
 MODULE_SCOPE double	TclBignumToDouble(const mp_int *bignum);
 MODULE_SCOPE int	TclByteArrayMatch(const unsigned char *string,
 			    int strLen, const unsigned char *pattern,
@@ -2909,24 +2596,13 @@
 MODULE_SCOPE int	TclChanCaughtErrorBypass(Tcl_Interp *interp,
 			    Tcl_Channel chan);
 MODULE_SCOPE Tcl_ObjCmdProc TclChannelNamesCmd;
 MODULE_SCOPE int	TclClearRootEnsemble(ClientData data[],
 			    Tcl_Interp *interp, int result);
-MODULE_SCOPE ContLineLoc *TclContinuationsEnter(Tcl_Obj *objPtr, int num,
-			    int *loc);
-MODULE_SCOPE void	TclContinuationsEnterDerived(Tcl_Obj *objPtr,
-			    int start, int *clNext);
-MODULE_SCOPE ContLineLoc *TclContinuationsGet(Tcl_Obj *objPtr);
-MODULE_SCOPE void	TclContinuationsCopy(Tcl_Obj *objPtr,
-			    Tcl_Obj *originObjPtr);
 MODULE_SCOPE int	TclConvertElement(const char *src, int length,
 			    char *dst, int flags);
 MODULE_SCOPE void	TclDeleteNamespaceVars(Namespace *nsPtr);
-/* TIP #280 - Modified token based evulation, with line information. */
-MODULE_SCOPE int	TclEvalEx(Tcl_Interp *interp, const char *script,
-			    int numBytes, int flags, int line,
-			    int *clNextOuter, const char *outerScript);
 MODULE_SCOPE Tcl_ObjCmdProc TclFileAttrsCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclFileCopyCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclFileDeleteCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclFileLinkCmd;
 MODULE_SCOPE Tcl_ObjCmdProc TclFileMakeDirsCmd;
@@ -2940,11 +2616,10 @@
 MODULE_SCOPE char *	TclDStringAppendObj(Tcl_DString *dsPtr,
 			    Tcl_Obj *objPtr);
 MODULE_SCOPE char *	TclDStringAppendDString(Tcl_DString *dsPtr,
 			    Tcl_DString *toAppendPtr);
 MODULE_SCOPE Tcl_Obj *	TclDStringToObj(Tcl_DString *dsPtr);
-MODULE_SCOPE void	TclFinalizeAllocSubsystem(void);
 MODULE_SCOPE void	TclFinalizeAsync(void);
 MODULE_SCOPE void	TclFinalizeDoubleConversion(void);
 MODULE_SCOPE void	TclFinalizeEncodingSubsystem(void);
 MODULE_SCOPE void	TclFinalizeEnvironment(void);
 MODULE_SCOPE void	TclFinalizeEvaluation(void);
@@ -2957,11 +2632,10 @@
 MODULE_SCOPE void	TclFinalizeMemorySubsystem(void);
 MODULE_SCOPE void	TclFinalizeNotifier(void);
 MODULE_SCOPE void	TclFinalizeObjects(void);
 MODULE_SCOPE void	TclFinalizePreserve(void);
 MODULE_SCOPE void	TclFinalizeSynchronization(void);
-MODULE_SCOPE void	TclFinalizeThreadAlloc(void);
 MODULE_SCOPE void	TclFinalizeThreadData(void);
 MODULE_SCOPE void	TclFinalizeThreadObjects(void);
 MODULE_SCOPE double	TclFloor(const mp_int *a);
 MODULE_SCOPE void	TclFormatNaN(double value, char *buffer);
 MODULE_SCOPE int	TclFSFileAttrIndex(Tcl_Obj *pathPtr,
@@ -2981,11 +2655,10 @@
 			    int *typePtr);
 MODULE_SCOPE int	TclGetOpenModeEx(Tcl_Interp *interp,
 			    const char *modeString, int *seekFlagPtr,
 			    int *binaryPtr);
 MODULE_SCOPE Tcl_Obj *	TclGetProcessGlobalValue(ProcessGlobalValue *pgvPtr);
-MODULE_SCOPE const char *TclGetSrcInfoForCmd(Interp *iPtr, int *lenPtr);
 MODULE_SCOPE int	TclGlob(Tcl_Interp *interp, char *pattern,
 			    Tcl_Obj *unquotedPrefix, int globFlags,
 			    Tcl_GlobTypeData *types);
 MODULE_SCOPE int	TclIncrObj(Tcl_Interp *interp, Tcl_Obj *valuePtr,
 			    Tcl_Obj *incrPtr);
@@ -2993,18 +2666,16 @@
 			    Tcl_Obj *part2Ptr, Tcl_Obj *incrPtr, int flags);
 MODULE_SCOPE int	TclInfoExistsCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
 MODULE_SCOPE int	TclInfoCoroutineCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
-MODULE_SCOPE Tcl_Obj *	TclInfoFrame(Tcl_Interp *interp, CmdFrame *framePtr);
 MODULE_SCOPE int	TclInfoGlobalsCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
 MODULE_SCOPE int	TclInfoLocalsCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
 MODULE_SCOPE int	TclInfoVarsCmd(ClientData dummy, Tcl_Interp *interp,
 			    int objc, Tcl_Obj *const objv[]);
-MODULE_SCOPE void	TclInitAlloc(void);
 MODULE_SCOPE void	TclInitDbCkalloc(void);
 MODULE_SCOPE void	TclInitDoubleConversion(void);
 MODULE_SCOPE void	TclInitEmbeddedConfigurationInformation(
 			    Tcl_Interp *interp);
 MODULE_SCOPE void	TclInitEncodingSubsystem(void);
@@ -3136,28 +2807,24 @@
 			    Command *cmdPtr);
 MODULE_SCOPE void	TclSetDuplicateObj(Tcl_Obj *dupPtr, Tcl_Obj *objPtr);
 MODULE_SCOPE void	TclSetProcessGlobalValue(ProcessGlobalValue *pgvPtr,
 			    Tcl_Obj *newValue, Tcl_Encoding encoding);
 MODULE_SCOPE void	TclSignalExitThread(Tcl_ThreadId id, int result);
-MODULE_SCOPE void *	TclStackRealloc(Tcl_Interp *interp, void *ptr,
-			    int numBytes);
 MODULE_SCOPE int	TclStringMatch(const char *str, int strLen,
 			    const char *pattern, int ptnLen, int flags);
 MODULE_SCOPE int	TclStringMatchObj(Tcl_Obj *stringObj,
 			    Tcl_Obj *patternObj, int flags);
 MODULE_SCOPE Tcl_Obj *	TclStringObjReverse(Tcl_Obj *objPtr);
 MODULE_SCOPE void	TclSubstCompile(Tcl_Interp *interp, const char *bytes,
-			    int numBytes, int flags, int line,
-			    struct CompileEnv *envPtr);
+			    int numBytes, int flags, struct CompileEnv *envPtr);
 MODULE_SCOPE int	TclSubstOptions(Tcl_Interp *interp, int numOpts,
 			    Tcl_Obj *const opts[], int *flagPtr);
 MODULE_SCOPE void	TclSubstParse(Tcl_Interp *interp, const char *bytes,
 			    int numBytes, int flags, Tcl_Parse *parsePtr,
 			    Tcl_InterpState *statePtr);
 MODULE_SCOPE int	TclSubstTokens(Tcl_Interp *interp, Tcl_Token *tokenPtr,
-			    int count, int *tokensLeftPtr, int line,
-			    int *clNextOuter, const char *outerScript);
+			    int count, int *tokensLeftPtr);
 MODULE_SCOPE int	TclTrimLeft(const char *bytes, int numBytes,
 			    const char *trim, int numTrim);
 MODULE_SCOPE int	TclTrimRight(const char *bytes, int numBytes,
 			    const char *trim, int numTrim);
 MODULE_SCOPE Tcl_Obj *	TclpNativeToNormalized(ClientData clientData);
@@ -3255,19 +2922,10 @@
 MODULE_SCOPE Tcl_Obj *	TclDictWithInit(Tcl_Interp *interp, Tcl_Obj *dictPtr,
 			    int pathc, Tcl_Obj *const pathv[]);
 MODULE_SCOPE int	Tcl_DisassembleObjCmd(ClientData clientData,
 			    Tcl_Interp *interp, int objc,
 			    Tcl_Obj *const objv[]);
-			    
-/* Assemble command function */			    
-MODULE_SCOPE int	Tcl_AssembleObjCmd(ClientData clientData,
-			    Tcl_Interp *interp, int objc,
-			    Tcl_Obj *const objv[]);			    
-MODULE_SCOPE int	TclNRAssembleObjCmd(ClientData clientData,
-			    Tcl_Interp *interp, int objc,
-			    Tcl_Obj *const objv[]);			    
-			    
 MODULE_SCOPE int	Tcl_EncodingObjCmd(ClientData clientData,
 			    Tcl_Interp *interp, int objc,
 			    Tcl_Obj *const objv[]);
 MODULE_SCOPE int	Tcl_EofObjCmd(ClientData clientData,
 			    Tcl_Interp *interp, int objc,
@@ -3994,14 +3652,14 @@
 #  define TclIncrObjsAllocated()
 #  define TclIncrObjsFreed()
 #endif /* TCL_COMPILE_STATS */
 
 #  define TclAllocObjStorage(objPtr)		\
-	TclAllocObjStorageEx(NULL, (objPtr))
+    (objPtr) = TclSmallAlloc()
 
 #  define TclFreeObjStorage(objPtr)		\
-	TclFreeObjStorageEx(NULL, (objPtr))
+    TclSmallFree(objPtr)
 
 #ifndef TCL_MEM_DEBUG
 # define TclNewObj(objPtr) \
     TclIncrObjsAllocated(); \
     TclAllocObjStorage(objPtr); \
@@ -4032,116 +3690,10 @@
 	} else { \
 	    TclFreeObj(objPtr); \
 	} \
     }
 
-#if defined(PURIFY)
-
-/*
- * The PURIFY mode is like the regular mode, but instead of doing block
- * Tcl_Obj allocation and keeping a freed list for efficiency, it always
- * allocates and frees a single Tcl_Obj so that tools like Purify can better
- * track memory leaks.
- */
-
-#  define TclAllocObjStorageEx(interp, objPtr) \
-	(objPtr) = (Tcl_Obj *) ckalloc(sizeof(Tcl_Obj))
-
-#  define TclFreeObjStorageEx(interp, objPtr) \
-	ckfree((char *) (objPtr))
-
-#undef USE_THREAD_ALLOC
-#undef USE_TCLALLOC
-#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)
-
-/*
- * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's from
- * per-thread caches.
- */
-
-MODULE_SCOPE Tcl_Obj *	TclThreadAllocObj(void);
-MODULE_SCOPE void	TclThreadFreeObj(Tcl_Obj *);
-MODULE_SCOPE Tcl_Mutex *TclpNewAllocMutex(void);
-MODULE_SCOPE void	TclFreeAllocCache(void *);
-MODULE_SCOPE void *	TclpGetAllocCache(void);
-MODULE_SCOPE void	TclpSetAllocCache(void *);
-MODULE_SCOPE void	TclpFreeAllocMutex(Tcl_Mutex *mutex);
-MODULE_SCOPE void	TclpFreeAllocCache(void *);
-
-/*
- * These macros need to be kept in sync with the code of TclThreadAllocObj()
- * and TclThreadFreeObj().
- *
- * Note that the optimiser should resolve the case (interp==NULL) at compile
- * time.
- */
-
-#  define ALLOC_NOBJHIGH 1200
-
-#  define TclAllocObjStorageEx(interp, objPtr)				\
-    do {								\
-	AllocCache *cachePtr;						\
-	if (((interp) == NULL) ||					\
-		((cachePtr = ((Interp *)(interp))->allocCache),		\
-			(cachePtr->numObjects == 0))) {			\
-	    (objPtr) = TclThreadAllocObj();				\
-	} else {							\
-	    (objPtr) = cachePtr->firstObjPtr;				\
-	    cachePtr->firstObjPtr = (objPtr)->internalRep.otherValuePtr; \
-	    --cachePtr->numObjects;					\
-	}								\
-    } while (0)
-
-#  define TclFreeObjStorageEx(interp, objPtr)				\
-    do {								\
-	AllocCache *cachePtr;						\
-	if (((interp) == NULL) ||					\
-		((cachePtr = ((Interp *)(interp))->allocCache),		\
-			(cachePtr->numObjects >= ALLOC_NOBJHIGH))) {	\
-	    TclThreadFreeObj(objPtr);					\
-	} else {							\
-	    (objPtr)->internalRep.otherValuePtr = cachePtr->firstObjPtr; \
-	    cachePtr->firstObjPtr = objPtr;				\
-	    ++cachePtr->numObjects;					\
-	}								\
-    } while (0)
-
-#else /* not PURIFY or USE_THREAD_ALLOC */
-
-#if defined(USE_TCLALLOC) && USE_TCLALLOC
-    MODULE_SCOPE void TclFinalizeAllocSubsystem();
-    MODULE_SCOPE void TclInitAlloc();
-#else
-#   define USE_TCLALLOC 0
-#endif
-
-#ifdef TCL_THREADS
-/* declared in tclObj.c */
-MODULE_SCOPE Tcl_Mutex	tclObjMutex;
-#endif
-
-#  define TclAllocObjStorageEx(interp, objPtr) \
-    do {								\
-	Tcl_MutexLock(&tclObjMutex);					\
-	if (tclFreeObjList == NULL) {					\
-	    TclAllocateFreeObjects();					\
-	}								\
-	(objPtr) = tclFreeObjList;					\
-	tclFreeObjList = (Tcl_Obj *)					\
-		tclFreeObjList->internalRep.otherValuePtr;		\
-	Tcl_MutexUnlock(&tclObjMutex);					\
-    } while (0)
-
-#  define TclFreeObjStorageEx(interp, objPtr) \
-    do {							       \
-	Tcl_MutexLock(&tclObjMutex);				       \
-	(objPtr)->internalRep.otherValuePtr = (void *) tclFreeObjList; \
-	tclFreeObjList = (objPtr);				       \
-	Tcl_MutexUnlock(&tclObjMutex);				       \
-    } while (0)
-#endif
-
 #else /* TCL_MEM_DEBUG */
 MODULE_SCOPE void	TclDbInitNewObj(Tcl_Obj *objPtr, const char *file,
 			    int line);
 
 # define TclDbNewObj(objPtr, file, line) \
@@ -4160,12 +3712,58 @@
     Tcl_DbDecrRefCount(objPtr, __FILE__, __LINE__)
 
 # define TclNewListObjDirect(objc, objv) \
     TclDbNewListObjDirect(objc, objv, __FILE__, __LINE__)
 
-#undef USE_THREAD_ALLOC
 #endif /* TCL_MEM_DEBUG */
+
+/*
+ * Macros that drive the allocator behaviour
+ */
+
+#if defined(TCL_THREADS)
+/*
+ * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's from
+ * per-thread caches.
+ */
+MODULE_SCOPE void	TclpFreeAllocCache(void *);
+MODULE_SCOPE void *	TclpGetAllocCache(void);
+MODULE_SCOPE void	TclpSetAllocCache(void *);
+MODULE_SCOPE void	TclFreeAllocCache(void *);
+MODULE_SCOPE void	TclpFreeAllocMutex(Tcl_Mutex *mutex);
+MODULE_SCOPE Tcl_Mutex *TclpNewAllocMutex(void);
+#endif
+
+MODULE_SCOPE void * TclSmallAlloc();
+MODULE_SCOPE void   TclSmallFree(void *ptr);
+MODULE_SCOPE void   TclInitAlloc(void);
+MODULE_SCOPE void   TclFinalizeAlloc(void);
+
+#define TclCkSmallAlloc(nbytes, memPtr)					\
+    do {								\
+	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
+	memPtr = TclSmallAlloc();					\
+    } while (0)
+
+/*
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
+ */
+
+#if defined(PURIFY) && defined(__clang__)
+#if __has_feature(attribute_analyzer_noreturn) && \
+       !defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
+void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
+#endif
+#if !defined(CLANG_ASSERT)
+#include <assert.h>
+#define CLANG_ASSERT(x) assert(x)
+#endif
+#elif !defined(CLANG_ASSERT)
+ #define CLANG_ASSERT(x)
+#endif /* PURIFY && __clang__ */
+
+
 
 /*
  *----------------------------------------------------------------
  * Macro used by the Tcl core to set a Tcl_Obj's string representation to a
  * copy of the "len" bytes starting at "bytePtr". This code works even if the
@@ -4698,77 +4296,15 @@
 
 #define TCL_CT_ASSERT(e) \
     {enum { ct_assert_value = 1/(!!(e)) };}
 
 /*
- *----------------------------------------------------------------
- * Allocator for small structs (<=sizeof(Tcl_Obj)) using the Tcl_Obj pool.
- * Only checked at compile time.
- *
- * ONLY USE FOR CONSTANT nBytes.
- *
- * DO NOT LET THEM CROSS THREAD BOUNDARIES
- *----------------------------------------------------------------
+ * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
  */
 
-#define TclSmallAlloc(nbytes, memPtr) \
-    TclSmallAllocEx(NULL, (nbytes), (memPtr))
-
-#define TclSmallFree(memPtr) \
-    TclSmallFreeEx(NULL, (memPtr))
-
-#ifndef TCL_MEM_DEBUG
-#define TclSmallAllocEx(interp, nbytes, memPtr) \
-    do {								\
-	Tcl_Obj *objPtr;						\
-	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
-	TclIncrObjsAllocated();						\
-	TclAllocObjStorageEx((interp), (objPtr));			\
-	memPtr = (ClientData) (objPtr);					\
-    } while (0)
-
-#define TclSmallFreeEx(interp, memPtr) \
-    do {								\
-	TclFreeObjStorageEx((interp), (Tcl_Obj *) (memPtr));		\
-	TclIncrObjsFreed();						\
-    } while (0)
-
-#else    /* TCL_MEM_DEBUG */
-#define TclSmallAllocEx(interp, nbytes, memPtr) \
-    do {								\
-	Tcl_Obj *objPtr;						\
-	TCL_CT_ASSERT((nbytes)<=sizeof(Tcl_Obj));			\
-	TclNewObj(objPtr);						\
-	memPtr = (ClientData) objPtr;					\
-    } while (0)
-
-#define TclSmallFreeEx(interp, memPtr) \
-    do {								\
-	Tcl_Obj *objPtr = (Tcl_Obj *) memPtr;				\
-	objPtr->bytes = NULL;						\
-	objPtr->typePtr = NULL;						\
-	objPtr->refCount = 1;						\
-	TclDecrRefCount(objPtr);					\
-    } while (0)
-#endif   /* TCL_MEM_DEBUG */
-
-/*
- * Support for Clang Static Analyzer <http://clang-analyzer.llvm.org>
- */
-
-#if defined(PURIFY) && defined(__clang__)
-#if __has_feature(attribute_analyzer_noreturn) && \
-	!defined(Tcl_Panic) && defined(Tcl_Panic_TCL_DECLARED)
-void Tcl_Panic(const char *, ...) __attribute__((analyzer_noreturn));
-#endif
-#if !defined(CLANG_ASSERT)
-#include <assert.h>
-#define CLANG_ASSERT(x) assert(x)
-#endif
-#elif !defined(CLANG_ASSERT)
 #define CLANG_ASSERT(x)
-#endif /* PURIFY && __clang__ */
+
 
 /*
  *----------------------------------------------------------------
  * Parameters, structs and macros for the non-recursive engine (NRE)
  *----------------------------------------------------------------
@@ -4837,12 +4373,12 @@
 	((Interp *)interp)->deferredCallbacks = NULL;			\
     }
 
 #if NRE_USE_SMALL_ALLOC
 #define TCLNR_ALLOC(interp, ptr) \
-    TclSmallAllocEx(interp, sizeof(NRE_callback), (ptr))
-#define TCLNR_FREE(interp, ptr)  TclSmallFreeEx((interp), (ptr))
+    TclCkSmallAlloc(sizeof(NRE_callback), (ptr))
+#define TCLNR_FREE(interp, ptr)  TclSmallFree(ptr)
 #else
 #define TCLNR_ALLOC(interp, ptr) \
     (ptr = ((ClientData) ckalloc(sizeof(NRE_callback))))
 #define TCLNR_FREE(interp, ptr)  ckfree((char *) (ptr))
 #endif
@@ -4850,20 +4386,34 @@
 #if NRE_ENABLE_ASSERTS
 #define NRE_ASSERT(expr) assert((expr))
 #else
 #define NRE_ASSERT(expr)
 #endif
+
+/* GET OUT OF THE ALLOCATOR BIZ! */
+#define TclpAlloc(size) malloc(size)
+#define TclpRealloc(ptr, size) realloc((ptr),(size))
+#define TclpFree(ptr)   free(ptr)
+
+#ifdef PURIFY
+#define TclSmallAlloc()    ckalloc(sizeof(Tcl_Obj))
+#define TclSmallFree(ptr)  ckfree(ptr)
+#define TclInitAlloc()
+#define TclFinalizeAlloc()
+#define TclFreeAllocCache(ptr) 
+#endif
 
 #include "tclIntDecls.h"
 #include "tclIntPlatDecls.h"
 #include "tclTomMathDecls.h"
 
-#if !defined(USE_TCL_STUBS) && !defined(TCL_MEM_DEBUG)
+#if !defined(USE_TCL_STUBS)
 #define Tcl_AttemptAlloc(size)        TclpAlloc(size)
 #define Tcl_AttemptRealloc(ptr, size) TclpRealloc((ptr), (size))
 #define Tcl_Free(ptr)                 TclpFree(ptr)
 #endif
+
 
 #endif /* _TCLINT */
 
 /*
  * Local Variables:

Index: generic/tclIntDecls.h
==================================================================
--- generic/tclIntDecls.h
+++ generic/tclIntDecls.h
@@ -56,12 +56,11 @@
  */
 
 /* Slot 0 is reserved */
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-/* 3 */
-EXTERN void		TclAllocateFreeObjects(void);
+/* Slot 3 is reserved */
 /* Slot 4 is reserved */
 /* 5 */
 EXTERN int		TclCleanupChildren(Tcl_Interp *interp, int numPids,
 				Tcl_Pid *pidPtr, Tcl_Channel errorChan);
 /* 6 */
@@ -198,29 +197,26 @@
 				Tcl_Obj *const objv[], int flags);
 /* Slot 65 is reserved */
 /* Slot 66 is reserved */
 /* Slot 67 is reserved */
 /* Slot 68 is reserved */
-/* 69 */
-EXTERN char *		TclpAlloc(unsigned int size);
+/* Slot 69 is reserved */
 /* Slot 70 is reserved */
 /* Slot 71 is reserved */
 /* Slot 72 is reserved */
 /* Slot 73 is reserved */
-/* 74 */
-EXTERN void		TclpFree(char *ptr);
+/* Slot 74 is reserved */
 /* 75 */
 EXTERN unsigned long	TclpGetClicks(void);
 /* 76 */
 EXTERN unsigned long	TclpGetSeconds(void);
 /* 77 */
 EXTERN void		TclpGetTime(Tcl_Time *time);
 /* Slot 78 is reserved */
 /* Slot 79 is reserved */
 /* Slot 80 is reserved */
-/* 81 */
-EXTERN char *		TclpRealloc(char *ptr, unsigned int size);
+/* Slot 81 is reserved */
 /* Slot 82 is reserved */
 /* Slot 83 is reserved */
 /* Slot 84 is reserved */
 /* Slot 85 is reserved */
 /* Slot 86 is reserved */
@@ -504,14 +500,12 @@
 /* 213 */
 EXTERN Tcl_Obj *	TclGetObjNameOfExecutable(void);
 /* 214 */
 EXTERN void		TclSetObjNameOfExecutable(Tcl_Obj *name,
 				Tcl_Encoding encoding);
-/* 215 */
-EXTERN void *		TclStackAlloc(Tcl_Interp *interp, int numBytes);
-/* 216 */
-EXTERN void		TclStackFree(Tcl_Interp *interp, void *freePtr);
+/* Slot 215 is reserved */
+/* Slot 216 is reserved */
 /* 217 */
 EXTERN int		TclPushStackFrame(Tcl_Interp *interp,
 				Tcl_CallFrame **framePtrPtr,
 				Tcl_Namespace *namespacePtr,
 				int isProcCallFrame);
@@ -526,12 +520,11 @@
 EXTERN TclPlatformType * TclGetPlatform(void);
 /* 225 */
 EXTERN Tcl_Obj *	TclTraceDictPath(Tcl_Interp *interp,
 				Tcl_Obj *rootPtr, int keyc,
 				Tcl_Obj *const keyv[], int flags);
-/* 226 */
-EXTERN int		TclObjBeingDeleted(Tcl_Obj *objPtr);
+/* Slot 226 is reserved */
 /* 227 */
 EXTERN void		TclSetNsPath(Namespace *nsPtr, int pathLength,
 				Tcl_Namespace *pathAry[]);
 /* Slot 228 is reserved */
 /* 229 */
@@ -544,15 +537,12 @@
 				const int createPart1, const int createPart2,
 				Var **arrayPtrPtr);
 /* 231 */
 EXTERN int		TclGetNamespaceFromObj(Tcl_Interp *interp,
 				Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr);
-/* 232 */
-EXTERN int		TclEvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
-				int flags, const CmdFrame *invoker, int word);
-/* 233 */
-EXTERN void		TclGetSrcInfoForPc(CmdFrame *contextPtr);
+/* Slot 232 is reserved */
+/* Slot 233 is reserved */
 /* 234 */
 EXTERN Var *		TclVarHashCreateVar(TclVarHashTable *tablePtr,
 				const char *key, int *newPtr);
 /* 235 */
 EXTERN void		TclInitVarHashTable(TclVarHashTable *tablePtr,
@@ -571,11 +561,11 @@
 /* 240 */
 EXTERN int		TclNRRunCallbacks(Tcl_Interp *interp, int result,
 				struct NRE_callback *rootPtr);
 /* 241 */
 EXTERN int		TclNREvalObjEx(Tcl_Interp *interp, Tcl_Obj *objPtr,
-				int flags, const CmdFrame *invoker, int word);
+				int flags);
 /* 242 */
 EXTERN int		TclNREvalObjv(Tcl_Interp *interp, int objc,
 				Tcl_Obj *const objv[], int flags,
 				Command *cmdPtr);
 /* 243 */
@@ -607,11 +597,11 @@
     void *hooks;
 
     void (*reserved0)(void);
     void (*reserved1)(void);
     void (*reserved2)(void);
-    void (*tclAllocateFreeObjects) (void); /* 3 */
+    void (*reserved3)(void);
     void (*reserved4)(void);
     int (*tclCleanupChildren) (Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr, Tcl_Channel errorChan); /* 5 */
     void (*tclCleanupCommand) (Command *cmdPtr); /* 6 */
     int (*tclCopyAndCollapse) (int count, const char *src, char *dst); /* 7 */
     int (*tclCopyChannelOld) (Tcl_Interp *interp, Tcl_Channel inChan, Tcl_Channel outChan, int toRead, Tcl_Obj *cmdPtr); /* 8 */
@@ -673,23 +663,23 @@
     int (*tclObjInvoke) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags); /* 64 */
     void (*reserved65)(void);
     void (*reserved66)(void);
     void (*reserved67)(void);
     void (*reserved68)(void);
-    char * (*tclpAlloc) (unsigned int size); /* 69 */
+    void (*reserved69)(void);
     void (*reserved70)(void);
     void (*reserved71)(void);
     void (*reserved72)(void);
     void (*reserved73)(void);
-    void (*tclpFree) (char *ptr); /* 74 */
+    void (*reserved74)(void);
     unsigned long (*tclpGetClicks) (void); /* 75 */
     unsigned long (*tclpGetSeconds) (void); /* 76 */
     void (*tclpGetTime) (Tcl_Time *time); /* 77 */
     void (*reserved78)(void);
     void (*reserved79)(void);
     void (*reserved80)(void);
-    char * (*tclpRealloc) (char *ptr, unsigned int size); /* 81 */
+    void (*reserved81)(void);
     void (*reserved82)(void);
     void (*reserved83)(void);
     void (*reserved84)(void);
     void (*reserved85)(void);
     void (*reserved86)(void);
@@ -819,37 +809,37 @@
     void (*reserved210)(void);
     void (*reserved211)(void);
     void (*tclpFindExecutable) (const char *argv0); /* 212 */
     Tcl_Obj * (*tclGetObjNameOfExecutable) (void); /* 213 */
     void (*tclSetObjNameOfExecutable) (Tcl_Obj *name, Tcl_Encoding encoding); /* 214 */
-    void * (*tclStackAlloc) (Tcl_Interp *interp, int numBytes); /* 215 */
-    void (*tclStackFree) (Tcl_Interp *interp, void *freePtr); /* 216 */
+    void (*reserved215)(void);
+    void (*reserved216)(void);
     int (*tclPushStackFrame) (Tcl_Interp *interp, Tcl_CallFrame **framePtrPtr, Tcl_Namespace *namespacePtr, int isProcCallFrame); /* 217 */
     void (*tclPopStackFrame) (Tcl_Interp *interp); /* 218 */
     void (*reserved219)(void);
     void (*reserved220)(void);
     void (*reserved221)(void);
     void (*reserved222)(void);
     void (*reserved223)(void);
     TclPlatformType * (*tclGetPlatform) (void); /* 224 */
     Tcl_Obj * (*tclTraceDictPath) (Tcl_Interp *interp, Tcl_Obj *rootPtr, int keyc, Tcl_Obj *const keyv[], int flags); /* 225 */
-    int (*tclObjBeingDeleted) (Tcl_Obj *objPtr); /* 226 */
+    void (*reserved226)(void);
     void (*tclSetNsPath) (Namespace *nsPtr, int pathLength, Tcl_Namespace *pathAry[]); /* 227 */
     void (*reserved228)(void);
     int (*tclPtrMakeUpvar) (Tcl_Interp *interp, Var *otherP1Ptr, const char *myName, int myFlags, int index); /* 229 */
     Var * (*tclObjLookupVar) (Tcl_Interp *interp, Tcl_Obj *part1Ptr, const char *part2, int flags, const char *msg, const int createPart1, const int createPart2, Var **arrayPtrPtr); /* 230 */
     int (*tclGetNamespaceFromObj) (Tcl_Interp *interp, Tcl_Obj *objPtr, Tcl_Namespace **nsPtrPtr); /* 231 */
-    int (*tclEvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 232 */
-    void (*tclGetSrcInfoForPc) (CmdFrame *contextPtr); /* 233 */
+    void (*reserved232)(void);
+    void (*reserved233)(void);
     Var * (*tclVarHashCreateVar) (TclVarHashTable *tablePtr, const char *key, int *newPtr); /* 234 */
     void (*tclInitVarHashTable) (TclVarHashTable *tablePtr, Namespace *nsPtr); /* 235 */
     void (*reserved236)(void);
     int (*tclResetCancellation) (Tcl_Interp *interp, int force); /* 237 */
     int (*tclNRInterpProc) (ClientData clientData, Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]); /* 238 */
     int (*tclNRInterpProcCore) (Tcl_Interp *interp, Tcl_Obj *procNameObj, int skip, ProcErrorProc *errorProc); /* 239 */
     int (*tclNRRunCallbacks) (Tcl_Interp *interp, int result, struct NRE_callback *rootPtr); /* 240 */
-    int (*tclNREvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags, const CmdFrame *invoker, int word); /* 241 */
+    int (*tclNREvalObjEx) (Tcl_Interp *interp, Tcl_Obj *objPtr, int flags); /* 241 */
     int (*tclNREvalObjv) (Tcl_Interp *interp, int objc, Tcl_Obj *const objv[], int flags, Command *cmdPtr); /* 242 */
     void (*tclDbDumpActiveObjects) (FILE *outFile); /* 243 */
     Tcl_HashTable * (*tclGetNamespaceChildTable) (Tcl_Namespace *nsPtr); /* 244 */
     Tcl_HashTable * (*tclGetNamespaceCommandTable) (Tcl_Namespace *nsPtr); /* 245 */
     int (*tclInitRewriteEnsemble) (Tcl_Interp *interp, int numRemoved, int numInserted, Tcl_Obj *const *objv); /* 246 */
@@ -874,12 +864,11 @@
  */
 
 /* Slot 0 is reserved */
 /* Slot 1 is reserved */
 /* Slot 2 is reserved */
-#define TclAllocateFreeObjects \
-	(tclIntStubsPtr->tclAllocateFreeObjects) /* 3 */
+/* Slot 3 is reserved */
 /* Slot 4 is reserved */
 #define TclCleanupChildren \
 	(tclIntStubsPtr->tclCleanupChildren) /* 5 */
 #define TclCleanupCommand \
 	(tclIntStubsPtr->tclCleanupCommand) /* 6 */
@@ -979,29 +968,26 @@
 	(tclIntStubsPtr->tclObjInvoke) /* 64 */
 /* Slot 65 is reserved */
 /* Slot 66 is reserved */
 /* Slot 67 is reserved */
 /* Slot 68 is reserved */
-#define TclpAlloc \
-	(tclIntStubsPtr->tclpAlloc) /* 69 */
+/* Slot 69 is reserved */
 /* Slot 70 is reserved */
 /* Slot 71 is reserved */
 /* Slot 72 is reserved */
 /* Slot 73 is reserved */
-#define TclpFree \
-	(tclIntStubsPtr->tclpFree) /* 74 */
+/* Slot 74 is reserved */
 #define TclpGetClicks \
 	(tclIntStubsPtr->tclpGetClicks) /* 75 */
 #define TclpGetSeconds \
 	(tclIntStubsPtr->tclpGetSeconds) /* 76 */
 #define TclpGetTime \
 	(tclIntStubsPtr->tclpGetTime) /* 77 */
 /* Slot 78 is reserved */
 /* Slot 79 is reserved */
 /* Slot 80 is reserved */
-#define TclpRealloc \
-	(tclIntStubsPtr->tclpRealloc) /* 81 */
+/* Slot 81 is reserved */
 /* Slot 82 is reserved */
 /* Slot 83 is reserved */
 /* Slot 84 is reserved */
 /* Slot 85 is reserved */
 /* Slot 86 is reserved */
@@ -1214,14 +1200,12 @@
 	(tclIntStubsPtr->tclpFindExecutable) /* 212 */
 #define TclGetObjNameOfExecutable \
 	(tclIntStubsPtr->tclGetObjNameOfExecutable) /* 213 */
 #define TclSetObjNameOfExecutable \
 	(tclIntStubsPtr->tclSetObjNameOfExecutable) /* 214 */
-#define TclStackAlloc \
-	(tclIntStubsPtr->tclStackAlloc) /* 215 */
-#define TclStackFree \
-	(tclIntStubsPtr->tclStackFree) /* 216 */
+/* Slot 215 is reserved */
+/* Slot 216 is reserved */
 #define TclPushStackFrame \
 	(tclIntStubsPtr->tclPushStackFrame) /* 217 */
 #define TclPopStackFrame \
 	(tclIntStubsPtr->tclPopStackFrame) /* 218 */
 /* Slot 219 is reserved */
@@ -1231,25 +1215,22 @@
 /* Slot 223 is reserved */
 #define TclGetPlatform \
 	(tclIntStubsPtr->tclGetPlatform) /* 224 */
 #define TclTraceDictPath \
 	(tclIntStubsPtr->tclTraceDictPath) /* 225 */
-#define TclObjBeingDeleted \
-	(tclIntStubsPtr->tclObjBeingDeleted) /* 226 */
+/* Slot 226 is reserved */
 #define TclSetNsPath \
 	(tclIntStubsPtr->tclSetNsPath) /* 227 */
 /* Slot 228 is reserved */
 #define TclPtrMakeUpvar \
 	(tclIntStubsPtr->tclPtrMakeUpvar) /* 229 */
 #define TclObjLookupVar \
 	(tclIntStubsPtr->tclObjLookupVar) /* 230 */
 #define TclGetNamespaceFromObj \
 	(tclIntStubsPtr->tclGetNamespaceFromObj) /* 231 */
-#define TclEvalObjEx \
-	(tclIntStubsPtr->tclEvalObjEx) /* 232 */
-#define TclGetSrcInfoForPc \
-	(tclIntStubsPtr->tclGetSrcInfoForPc) /* 233 */
+/* Slot 232 is reserved */
+/* Slot 233 is reserved */
 #define TclVarHashCreateVar \
 	(tclIntStubsPtr->tclVarHashCreateVar) /* 234 */
 #define TclInitVarHashTable \
 	(tclIntStubsPtr->tclInitVarHashTable) /* 235 */
 /* Slot 236 is reserved */

Index: generic/tclInterp.c
==================================================================
--- generic/tclInterp.c
+++ generic/tclInterp.c
@@ -1131,11 +1131,11 @@
     Tcl_Obj *slaveObjPtr, *targetObjPtr;
     Tcl_Obj **objv;
     int i;
     int result;
 
-    objv = TclStackAlloc(slaveInterp, (unsigned) sizeof(Tcl_Obj *) * argc);
+    objv = ckalloc((unsigned) sizeof(Tcl_Obj *) * argc);
     for (i = 0; i < argc; i++) {
 	objv[i] = Tcl_NewStringObj(argv[i], -1);
 	Tcl_IncrRefCount(objv[i]);
     }
 
@@ -1149,11 +1149,11 @@
 	    targetObjPtr, argc, objv);
 
     for (i = 0; i < argc; i++) {
 	Tcl_DecrRefCount(objv[i]);
     }
-    TclStackFree(slaveInterp, objv);
+    ckfree(objv);
     Tcl_DecrRefCount(targetObjPtr);
     Tcl_DecrRefCount(slaveObjPtr);
 
     return result;
 }
@@ -1829,11 +1829,11 @@
     prefv = &aliasPtr->objPtr;
     cmdc = prefc + objc - 1;
     if (cmdc <= ALIAS_CMDV_PREALLOC) {
 	cmdv = cmdArr;
     } else {
-	cmdv = TclStackAlloc(interp, cmdc * sizeof(Tcl_Obj *));
+	cmdv = ckalloc(cmdc * sizeof(Tcl_Obj *));
     }
 
     prefv = &aliasPtr->objPtr;
     memcpy(cmdv, prefv, (size_t) (prefc * sizeof(Tcl_Obj *)));
     memcpy(cmdv+prefc, objv+1, (size_t) ((objc-1) * sizeof(Tcl_Obj *)));
@@ -1896,11 +1896,11 @@
 
     for (i=0; i<cmdc; i++) {
 	Tcl_DecrRefCount(cmdv[i]);
     }
     if (cmdv != cmdArr) {
-	TclStackFree(interp, cmdv);
+	ckfree(cmdv);
     }
     return result;
 #undef ALIAS_CMDV_PREALLOC
 }
 
@@ -2767,21 +2767,11 @@
 
     Tcl_Preserve(slaveInterp);
     Tcl_AllowExceptions(slaveInterp);
 
     if (objc == 1) {
-	/*
-	 * TIP #280: Make actual argument location available to eval'd script.
-	 */
-
-	Interp *iPtr = (Interp *) interp;
-	CmdFrame *invoker = iPtr->cmdFramePtr;
-	int word = 0;
-
-	TclArgumentGet(interp, objv[0], &invoker, &word);
-
-	result = TclEvalObjEx(slaveInterp, objv[0], 0, invoker, word);
+	result = Tcl_EvalObjEx(slaveInterp, objv[0], 0);
     } else {
 	Tcl_Obj *objPtr = Tcl_ConcatObj(objc, objv);
 	Tcl_IncrRefCount(objPtr);
 	result = Tcl_EvalObjEx(slaveInterp, objPtr, 0);
 	Tcl_DecrRefCount(objPtr);

Index: generic/tclListObj.c
==================================================================
Index: generic/tclNamesp.c
==================================================================
--- generic/tclNamesp.c
+++ generic/tclNamesp.c
@@ -463,11 +463,11 @@
 				 * for a "namespace eval" or "namespace
 				 * inscope" command and var references are
 				 * treated as references to namespace
 				 * variables. */
 {
-    *framePtrPtr = TclStackAlloc(interp, sizeof(CallFrame));
+    *framePtrPtr = ckalloc(sizeof(CallFrame));
     return Tcl_PushCallFrame(interp, *framePtrPtr, namespacePtr,
 	    isProcCallFrame);
 }
 
 void
@@ -475,11 +475,11 @@
     Tcl_Interp *interp)		/* Interpreter with call frame to pop. */
 {
     CallFrame *freePtr = ((Interp *) interp)->framePtr;
 
     Tcl_PopCallFrame(interp);
-    TclStackFree(interp, freePtr);
+    ckfree(freePtr);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -2639,12 +2639,11 @@
     Namespace *trailNsPtr, *shadowNsPtr;
     Namespace *globalNsPtr = (Namespace *) TclGetGlobalNamespace(interp);
     int found, i;
     int trailFront = -1;
     int trailSize = 5;		/* Formerly NUM_TRAIL_ELEMS. */
-    Namespace **trailPtr = TclStackAlloc(interp,
-	    trailSize * sizeof(Namespace *));
+    Namespace **trailPtr = ckalloc(trailSize * sizeof(Namespace *));
 
     /*
      * Start at the namespace containing the new command, and work up through
      * the list of parents. Stop just before the global namespace, since the
      * global namespace can't "shadow" its own entries.
@@ -2729,17 +2728,16 @@
 
 	trailFront++;
 	if (trailFront == trailSize) {
 	    int newSize = 2 * trailSize;
 
-	    trailPtr = TclStackRealloc(interp, trailPtr,
-		    newSize * sizeof(Namespace *));
+	    trailPtr = ckrealloc(trailPtr, newSize * sizeof(Namespace *));
 	    trailSize = newSize;
 	}
 	trailPtr[trailFront] = nsPtr;
     }
-    TclStackFree(interp, trailPtr);
+    ckfree(trailPtr);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -3237,12 +3235,10 @@
     Tcl_Interp *interp,		/* Current interpreter. */
     int objc,			/* Number of arguments. */
     Tcl_Obj *const objv[])	/* Argument objects. */
 {
     Interp *iPtr = (Interp *) interp;
-    CmdFrame *invoker;
-    int word;
     Tcl_Namespace *namespacePtr;
     CallFrame *framePtr, **framePtrPtr;
     Tcl_Obj *objPtr;
     int result;
 
@@ -3292,37 +3288,24 @@
 		- iPtr->ensembleRewrite.numInsertedObjs;
 	framePtr->objv = iPtr->ensembleRewrite.sourceObjs;
     }
 
     if (objc == 3) {
-	/*
-	 * TIP #280: Make actual argument location available to eval'd script.
-	 */
-
 	objPtr = objv[2];
-	invoker = iPtr->cmdFramePtr;
-	word = 3;
-	TclArgumentGet(interp, objPtr, &invoker, &word);
     } else {
 	/*
 	 * More than one argument: concatenate them together with spaces
 	 * between, then evaluate the result. Tcl_EvalObjEx will delete the
 	 * object when it decrements its refcount after eval'ing it.
 	 */
 
 	objPtr = Tcl_ConcatObj(objc-2, objv+2);
-	invoker = NULL;
-	word = 0;
     }
 
-    /*
-     * TIP #280: Make invoking context available to eval'd script.
-     */
-
     TclNRAddCallback(interp, NsEval_Callback, namespacePtr, "eval",
 	    NULL, NULL);
-    return TclNREvalObjEx(interp, objPtr, 0, invoker, word);
+    return TclNREvalObjEx(interp, objPtr, 0);
 }
 
 static int
 NsEval_Callback(
     ClientData data[],
@@ -3783,11 +3766,11 @@
 	Tcl_DecrRefCount(listPtr);    /* We're done with the list object. */
     }
 
     TclNRAddCallback(interp, NsEval_Callback, namespacePtr, "inscope",
 	    NULL, NULL);
-    return TclNREvalObjEx(interp, cmdObjPtr, 0, NULL, 0);
+    return TclNREvalObjEx(interp, cmdObjPtr, 0);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -3976,12 +3959,11 @@
 
     if (TclListObjGetElements(interp, objv[1], &nsObjc, &nsObjv) != TCL_OK) {
 	goto badNamespace;
     }
     if (nsObjc != 0) {
-	namespaceList = TclStackAlloc(interp,
-		sizeof(Tcl_Namespace *) * nsObjc);
+	namespaceList = ckalloc(sizeof(Tcl_Namespace *) * nsObjc);
 
 	for (i=0 ; i<nsObjc ; i++) {
 	    if (TclGetNamespaceFromObj(interp, nsObjv[i],
 		    &namespaceList[i]) != TCL_OK) {
 		goto badNamespace;
@@ -3996,11 +3978,11 @@
     TclSetNsPath(nsPtr, nsObjc, namespaceList);
 
     result = TCL_OK;
   badNamespace:
     if (namespaceList != NULL) {
-	TclStackFree(interp, namespaceList);
+	ckfree(namespaceList);
     }
     return result;
 }
 
 /*

Index: generic/tclOOBasic.c
==================================================================
--- generic/tclOOBasic.c
+++ generic/tclOOBasic.c
@@ -402,11 +402,10 @@
     Tcl_Object object = Tcl_ObjectContextObject(context);
     register const int skip = Tcl_ObjectContextSkippedArgs(context);
     CallFrame *framePtr, **framePtrPtr = &framePtr;
     Tcl_Obj *scriptPtr;
     int result;
-    CmdFrame *invoker;
 
     if (objc-1 < skip) {
 	Tcl_WrongNumArgs(interp, skip, objv, "arg ?arg ...?");
 	return TCL_ERROR;
     }
@@ -437,23 +436,21 @@
      * object when it decrements its refcount after eval'ing it.
      */
 
     if (objc != skip+1) {
 	scriptPtr = Tcl_ConcatObj(objc-skip, objv+skip);
-	invoker = NULL;
     } else {
 	scriptPtr = objv[skip];
-	invoker = ((Interp *) interp)->cmdFramePtr;
     }
 
     /*
      * Evaluate the script now, with FinalizeEval to do the processing after
      * the script completes.
      */
 
     TclNRAddCallback(interp, FinalizeEval, object, NULL, NULL, NULL);
-    return TclNREvalObjEx(interp, scriptPtr, 0, invoker, skip);
+    return TclNREvalObjEx(interp, scriptPtr, 0);
 }
 
 static int
 FinalizeEval(
     ClientData data[],

Index: generic/tclOOCall.c
==================================================================
--- generic/tclOOCall.c
+++ generic/tclOOCall.c
@@ -103,11 +103,11 @@
 {
     register Object *oPtr = contextPtr->oPtr;
 
     TclOODeleteChain(contextPtr->callPtr);
     if (oPtr != NULL) {
-	TclStackFree(oPtr->fPtr->interp, contextPtr);
+	ckfree(contextPtr);
 	DelRef(oPtr);
     }
 }
 
 /*
@@ -1103,11 +1103,11 @@
 	oPtr->selfCls->destructorChainPtr = callPtr;
 	callPtr->refCount++;
     }
 
   returnContext:
-    contextPtr = TclStackAlloc(oPtr->fPtr->interp, sizeof(CallContext));
+    contextPtr = ckalloc(sizeof(CallContext));
     contextPtr->oPtr = oPtr;
     AddRef(oPtr);
     contextPtr->callPtr = callPtr;
     contextPtr->skip = 2;
     contextPtr->index = 0;
@@ -1444,11 +1444,11 @@
      * the method in question (which differs for "unknown" and "filter" types)
      * and the third word is the full name of the class that declares the
      * method (or "object" if it is declared on the instance).
      */
 
-    objv = TclStackAlloc(interp, callPtr->numChain * sizeof(Tcl_Obj *));
+    objv = ckalloc(callPtr->numChain * sizeof(Tcl_Obj *));
     for (i=0 ; i<callPtr->numChain ; i++) {
 	struct MInvoke *miPtr = &callPtr->chain[i];
 
 	descObjs[0] = miPtr->isFilter
 		? filterLiteral
@@ -1481,11 +1481,11 @@
     /*
      * Finish building the description and return it.
      */
 
     resultObj = Tcl_NewListObj(callPtr->numChain, objv);
-    TclStackFree(interp, objv);
+    ckfree(objv);
     return resultObj;
 }
 
 /*
  * Local Variables:

Index: generic/tclOODefineCmds.c
==================================================================
--- generic/tclOODefineCmds.c
+++ generic/tclOODefineCmds.c
@@ -543,21 +543,21 @@
     if (matchedStr != NULL) {
 	/*
 	 * Got one match, and only one match!
 	 */
 
-	Tcl_Obj **newObjv = TclStackAlloc(interp, sizeof(Tcl_Obj*)*(objc-1));
+	Tcl_Obj **newObjv = ckalloc(sizeof(Tcl_Obj*)*(objc-1));
 	int result;
 
 	newObjv[0] = Tcl_NewStringObj(matchedStr, -1);
 	Tcl_IncrRefCount(newObjv[0]);
 	if (objc > 2) {
 	    memcpy(newObjv+1, objv+2, sizeof(Tcl_Obj *) * (objc-2));
 	}
 	result = Tcl_EvalObjv(interp, objc-1, newObjv, 0);
 	Tcl_DecrRefCount(newObjv[0]);
-	TclStackFree(interp, newObjv);
+	ckfree(newObjv);
 	return result;
     }
 
   noMatch:
     Tcl_SetObjResult(interp, Tcl_ObjPrintf(
@@ -839,12 +839,11 @@
     AddRef(oPtr);
     if (objc == 3) {
 	Tcl_Obj *objNameObj = TclOOObjectName(interp, oPtr);
 
 	Tcl_IncrRefCount(objNameObj);
-	result = TclEvalObjEx(interp, objv[2], 0,
-		((Interp *)interp)->cmdFramePtr, 2);
+	result = Tcl_EvalObjEx(interp, objv[2], 0);
 	if (result == TCL_ERROR) {
 	    GenerateErrorInfo(interp, oPtr, objNameObj, "class");
 	}
 	TclDecrRefCount(objNameObj);
     } else {
@@ -953,12 +952,11 @@
     AddRef(oPtr);
     if (objc == 3) {
 	Tcl_Obj *objNameObj = TclOOObjectName(interp, oPtr);
 
 	Tcl_IncrRefCount(objNameObj);
-	result = TclEvalObjEx(interp, objv[2], 0,
-		((Interp *)interp)->cmdFramePtr, 2);
+	result = Tcl_EvalObjEx(interp, objv[2], 0);
 	if (result == TCL_ERROR) {
 	    GenerateErrorInfo(interp, oPtr, objNameObj, "object");
 	}
 	TclDecrRefCount(objNameObj);
     } else {
@@ -1067,12 +1065,11 @@
     AddRef(oPtr);
     if (objc == 2) {
 	Tcl_Obj *objNameObj = TclOOObjectName(interp, oPtr);
 
 	Tcl_IncrRefCount(objNameObj);
-	result = TclEvalObjEx(interp, objv[1], 0,
-		((Interp *)interp)->cmdFramePtr, 2);
+	result = Tcl_EvalObjEx(interp, objv[1], 0);
 	if (result == TCL_ERROR) {
 	    GenerateErrorInfo(interp, oPtr, objNameObj, "class object");
 	}
 	TclDecrRefCount(objNameObj);
     } else {
@@ -1651,11 +1648,11 @@
 	Tcl_SetObjResult(interp, Tcl_NewStringObj(
 		"attempt to misuse API", -1));
 	Tcl_SetErrorCode(interp, "TCL", "OO", "MONKEY_BUSINESS", NULL);
 	return TCL_ERROR;
     }
-    mixins = TclStackAlloc(interp, sizeof(Class *) * (objc-1));
+    mixins = ckalloc(sizeof(Class *) * (objc-1));
 
     for (i=1 ; i<objc ; i++) {
 	Class *clsPtr = GetClassInOuterContext(interp, objv[i],
 		"may only mix in classes");
 
@@ -1675,15 +1672,15 @@
 	TclOOObjectSetMixins(oPtr, objc-1, mixins);
     } else {
 	TclOOClassSetMixins(interp, oPtr->classPtr, objc-1, mixins);
     }
 
-    TclStackFree(interp, mixins);
+    ckfree(mixins);
     return TCL_OK;
 
   freeAndError:
-    TclStackFree(interp, mixins);
+    ckfree(mixins);
     return TCL_ERROR;
 }
 
 /*
  * ----------------------------------------------------------------------
@@ -2088,11 +2085,11 @@
     } else if (Tcl_ListObjGetElements(interp, objv[0], &mixinc,
 	    &mixinv) != TCL_OK) {
 	return TCL_ERROR;
     }
 
-    mixins = TclStackAlloc(interp, sizeof(Class *) * mixinc);
+    mixins = ckalloc(sizeof(Class *) * mixinc);
 
     for (i=0 ; i<mixinc ; i++) {
 	mixins[i] = GetClassInOuterContext(interp, mixinv[i],
 		"may only mix in classes");
 	if (mixins[i] == NULL) {
@@ -2105,15 +2102,15 @@
 	    goto freeAndError;
 	}
     }
 
     TclOOClassSetMixins(interp, oPtr->classPtr, mixinc, mixins);
-    TclStackFree(interp, mixins);
+    ckfree(mixins);
     return TCL_OK;
 
   freeAndError:
-    TclStackFree(interp, mixins);
+    ckfree(mixins);
     return TCL_ERROR;
 }
 
 /*
  * ----------------------------------------------------------------------
@@ -2529,23 +2526,23 @@
     if (Tcl_ListObjGetElements(interp, objv[0], &mixinc,
 	    &mixinv) != TCL_OK) {
 	return TCL_ERROR;
     }
 
-    mixins = TclStackAlloc(interp, sizeof(Class *) * mixinc);
+    mixins = ckalloc(sizeof(Class *) * mixinc);
 
     for (i=0 ; i<mixinc ; i++) {
 	mixins[i] = GetClassInOuterContext(interp, mixinv[i],
 		"may only mix in classes");
 	if (mixins[i] == NULL) {
-	    TclStackFree(interp, mixins);
+	    ckfree(mixins);
 	    return TCL_ERROR;
 	}
     }
 
     TclOOObjectSetMixins(oPtr, mixinc, mixins);
-    TclStackFree(interp, mixins);
+    ckfree(mixins);
     return TCL_OK;
 }
 
 /*
  * ----------------------------------------------------------------------

Index: generic/tclOOInt.h
==================================================================
--- generic/tclOOInt.h
+++ generic/tclOOInt.h
@@ -92,13 +92,10 @@
 				/* Callback to allow for additional setup
 				 * before the method executes. */
     TclOO_PostCallProc *postCallProc;
 				/* Callback to allow for additional cleanup
 				 * after the method executes. */
-    GetFrameInfoValueProc *gfivProc;
-				/* Callback to allow for fine tuning of how
-				 * the method reports itself. */
 } ProcedureMethod;
 
 #define TCLOO_PROCEDURE_METHOD_VERSION 0
 
 /*

Index: generic/tclOOMethod.c
==================================================================
--- generic/tclOOMethod.c
+++ generic/tclOOMethod.c
@@ -14,21 +14,10 @@
 #endif
 #include "tclInt.h"
 #include "tclOOInt.h"
 #include "tclCompile.h"
 
-/*
- * Structure used to help delay computing names of objects or classes for
- * [info frame] until needed, making invokation faster in the normal case.
- */
-
-struct PNI {
-    Tcl_Interp *interp;		/* Interpreter in which to compute the name of
-				 * a method. */
-    Tcl_Method method;		/* Method to compute the name of. */
-};
-
 /*
  * Structure used to contain all the information needed about a call frame
  * used in a procedure-like method.
  */
 
@@ -36,15 +25,12 @@
     CallFrame *framePtr;	/* Reference to the call frame itself (it's
 				 * actually allocated on the Tcl stack). */
     ProcErrorProc *errProc;	/* The error handler for the body. */
     Tcl_Obj *nameObj;		/* The "name" of the command. */
     Command cmd;		/* The command structure. Mostly bogus. */
-    ExtraFrameInfo efi;		/* Extra information used for [info frame]. */
     Command *oldCmdPtr;		/* Saved cmdPtr so that we can be safe after a
 				 * recursive call returns. */
-    struct PNI pni;		/* Specialist information used in the efi
-				 * field for this type of call. */
 } PMFrameData;
 
 /*
  * Structure used to pass information about variable resolution to the
  * on-the-ground resolvers used when working with resolved compiled variables.
@@ -86,11 +72,10 @@
 			    Tcl_Obj *procNameObj);
 static void		ConstructorErrorHandler(Tcl_Interp *interp,
 			    Tcl_Obj *procNameObj);
 static void		DestructorErrorHandler(Tcl_Interp *interp,
 			    Tcl_Obj *procNameObj);
-static Tcl_Obj *	RenderDeclarerName(ClientData clientData);
 static int		InvokeForwardMethod(ClientData clientData,
 			    Tcl_Interp *interp, Tcl_ObjectContext context,
 			    int objc, Tcl_Obj *const *objv);
 static void		DeleteForwardMethod(ClientData clientData);
 static int		CloneForwardMethod(Tcl_Interp *interp,
@@ -456,83 +441,19 @@
     Proc **procPtrPtr)		/* A pointer to the variable in which to write
 				 * the procedure record reference. Presumably
 				 * inside the structure indicated by the
 				 * pointer in clientData. */
 {
-    Interp *iPtr = (Interp *) interp;
     Proc *procPtr;
 
     if (TclCreateProc(interp, NULL, TclGetString(nameObj), argsObj, bodyObj,
 	    procPtrPtr) != TCL_OK) {
 	return NULL;
     }
     procPtr = *procPtrPtr;
     procPtr->cmdPtr = NULL;
 
-    if (iPtr->cmdFramePtr) {
-	CmdFrame context = *iPtr->cmdFramePtr;
-
-	if (context.type == TCL_LOCATION_BC) {
-	    /*
-	     * Retrieve source information from the bytecode, if possible. If
-	     * the information is retrieved successfully, context.type will be
-	     * TCL_LOCATION_SOURCE and the reference held by
-	     * context.data.eval.path will be counted.
-	     */
-
-	    TclGetSrcInfoForPc(&context);
-	} else if (context.type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * The copy into 'context' up above has created another reference
-	     * to 'context.data.eval.path'; account for it.
-	     */
-
-	    Tcl_IncrRefCount(context.data.eval.path);
-	}
-
-	if (context.type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * We can account for source location within a proc only if the
-	     * proc body was not created by substitution.
-	     * (FIXME: check that this is sane and correct!)
-	     */
-
-	    if (context.line
-		    && (context.nline >= 4) && (context.line[3] >= 0)) {
-		int isNew;
-		CmdFrame *cfPtr = ckalloc(sizeof(CmdFrame));
-		Tcl_HashEntry *hPtr;
-
-		cfPtr->level = -1;
-		cfPtr->type = context.type;
-		cfPtr->line = ckalloc(sizeof(int));
-		cfPtr->line[0] = context.line[3];
-		cfPtr->nline = 1;
-		cfPtr->framePtr = NULL;
-		cfPtr->nextPtr = NULL;
-
-		cfPtr->data.eval.path = context.data.eval.path;
-		Tcl_IncrRefCount(cfPtr->data.eval.path);
-
-		cfPtr->cmd.str.cmd = NULL;
-		cfPtr->cmd.str.len = 0;
-
-		hPtr = Tcl_CreateHashEntry(iPtr->linePBodyPtr,
-			(char *) procPtr, &isNew);
-		Tcl_SetHashValue(hPtr, cfPtr);
-	    }
-
-	    /*
-	     * 'context' is going out of scope; account for the reference that
-	     * it's holding to the path name.
-	     */
-
-	    Tcl_DecrRefCount(context.data.eval.path);
-	    context.data.eval.path = NULL;
-	}
-    }
-
     return Tcl_NewInstanceMethod(interp, (Tcl_Object) oPtr, nameObj, flags,
 	    typePtr, clientData);
 }
 
 /*
@@ -569,83 +490,19 @@
     Proc **procPtrPtr)		/* A pointer to the variable in which to write
 				 * the procedure record reference. Presumably
 				 * inside the structure indicated by the
 				 * pointer in clientData. */
 {
-    Interp *iPtr = (Interp *) interp;
     Proc *procPtr;
 
     if (TclCreateProc(interp, NULL, namePtr, argsObj, bodyObj,
 	    procPtrPtr) != TCL_OK) {
 	return NULL;
     }
     procPtr = *procPtrPtr;
     procPtr->cmdPtr = NULL;
 
-    if (iPtr->cmdFramePtr) {
-	CmdFrame context = *iPtr->cmdFramePtr;
-
-	if (context.type == TCL_LOCATION_BC) {
-	    /*
-	     * Retrieve source information from the bytecode, if possible. If
-	     * the information is retrieved successfully, context.type will be
-	     * TCL_LOCATION_SOURCE and the reference held by
-	     * context.data.eval.path will be counted.
-	     */
-
-	    TclGetSrcInfoForPc(&context);
-	} else if (context.type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * The copy into 'context' up above has created another reference
-	     * to 'context.data.eval.path'; account for it.
-	     */
-
-	    Tcl_IncrRefCount(context.data.eval.path);
-	}
-
-	if (context.type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * We can account for source location within a proc only if the
-	     * proc body was not created by substitution.
-	     * (FIXME: check that this is sane and correct!)
-	     */
-
-	    if (context.line
-		    && (context.nline >= 4) && (context.line[3] >= 0)) {
-		int isNew;
-		CmdFrame *cfPtr = ckalloc(sizeof(CmdFrame));
-		Tcl_HashEntry *hPtr;
-
-		cfPtr->level = -1;
-		cfPtr->type = context.type;
-		cfPtr->line = ckalloc(sizeof(int));
-		cfPtr->line[0] = context.line[3];
-		cfPtr->nline = 1;
-		cfPtr->framePtr = NULL;
-		cfPtr->nextPtr = NULL;
-
-		cfPtr->data.eval.path = context.data.eval.path;
-		Tcl_IncrRefCount(cfPtr->data.eval.path);
-
-		cfPtr->cmd.str.cmd = NULL;
-		cfPtr->cmd.str.len = 0;
-
-		hPtr = Tcl_CreateHashEntry(iPtr->linePBodyPtr,
-			(char *) procPtr, &isNew);
-		Tcl_SetHashValue(hPtr, cfPtr);
-	    }
-
-	    /*
-	     * 'context' is going out of scope; account for the reference that
-	     * it's holding to the path name.
-	     */
-
-	    Tcl_DecrRefCount(context.data.eval.path);
-	    context.data.eval.path = NULL;
-	}
-    }
-
     return Tcl_NewMethod(interp, (Tcl_Class) clsPtr, nameObj, flags, typePtr,
 	    clientData);
 }
 
 /*
@@ -684,20 +541,20 @@
 
     /*
      * Allocate the special frame data.
      */
 
-    fdPtr = TclStackAlloc(interp, sizeof(PMFrameData));
+    fdPtr = ckalloc(sizeof(PMFrameData));
 
     /*
      * Create a call frame for this method.
      */
 
     result = PushMethodCallFrame(interp, (CallContext *) context, pmPtr,
 	    objc, objv, fdPtr);
     if (result != TCL_OK) {
-	TclStackFree(interp, fdPtr);
+	ckfree(fdPtr);
 	return result;
     }
     pmPtr->refCount++;
 
     /*
@@ -717,15 +574,15 @@
 	     */
 
 	    pmPtr->procPtr->cmdPtr = fdPtr->oldCmdPtr;
 
 	    Tcl_PopCallFrame(interp);
-	    TclStackFree(interp, fdPtr->framePtr);
+	    ckfree(fdPtr->framePtr);
 	    if (--pmPtr->refCount < 1) {
 		DeleteProcedureMethodRecord(pmPtr);
 	    }
-	    TclStackFree(interp, fdPtr);
+	    ckfree(fdPtr);
 	    return result;
 	}
     }
 
     /*
@@ -772,11 +629,11 @@
      */
 
     if (--pmPtr->refCount < 1) {
 	DeleteProcedureMethodRecord(pmPtr);
     }
-    TclStackFree(interp, fdPtr);
+    ckfree(fdPtr);
     return result;
 }
 
 static int
 PushMethodCallFrame(
@@ -843,14 +700,12 @@
 
     /*
      * Compile the body. This operation may fail.
      */
 
-    fdPtr->efi.length = 2;
     memset(&fdPtr->cmd, 0, sizeof(Command));
     fdPtr->cmd.nsPtr = nsPtr;
-    fdPtr->cmd.clientData = &fdPtr->efi;
     pmPtr->procPtr->cmdPtr = &fdPtr->cmd;
 
     /*
      * [Bug 2037727] Always call TclProcCompileProc so that we check not only
      * that we have bytecode, but also that it remains valid. Note that we set
@@ -884,36 +739,10 @@
     fdPtr->framePtr->clientData = contextPtr;
     fdPtr->framePtr->objc = objc;
     fdPtr->framePtr->objv = objv;
     fdPtr->framePtr->procPtr = pmPtr->procPtr;
 
-    /*
-     * Finish filling out the extra frame info so that [info frame] works.
-     */
-
-    fdPtr->efi.fields[0].name = "method";
-    fdPtr->efi.fields[0].proc = NULL;
-    fdPtr->efi.fields[0].clientData = fdPtr->nameObj;
-    if (pmPtr->gfivProc != NULL) {
-	fdPtr->efi.fields[1].name = "";
-	fdPtr->efi.fields[1].proc = pmPtr->gfivProc;
-	fdPtr->efi.fields[1].clientData = pmPtr;
-    } else {
-	register Tcl_Method method =
-		Tcl_ObjectContextMethod((Tcl_ObjectContext) contextPtr);
-
-	if (Tcl_MethodDeclarerObject(method) != NULL) {
-	    fdPtr->efi.fields[1].name = "object";
-	} else {
-	    fdPtr->efi.fields[1].name = "class";
-	}
-	fdPtr->efi.fields[1].proc = RenderDeclarerName;
-	fdPtr->efi.fields[1].clientData = &fdPtr->pni;
-	fdPtr->pni.interp = interp;
-	fdPtr->pni.method = method;
-    }
-
     return TCL_OK;
 
     /*
      * Restore the old cmdPtr so that a subsequent use of [info frame] won't
      * crash on us. [Bug 3001438]
@@ -1114,36 +943,10 @@
     infoPtr->variableObj = variableObj;
     Tcl_IncrRefCount(variableObj);
     *rPtrPtr = &infoPtr->info;
     return TCL_OK;
 }
-
-/*
- * ----------------------------------------------------------------------
- *
- * RenderDeclarerName --
- *
- *	Returns the name of the entity (object or class) which declared a
- *	method. Used for producing information for [info frame] in such a way
- *	that the expensive part of this (generating the object or class name
- *	itself) isn't done until it is needed.
- *
- * ----------------------------------------------------------------------
- */
-
-static Tcl_Obj *
-RenderDeclarerName(
-    ClientData clientData)
-{
-    struct PNI *pni = clientData;
-    Tcl_Object object = Tcl_MethodDeclarerObject(pni->method);
-
-    if (object == NULL) {
-	object = Tcl_GetClassAsObject(Tcl_MethodDeclarerClass(pni->method));
-    }
-    return TclOOObjectName(pni->interp, (Object *) object);
-}
 
 /*
  * ----------------------------------------------------------------------
  *
  * MethodErrorHandler, ConstructorErrorHandler, DestructorErrorHandler --
@@ -1438,11 +1241,11 @@
     Tcl_Interp *interp,
     int result)
 {
     Tcl_Obj **argObjs = data[0];
     
-    TclStackFree(interp, argObjs);
+    ckfree(argObjs);
     return result;
 }
 
 /*
  * ----------------------------------------------------------------------
@@ -1567,11 +1370,11 @@
     Interp *iPtr = (Interp *) interp;
     int isRootEnsemble = (iPtr->ensembleRewrite.sourceObjs == NULL);
     Tcl_Obj **argObjs;
     unsigned len = rewriteLength + objc - toRewrite;
 
-    argObjs = TclStackAlloc(interp, sizeof(Tcl_Obj *) * len);
+    argObjs = ckalloc(sizeof(Tcl_Obj *) * len);
     memcpy(argObjs, rewriteObjs, rewriteLength * sizeof(Tcl_Obj *));
     memcpy(argObjs + rewriteLength, objv + toRewrite,
 	    sizeof(Tcl_Obj *) * (objc - toRewrite));
 
     /*

Index: generic/tclObj.c
==================================================================
--- generic/tclObj.c
+++ generic/tclObj.c
@@ -24,24 +24,12 @@
 
 static Tcl_HashTable typeTable;
 static int typeTableInitialized = 0;	/* 0 means not yet initialized. */
 TCL_DECLARE_MUTEX(tableMutex)
 
-/*
- * Head of the list of free Tcl_Obj structs we maintain.
- */
-
-Tcl_Obj *tclFreeObjList = NULL;
-
-/*
- * The object allocator is single threaded. This mutex is referenced by the
- * TclNewObj macro, however, so must be visible.
- */
-
-#ifdef TCL_THREADS
-MODULE_SCOPE Tcl_Mutex tclObjMutex;
-Tcl_Mutex tclObjMutex;
+#if (defined(TCL_THREADS) && TCL_MEM_DEBUG)
+static Tcl_Mutex tclObjMutex;
 #endif
 
 /*
  * Pointer to a heap-allocated string of length zero that the Tcl core uses as
  * the value of an empty string representation for an object. This value is
@@ -74,34 +62,21 @@
  *
  * Notice that different structures with the same name appear in other files.
  * The structure defined below is used in this file only.
  */
 
-typedef struct ThreadSpecificData {
-    Tcl_HashTable *lineCLPtr;   /* This table remembers for each Tcl_Obj
-                                 * generated by a call to the function
-                                 * TclSubstTokens() from a literal text
-                                 * where bs+nl sequences occured in it, if
-                                 * any. I.e. this table keeps track of
-                                 * invisible and stripped continuation lines.
-                                 * Its keys are Tcl_Obj pointers, the values
-                                 * are ContLineLoc pointers. See the file
-                                 * tclCompile.h for the definition of this
-                                 * structure, and for references to all
-                                 * related places in the core. */
 #if defined(TCL_MEM_DEBUG) && defined(TCL_THREADS)
+typedef struct ThreadSpecificData {
     Tcl_HashTable *objThreadMap;/* Thread local table that is used to check
                                  * that a Tcl_Obj was not allocated by some
                                  * other thread. */
-#endif /* TCL_MEM_DEBUG && TCL_THREADS */
+
 } ThreadSpecificData;
 
 static Tcl_ThreadDataKey dataKey;
 
-static void             ContLineLocFree(char *clientData);
-static void             TclThreadFinalizeContLines(ClientData clientData);
-static ThreadSpecificData *TclGetContLineTable(void);
+#endif /* TCL_MEM_DEBUG && TCL_THREADS */
 
 /*
  * Nested Tcl_Obj deletion management support
  *
  * All context references used in the object freeing code are pointers to this
@@ -497,354 +472,10 @@
     if (typeTableInitialized) {
 	Tcl_DeleteHashTable(&typeTable);
 	typeTableInitialized = 0;
     }
     Tcl_MutexUnlock(&tableMutex);
-
-    /*
-     * All we do here is reset the head pointer of the linked list of free
-     * Tcl_Obj's to NULL; the memory finalization will take care of releasing
-     * memory for us.
-     */
-    Tcl_MutexLock(&tclObjMutex);
-    tclFreeObjList = NULL;
-    Tcl_MutexUnlock(&tclObjMutex);
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclGetContLineTable --
- *
- *	This procedure is a helper which returns the thread-specific
- *	hash-table used to track continuation line information associated with
- *	Tcl_Obj*, and the objThreadMap, etc.
- *
- * Results:
- *	A reference to the thread-data.
- *
- * Side effects:
- *	May allocate memory for the thread-data.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-static ThreadSpecificData *
-TclGetContLineTable(void)
-{
-    /*
-     * Initialize the hashtable tracking invisible continuation lines.  For
-     * the release we use a thread exit handler to ensure that this is done
-     * before TSD blocks are made invalid. The TclFinalizeObjects() which
-     * would be the natural place for this is invoked afterwards, meaning that
-     * we try to operate on a data structure already gone.
-     */
-
-    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
-
-    if (!tsdPtr->lineCLPtr) {
-	tsdPtr->lineCLPtr = ckalloc(sizeof(Tcl_HashTable));
-	Tcl_InitHashTable(tsdPtr->lineCLPtr, TCL_ONE_WORD_KEYS);
-	Tcl_CreateThreadExitHandler(TclThreadFinalizeContLines,NULL);
-    }
-    return tsdPtr;
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclContinuationsEnter --
- *
- *	This procedure is a helper which saves the continuation line
- *	information associated with a Tcl_Obj*.
- *
- * Results:
- *	A reference to the newly created continuation line location table.
- *
- * Side effects:
- *	Allocates memory for the table of continuation line locations.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-ContLineLoc *
-TclContinuationsEnter(
-    Tcl_Obj *objPtr,
-    int num,
-    int *loc)
-{
-    int newEntry;
-    ThreadSpecificData *tsdPtr = TclGetContLineTable();
-    Tcl_HashEntry *hPtr =
-	    Tcl_CreateHashEntry(tsdPtr->lineCLPtr, objPtr, &newEntry);
-    ContLineLoc *clLocPtr = ckalloc(sizeof(ContLineLoc) + num*sizeof(int));
-
-    if (!newEntry) {
-	/*
-	 * We're entering ContLineLoc data for the same value more than one
-	 * time. Taking care not to leak the old entry.
-	 *
-	 * This can happen when literals in a proc body are shared. See for
-	 * example test info-30.19 where the action (code) for all branches of
-	 * the switch command is identical, mapping them all to the same
-	 * literal. An interesting result of this is that the number and
-	 * locations (offset) of invisible continuation lines in the literal
-	 * are the same for all occurences.
-	 *
-	 * Note that while reusing the existing entry is possible it requires
-	 * the same actions as for a new entry because we have to copy the
-	 * incoming num/loc data even so. Because we are called from
-	 * TclContinuationsEnterDerived for this case, which modified the
-	 * stored locations (Rebased to the proper relative offset). Just
-	 * returning the stored entry would rebase them a second time, or
-	 * more, hosing the data. It is easier to simply replace, as we are
-	 * doing.
-	 */
-
-	ckfree(Tcl_GetHashValue(hPtr));
-    }
-
-    clLocPtr->num = num;
-    memcpy(&clLocPtr->loc, loc, num*sizeof(int));
-    clLocPtr->loc[num] = CLL_END;       /* Sentinel */
-    Tcl_SetHashValue(hPtr, clLocPtr);
-
-    return clLocPtr;
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclContinuationsEnterDerived --
- *
- *	This procedure is a helper which computes the continuation line
- *	information associated with a Tcl_Obj* cut from the middle of a
- *	script.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	Allocates memory for the table of continuation line locations.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclContinuationsEnterDerived(
-    Tcl_Obj *objPtr,
-    int start,
-    int *clNext)
-{
-    int length, end, num;
-    int *wordCLLast = clNext;
-
-    /*
-     * We have to handle invisible continuations lines here as well, despite
-     * the code we have in TclSubstTokens (TST) for that. Why ?  Nesting. If
-     * our script is the sole argument to an 'eval' command, for example, the
-     * scriptCLLocPtr we are using was generated by a previous call to TST,
-     * and while the words we have here may contain continuation lines they
-     * are invisible already, and the inner call to TST had no bs+nl sequences
-     * to trigger its code.
-     *
-     * Luckily for us, the table we have to create here for the current word
-     * has to be a slice of the table currently in use, with the locations
-     * suitably modified to be relative to the start of the word instead of
-     * relative to the script.
-     *
-     * That is what we are doing now. Determine the slice we need, and if not
-     * empty, wrap it into a new table, and save the result into our
-     * thread-global hashtable, as usual.
-     */
-
-    /*
-     * First compute the range of the word within the script. (Is there a
-     * better way which doesn't shimmer?)
-     */
-
-    Tcl_GetStringFromObj(objPtr, &length);
-    end = start + length;       /* First char after the word */
-
-    /*
-     * Then compute the table slice covering the range of the word.
-     */
-
-    while (*wordCLLast >= 0 && *wordCLLast < end) {
-	wordCLLast++;
-    }
-
-    /*
-     * And generate the table from the slice, if it was not empty.
-     */
-
-    num = wordCLLast - clNext;
-    if (num) {
-	int i;
-	ContLineLoc *clLocPtr = TclContinuationsEnter(objPtr, num, clNext);
-
-	/*
-	 * Re-base the locations.
-	 */
-
-	for (i=0 ; i<num ; i++) {
-	    clLocPtr->loc[i] -= start;
-
-	    /*
-	     * Continuation lines coming before the string and affecting us
-	     * should not happen, due to the proper maintenance of clNext
-	     * during compilation.
-	     */
-
-	    if (clLocPtr->loc[i] < 0) {
-		Tcl_Panic("Derived ICL data for object using offsets from before the script");
-	    }
-	}
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclContinuationsCopy --
- *
- *	This procedure is a helper which copies the continuation line
- *	information associated with a Tcl_Obj* to another Tcl_Obj*. It is
- *	assumed that both contain the same string/script. Use this when a
- *	script is duplicated because it was shared.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	Allocates memory for the table of continuation line locations.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-void
-TclContinuationsCopy(
-    Tcl_Obj *objPtr,
-    Tcl_Obj *originObjPtr)
-{
-    ThreadSpecificData *tsdPtr = TclGetContLineTable();
-    Tcl_HashEntry *hPtr =
-            Tcl_FindHashEntry(tsdPtr->lineCLPtr, originObjPtr);
-
-    if (hPtr) {
-	ContLineLoc *clLocPtr = Tcl_GetHashValue(hPtr);
-
-	TclContinuationsEnter(objPtr, clLocPtr->num, clLocPtr->loc);
-    }
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclContinuationsGet --
- *
- *	This procedure is a helper which retrieves the continuation line
- *	information associated with a Tcl_Obj*, if it has any.
- *
- * Results:
- *	A reference to the continuation line location table, or NULL if the
- *	Tcl_Obj* has no such information associated with it.
- *
- * Side effects:
- *	None.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-ContLineLoc *
-TclContinuationsGet(
-    Tcl_Obj *objPtr)
-{
-    ThreadSpecificData *tsdPtr = TclGetContLineTable();
-    Tcl_HashEntry *hPtr =
-            Tcl_FindHashEntry(tsdPtr->lineCLPtr, objPtr);
-
-    if (!hPtr) {
-        return NULL;
-    }
-    return Tcl_GetHashValue(hPtr);
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * TclThreadFinalizeContLines --
- *
- *	This procedure is a helper which releases all continuation line
- *	information currently known. It is run as a thread exit handler.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	Releases memory.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-static void
-TclThreadFinalizeContLines(
-    ClientData clientData)
-{
-    /*
-     * Release the hashtable tracking invisible continuation lines.
-     */
-
-    ThreadSpecificData *tsdPtr = TclGetContLineTable();
-    Tcl_HashEntry *hPtr;
-    Tcl_HashSearch hSearch;
-
-    for (hPtr = Tcl_FirstHashEntry(tsdPtr->lineCLPtr, &hSearch);
-	    hPtr != NULL; hPtr = Tcl_NextHashEntry(&hSearch)) {
-	/*
-	 * We are not using Tcl_EventuallyFree (as in TclFreeObj()) because
-	 * here we can be sure that the compiler will not hold references to
-	 * the data in the hashtable, and using TEF might bork the
-	 * finalization sequence.
-	 */
-
-	ContLineLocFree(Tcl_GetHashValue(hPtr));
-	Tcl_DeleteHashEntry(hPtr);
-    }
-    Tcl_DeleteHashTable(tsdPtr->lineCLPtr);
-    ckfree(tsdPtr->lineCLPtr);
-    tsdPtr->lineCLPtr = NULL;
-}
-
-/*
- *----------------------------------------------------------------------
- *
- * ContLineLocFree --
- *
- *	The freProc for continuation line location tables.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	Releases memory.
- *
- * TIP #280
- *----------------------------------------------------------------------
- */
-
-static void
-ContLineLocFree(
-    char *clientData)
-{
-    ckfree(clientData);
 }
 
 /*
  *--------------------------------------------------------------
  *
@@ -1240,63 +871,10 @@
 #endif /* TCL_MEM_DEBUG */
 
 /*
  *----------------------------------------------------------------------
  *
- * TclAllocateFreeObjects --
- *
- *	Function to allocate a number of free Tcl_Objs. This is done using a
- *	single ckalloc to reduce the overhead for Tcl_Obj allocation.
- *
- *	Assumes mutex is held.
- *
- * Results:
- *	None.
- *
- * Side effects:
- *	tclFreeObjList, the head of the list of free Tcl_Objs, is set to the
- *	first of a number of free Tcl_Obj's linked together by their
- *	internalRep.otherValuePtrs.
- *
- *----------------------------------------------------------------------
- */
-
-#define OBJS_TO_ALLOC_EACH_TIME 100
-
-void
-TclAllocateFreeObjects(void)
-{
-    size_t bytesToAlloc = (OBJS_TO_ALLOC_EACH_TIME * sizeof(Tcl_Obj));
-    char *basePtr;
-    register Tcl_Obj *prevPtr, *objPtr;
-    register int i;
-
-    /*
-     * This has been noted by Purify to be a potential leak. The problem is
-     * that Tcl, when not TCL_MEM_DEBUG compiled, keeps around all allocated
-     * Tcl_Obj's, pointed to by tclFreeObjList, when freed instead of actually
-     * freeing the memory. TclFinalizeObjects() does not ckfree() this memory,
-     * but leaves it to Tcl's memory subsystem finalization to release it.
-     * Purify apparently can't figure that out, and fires a false alarm.
-     */
-
-    basePtr = ckalloc(bytesToAlloc);
-
-    prevPtr = NULL;
-    objPtr = (Tcl_Obj *) basePtr;
-    for (i = 0; i < OBJS_TO_ALLOC_EACH_TIME; i++) {
-	objPtr->internalRep.otherValuePtr = prevPtr;
-	prevPtr = objPtr;
-	objPtr++;
-    }
-    tclFreeObjList = prevPtr;
-}
-#undef OBJS_TO_ALLOC_EACH_TIME
-
-/*
- *----------------------------------------------------------------------
- *
  * TclFreeObj --
  *
  *	This function frees the memory associated with the argument object.
  *	It is called by the tcl.h macro Tcl_DecrRefCount when an object's ref
  *	count is zero. It is only "public" since it must be callable by that
@@ -1338,11 +916,10 @@
      * pointer chain, and signal an obj deletion (as opposed to shimmering)
      * with 'length == -1'.
      */
 
     TclInvalidateStringRep(objPtr);
-    objPtr->length = -1;
 
     if (ObjDeletePending(context)) {
 	PushObjToDelete(context, objPtr);
     } else {
 	TCL_DTRACE_OBJ_FREE(objPtr);
@@ -1370,32 +947,10 @@
 	    TclIncrObjsFreed();
 	}
 	ObjDeletionUnlock(context);
     }
 
-    /*
-     * We cannot use TclGetContinuationTable() here, because that may
-     * re-initialize the thread-data for calls coming after the finalization.
-     * We have to access it using the low-level call and then check for
-     * validity. This function can be called after TclFinalizeThreadData() has
-     * already killed the thread-global data structures. Performing
-     * TCL_TSD_INIT will leave us with an un-initialized memory block upon
-     * which we crash (if we where to access the uninitialized hashtable).
-     */
-
-    {
-	ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
-        Tcl_HashEntry *hPtr;
-
-	if (tsdPtr->lineCLPtr) {
-            hPtr = Tcl_FindHashEntry(tsdPtr->lineCLPtr, objPtr);
-	    if (hPtr) {
-		Tcl_EventuallyFree(Tcl_GetHashValue(hPtr), ContLineLocFree);
-		Tcl_DeleteHashEntry(hPtr);
-	    }
-	}
-    }
 }
 #else /* TCL_MEM_DEBUG */
 
 void
 TclFreeObj(
@@ -1406,11 +961,10 @@
      * pointer chain, and signal an obj deletion (as opposed to shimmering)
      * with 'length == -1'.
      */
 
     TclInvalidateStringRep(objPtr);
-    objPtr->length = -1;
 
     if (!objPtr->typePtr || !objPtr->typePtr->freeIntRepProc) {
 	/*
 	 * objPtr can be freed safely, as it will not attempt to free any
 	 * other objects: it will not cause recursive calls to this function.
@@ -1461,59 +1015,12 @@
 	    }
 	    ObjDeletionUnlock(context);
 	}
     }
 
-    /*
-     * We cannot use TclGetContinuationTable() here, because that may
-     * re-initialize the thread-data for calls coming after the finalization.
-     * We have to access it using the low-level call and then check for
-     * validity. This function can be called after TclFinalizeThreadData() has
-     * already killed the thread-global data structures. Performing
-     * TCL_TSD_INIT will leave us with an un-initialized memory block upon
-     * which we crash (if we where to access the uninitialized hashtable).
-     */
-
-    {
-	ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
-        Tcl_HashEntry *hPtr;
-
-	if (tsdPtr->lineCLPtr) {
-            hPtr = Tcl_FindHashEntry(tsdPtr->lineCLPtr, objPtr);
-	    if (hPtr) {
-		Tcl_EventuallyFree(Tcl_GetHashValue(hPtr), ContLineLocFree);
-		Tcl_DeleteHashEntry(hPtr);
-	    }
-	}
-    }
 }
 #endif /* TCL_MEM_DEBUG */
-
-/*
- *----------------------------------------------------------------------
- *
- * TclObjBeingDeleted --
- *
- *	This function returns 1 when the Tcl_Obj is being deleted. It is
- *	provided for the rare cases where the reason for the loss of an
- *	internal rep might be relevant. [FR 1512138]
- *
- * Results:
- *	1 if being deleted, 0 otherwise.
- *
- * Side effects:
- *	None.
- *
- *----------------------------------------------------------------------
- */
-
-int
-TclObjBeingDeleted(
-    Tcl_Obj *objPtr)
-{
-    return (objPtr->length == -1);
-}
 
 /*
  *----------------------------------------------------------------------
  *
  * Tcl_DuplicateObj --

ADDED    generic/tclObjAlloc.c
Index: generic/tclParse.c
==================================================================
--- generic/tclParse.c
+++ generic/tclParse.c
@@ -1147,18 +1147,18 @@
 	     * parse information.
 	     */
 
 	    src++;
 	    numBytes--;
-	    nestedPtr = TclStackAlloc(parsePtr->interp, sizeof(Tcl_Parse));
+	    nestedPtr = ckalloc(sizeof(Tcl_Parse));
 	    while (1) {
 		if (Tcl_ParseCommand(parsePtr->interp, src, numBytes, 1,
 			nestedPtr) != TCL_OK) {
 		    parsePtr->errorType = nestedPtr->errorType;
 		    parsePtr->term = nestedPtr->term;
 		    parsePtr->incomplete = nestedPtr->incomplete;
-		    TclStackFree(parsePtr->interp, nestedPtr);
+		    ckfree(nestedPtr);
 		    return TCL_ERROR;
 		}
 		src = nestedPtr->commandStart + nestedPtr->commandSize;
 		numBytes = parsePtr->end - src;
 		Tcl_FreeParse(nestedPtr);
@@ -1180,15 +1180,15 @@
 				"missing close-bracket", -1));
 		    }
 		    parsePtr->errorType = TCL_PARSE_MISSING_BRACKET;
 		    parsePtr->term = tokenPtr->start;
 		    parsePtr->incomplete = 1;
-		    TclStackFree(parsePtr->interp, nestedPtr);
+		    ckfree(nestedPtr);
 		    return TCL_ERROR;
 		}
 	    }
-	    TclStackFree(parsePtr->interp, nestedPtr);
+	    ckfree(nestedPtr);
 	    tokenPtr->type = TCL_TOKEN_COMMAND;
 	    tokenPtr->size = src - tokenPtr->start;
 	    parsePtr->numTokens++;
 	} else if (*src == '\\') {
 	    if (noSubstBS) {
@@ -1544,14 +1544,14 @@
 				 * character just after last one in the
 				 * variable specifier. */
 {
     register Tcl_Obj *objPtr;
     int code;
-    Tcl_Parse *parsePtr = TclStackAlloc(interp, sizeof(Tcl_Parse));
+    Tcl_Parse *parsePtr = ckalloc(sizeof(Tcl_Parse));
 
     if (Tcl_ParseVarName(interp, start, -1, parsePtr, 0) != TCL_OK) {
-	TclStackFree(interp, parsePtr);
+	ckfree(parsePtr);
 	return NULL;
     }
 
     if (termPtr != NULL) {
 	*termPtr = start + parsePtr->tokenPtr->size;
@@ -1559,17 +1559,17 @@
     if (parsePtr->numTokens == 1) {
 	/*
 	 * There isn't a variable name after all: the $ is just a $.
 	 */
 
-	TclStackFree(interp, parsePtr);
+	ckfree(parsePtr);
 	return "$";
     }
 
     code = TclSubstTokens(interp, parsePtr->tokenPtr, parsePtr->numTokens,
-	    NULL, 1, NULL, NULL);
-    TclStackFree(interp, parsePtr);
+	    NULL);
+    ckfree(parsePtr);
     if (code != TCL_OK) {
 	return NULL;
     }
     objPtr = Tcl_GetObjResult(interp);
 
@@ -2028,11 +2028,11 @@
 		 */
 
 		Tcl_Token *tokenPtr;
 		const char *lastTerm = parsePtr->term;
 		Tcl_Parse *nestedPtr =
-			TclStackAlloc(interp, sizeof(Tcl_Parse));
+			ckalloc(sizeof(Tcl_Parse));
 
 		while (TCL_OK ==
 			Tcl_ParseCommand(NULL, p, length, 0, nestedPtr)) {
 		    Tcl_FreeParse(nestedPtr);
 		    p = nestedPtr->term + (nestedPtr->term < nestedPtr->end);
@@ -2046,11 +2046,11 @@
 
 			break;
 		    }
 		    lastTerm = nestedPtr->term;
 		}
-		TclStackFree(interp, nestedPtr);
+		ckfree(nestedPtr);
 
 		if (lastTerm == parsePtr->term) {
 		    /*
 		     * Parse error in first command. No commands to subst, add
 		     * no more tokens.
@@ -2108,37 +2108,17 @@
 				 * errors. */
     Tcl_Token *tokenPtr,	/* Pointer to first in an array of tokens to
 				 * evaluate and concatenate. */
     int count,			/* Number of tokens to consider at tokenPtr.
 				 * Must be at least 1. */
-    int *tokensLeftPtr,		/* If not NULL, points to memory where an
+    int *tokensLeftPtr)		/* If not NULL, points to memory where an
 				 * integer representing the number of tokens
 				 * left to be substituted will be written */
-    int line,			/* The line the script starts on. */
-    int *clNextOuter,		/* Information about an outer context for */
-    const char *outerScript)	/* continuation line data. This is set by
-				 * EvalEx() to properly handle [...]-nested
-				 * commands. The 'outerScript' refers to the
-				 * most-outer script containing the embedded
-				 * command, which is refered to by 'script'.
-				 * The 'clNextOuter' refers to the current
-				 * entry in the table of continuation lines in
-				 * this "master script", and the character
-				 * offsets are relative to the 'outerScript'
-				 * as well.
-				 *
-				 * If outerScript == script, then this call is
-				 * for words in the outer-most script or
-				 * command. See Tcl_EvalEx and TclEvalObjEx
-				 * for the places generating arguments for
-				 * which this is true. */
 {
     Tcl_Obj *result;
     int code = TCL_OK;
 #define NUM_STATIC_POS 20
-    int isLiteral, maxNumCL, numCL, i, adjust;
-    int *clPosition = NULL;
     Interp *iPtr = (Interp *) interp;
     int inFile = iPtr->evalFlags & TCL_EVAL_FILE;
 
     /*
      * Each pass through this loop will substitute one token, and its
@@ -2148,35 +2128,10 @@
      *
      * Further optimization opportunities might be to check for the equivalent
      * of Tcl_SetObjResult(interp, Tcl_GetObjResult(interp)) and omit them.
      */
 
-    /*
-     * For the handling of continuation lines in literals we first check if
-     * this is actually a literal. For if not we can forego the additional
-     * processing. Otherwise we pre-allocate a small table to store the
-     * locations of all continuation lines we find in this literal, if any.
-     * The table is extended if needed.
-     */
-
-    numCL = 0;
-    maxNumCL = 0;
-    isLiteral = 1;
-    for (i=0 ; i < count; i++) {
-	if ((tokenPtr[i].type != TCL_TOKEN_TEXT)
-		&& (tokenPtr[i].type != TCL_TOKEN_BS)) {
-	    isLiteral = 0;
-	    break;
-	}
-    }
-
-    if (isLiteral) {
-	maxNumCL = NUM_STATIC_POS;
-	clPosition = ckalloc(maxNumCL * sizeof(int));
-    }
-
-    adjust = 0;
     result = NULL;
     for (; count>0 && code==TCL_OK ; count--, tokenPtr++) {
 	Tcl_Obj *appendObj = NULL;
 	const char *append = NULL;
 	int appendByteLength = 0;
@@ -2190,68 +2145,22 @@
 
 	case TCL_TOKEN_BS:
 	    appendByteLength = TclParseBackslash(tokenPtr->start,
 		    tokenPtr->size, NULL, utfCharBytes);
 	    append = utfCharBytes;
-
-	    /*
-	     * If the backslash sequence we found is in a literal, and
-	     * represented a continuation line, we compute and store its
-	     * location (as char offset to the beginning of the _result_
-	     * script). We may have to extend the table of locations.
-	     *
-	     * Note that the continuation line information is relevant even if
-	     * the word we are processing is not a literal, as it can affect
-	     * nested commands. See the branch for TCL_TOKEN_COMMAND below,
-	     * where the adjustment we are tracking here is taken into
-	     * account. The good thing is that we do not need a table of
-	     * everything, just the number of lines we have to add as
-	     * correction.
-	     */
-
-	    if ((appendByteLength == 1) && (utfCharBytes[0] == ' ')
-		    && (tokenPtr->start[1] == '\n')) {
-		if (isLiteral) {
-		    int clPos;
-
-		    if (result == 0) {
-			clPos = 0;
-		    } else {
-			Tcl_GetStringFromObj(result, &clPos);
-		    }
-
-		    if (numCL >= maxNumCL) {
-			maxNumCL *= 2;
-			clPosition = ckrealloc(clPosition,
-				maxNumCL * sizeof(int));
-		    }
-		    clPosition[numCL] = clPos;
-		    numCL++;
-		}
-		adjust++;
-	    }
 	    break;
 
 	case TCL_TOKEN_COMMAND: {
-	    /* TIP #280: Transfer line information to nested command */
 	    iPtr->numLevels++;
 	    code = TclInterpReady(interp);
 	    if (code == TCL_OK) {
 		/*
 		 * Test cases: info-30.{6,8,9}
 		 */
 
-		int theline;
-
-		TclAdvanceContinuations(&line, &clNextOuter,
-			tokenPtr->start - outerScript);
-		theline = line + adjust;
-		code = TclEvalEx(interp, tokenPtr->start+1, tokenPtr->size-2,
-			0, theline, clNextOuter, outerScript);
-
-		TclAdvanceLines(&line, tokenPtr->start+1,
-			tokenPtr->start + tokenPtr->size - 1);
+		code = Tcl_EvalEx(interp, tokenPtr->start+1,
+			tokenPtr->size-2, 0);
 
 		/*
 		 * Restore flag reset by nested eval for future bracketed
 		 * commands and their cmdframe setup
 		 */
@@ -2274,11 +2183,11 @@
 		/*
 		 * Subst the index part of an array variable reference.
 		 */
 
 		code = TclSubstTokens(interp, tokenPtr+2,
-			tokenPtr->numComponents - 1, NULL, line, NULL, NULL);
+			tokenPtr->numComponents - 1, NULL);
 		arrayIndex = Tcl_GetObjResult(interp);
 		Tcl_IncrRefCount(arrayIndex);
 	    }
 
 	    if (code == TCL_OK) {
@@ -2358,31 +2267,10 @@
     }
 
     if (code != TCL_ERROR) {		/* Keep error message in result! */
 	if (result != NULL) {
 	    Tcl_SetObjResult(interp, result);
-
-	    /*
-	     * If the code found continuation lines (which implies that this
-	     * word is a literal), then we store the accumulated table of
-	     * locations in the thread-global data structure for the bytecode
-	     * compiler to find later, assuming that the literal is a script
-	     * which will be compiled.
-	     */
-
-	    if (numCL) {
-		TclContinuationsEnter(result, numCL, clPosition);
-	    }
-
-	    /*
-	     * Release the temp table we used to collect the locations of
-	     * continuation lines, if any.
-	     */
-
-	    if (maxNumCL) {
-		ckfree(clPosition);
-	    }
 	} else {
 	    Tcl_ResetResult(interp);
 	}
     }
     if (tokensLeftPtr != NULL) {

Index: generic/tclPreserve.c
==================================================================
Index: generic/tclProc.c
==================================================================
--- generic/tclProc.c
+++ generic/tclProc.c
@@ -23,11 +23,10 @@
  */
 
 typedef struct {
     int isRootEnsemble;
     Command cmd;
-    ExtraFrameInfo efi;
 } ApplyExtraData;
 
 /*
  * Prototypes for static functions in this file
  */
@@ -211,105 +210,10 @@
      * namespace if the proc was renamed into a different namespace.
      */
 
     procPtr->cmdPtr = (Command *) cmd;
 
-    /*
-     * TIP #280: Remember the line the procedure body is starting on. In a
-     * bytecode context we ask the engine to provide us with the necessary
-     * information. This is for the initialization of the byte code compiler
-     * when the body is used for the first time.
-     *
-     * This code is nearly identical to the #280 code in SetLambdaFromAny, see
-     * this file. The differences are the different index of the body in the
-     * line array of the context, and the lamdba code requires some special
-     * processing. Find a way to factor the common elements into a single
-     * function.
-     */
-
-    if (iPtr->cmdFramePtr) {
-	CmdFrame *contextPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-
-	*contextPtr = *iPtr->cmdFramePtr;
-	if (contextPtr->type == TCL_LOCATION_BC) {
-	    /*
-	     * Retrieve source information from the bytecode, if possible. If
-	     * the information is retrieved successfully, context.type will be
-	     * TCL_LOCATION_SOURCE and the reference held by
-	     * context.data.eval.path will be counted.
-	     */
-
-	    TclGetSrcInfoForPc(contextPtr);
-	} else if (contextPtr->type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * The copy into 'context' up above has created another reference
-	     * to 'context.data.eval.path'; account for it.
-	     */
-
-	    Tcl_IncrRefCount(contextPtr->data.eval.path);
-	}
-
-	if (contextPtr->type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * We can account for source location within a proc only if the
-	     * proc body was not created by substitution.
-	     */
-
-	    if (contextPtr->line
-		    && (contextPtr->nline >= 4) && (contextPtr->line[3] >= 0)) {
-		int isNew;
-		Tcl_HashEntry *hePtr;
-		CmdFrame *cfPtr = ckalloc(sizeof(CmdFrame));
-
-		cfPtr->level = -1;
-		cfPtr->type = contextPtr->type;
-		cfPtr->line = ckalloc(sizeof(int));
-		cfPtr->line[0] = contextPtr->line[3];
-		cfPtr->nline = 1;
-		cfPtr->framePtr = NULL;
-		cfPtr->nextPtr = NULL;
-
-		cfPtr->data.eval.path = contextPtr->data.eval.path;
-		Tcl_IncrRefCount(cfPtr->data.eval.path);
-
-		cfPtr->cmd.str.cmd = NULL;
-		cfPtr->cmd.str.len = 0;
-
-		hePtr = Tcl_CreateHashEntry(iPtr->linePBodyPtr,
-			procPtr, &isNew);
-		if (!isNew) {
-		    /*
-		     * Get the old command frame and release it. See also
-		     * TclProcCleanupProc in this file. Currently it seems as
-		     * if only the procbodytest::proc command of the testsuite
-		     * is able to trigger this situation.
-		     */
-
-		    CmdFrame *cfOldPtr = Tcl_GetHashValue(hePtr);
-
-		    if (cfOldPtr->type == TCL_LOCATION_SOURCE) {
-			Tcl_DecrRefCount(cfOldPtr->data.eval.path);
-			cfOldPtr->data.eval.path = NULL;
-		    }
-		    ckfree(cfOldPtr->line);
-		    cfOldPtr->line = NULL;
-		    ckfree(cfOldPtr);
-		}
-		Tcl_SetHashValue(hePtr, cfPtr);
-	    }
-
-	    /*
-	     * 'contextPtr' is going out of scope; account for the reference
-	     * that it's holding to the path name.
-	     */
-
-	    Tcl_DecrRefCount(contextPtr->data.eval.path);
-	    contextPtr->data.eval.path = NULL;
-	}
-	TclStackFree(interp, contextPtr);
-    }
-
     /*
      * Optimize for no-op procs: if the body is not precompiled (like a TclPro
      * procbody), and the argument list is just "args" and the body is empty,
      * define a compileProc to compile a no-op.
      *
@@ -440,22 +344,12 @@
 	 * identical. Note that we don't use Tcl_DuplicateObj since we would
 	 * not want any bytecode internal representation.
 	 */
 
 	if (Tcl_IsShared(bodyPtr)) {
-	    Tcl_Obj *sharedBodyPtr = bodyPtr;
-
 	    bytes = TclGetStringFromObj(bodyPtr, &length);
 	    bodyPtr = Tcl_NewStringObj(bytes, length);
-
-	    /*
-	     * TIP #280.
-	     * Ensure that the continuation line data for the original body is
-	     * not lost and applies to the new body as well.
-	     */
-
-	    TclContinuationsCopy(bodyPtr, sharedBodyPtr);
 	}
 
 	/*
 	 * Create and initialize a Proc structure for the procedure. We
 	 * increment the ref count of the procedure's body object since there
@@ -965,12 +859,10 @@
     int objc,			/* Number of arguments. */
     Tcl_Obj *const objv[])	/* Argument objects. */
 {
 
     register Interp *iPtr = (Interp *) interp;
-    CmdFrame *invoker = NULL;
-    int word = 0;
     int result;
     CallFrame *savedVarFramePtr, *framePtr;
     Tcl_Obj *objPtr;
 
     if (objc < 2) {
@@ -1003,17 +895,11 @@
     /*
      * Execute the residual arguments as a command.
      */
 
     if (objc == 1) {
-	/*
-	 * TIP #280. Make actual argument location available to eval'd script
-	 */
-
-	TclArgumentGet(interp, objv[0], &invoker, &word);
 	objPtr = objv[0];
-
     } else {
 	/*
 	 * More than one argument: concatenate them together with spaces
 	 * between, then evaluate the result. Tcl_EvalObjEx will delete the
 	 * object when it decrements its refcount after eval'ing it.
@@ -1022,11 +908,11 @@
 	objPtr = Tcl_ConcatObj(objc, objv);
     }
 
     TclNRAddCallback(interp, Uplevel_Callback, savedVarFramePtr, NULL, NULL,
 	    NULL);
-    return TclNREvalObjEx(interp, objPtr, 0, invoker, word);
+    return TclNREvalObjEx(interp, objPtr, 0);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -1115,12 +1001,11 @@
     /*
      * Build up desired argument list for Tcl_WrongNumArgs
      */
 
     numArgs = framePtr->procPtr->numArgs;
-    desiredObjs = TclStackAlloc(interp,
-	    (int) sizeof(Tcl_Obj *) * (numArgs+1));
+    desiredObjs = ckalloc((int) sizeof(Tcl_Obj *) * (numArgs+1));
 
     if (framePtr->isProcCallFrame & FRAME_IS_LAMBDA) {
 	desiredObjs[0] = Tcl_NewStringObj("lambdaExpr", -1);
     } else {
 	((Interp *) interp)->ensembleRewrite.numInsertedObjs -= skip - 1;
@@ -1156,11 +1041,11 @@
     Tcl_WrongNumArgs(interp, numArgs+1, desiredObjs, final);
 
     for (i=0 ; i<=numArgs ; i++) {
 	Tcl_DecrRefCount(desiredObjs[i]);
     }
-    TclStackFree(interp, desiredObjs);
+    ckfree(desiredObjs);
     return TCL_ERROR;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -1470,11 +1355,11 @@
      * Create the "compiledLocals" array. Make sure it is large enough to hold
      * all the procedure's compiled local variables, including its formal
      * parameters.
      */
 
-    varPtr = TclStackAlloc(interp, (int)(localCt * sizeof(Var)));
+    varPtr = ckalloc((int)(localCt * sizeof(Var)));
     framePtr->compiledLocals = varPtr;
     framePtr->numCompiledLocals = localCt;
 
     /*
      * Match and assign the call's actual parameters to the procedure's formal
@@ -1761,13 +1646,13 @@
 
     result = InitArgsAndLocals(interp, procNameObj, skip);
     if (result != TCL_OK) {
 	freePtr = iPtr->framePtr;
 	Tcl_PopCallFrame(interp);	/* Pop but do not free. */
-	TclStackFree(interp, freePtr->compiledLocals);
+	ckfree(freePtr->compiledLocals);
 					/* Free compiledLocals. */
-	TclStackFree(interp, freePtr);	/* Free CallFrame. */
+	ckfree(freePtr);	/* Free CallFrame. */
 	return TCL_ERROR;
     }
 
 #if defined(TCL_COMPILE_DEBUG)
     if (tclTraceExec >= 1) {
@@ -1800,18 +1685,10 @@
 	    l++;
 	}
 	TCL_DTRACE_PROC_ARGS(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7],
 		a[8], a[9]);
     }
-    if (TCL_DTRACE_PROC_INFO_ENABLED() && iPtr->cmdFramePtr) {
-	Tcl_Obj *info = TclInfoFrame(interp, iPtr->cmdFramePtr);
-	const char *a[6]; int i[2];
-
-	TclDTraceInfo(info, a, i);
-	TCL_DTRACE_PROC_INFO(a[0], a[1], a[2], a[3], i[0], i[1], a[4], a[5]);
-	TclDecrRefCount(info);
-    }
     if (TCL_DTRACE_PROC_ENTRY_ENABLED()) {
 	int l = iPtr->varFramePtr->isProcCallFrame & FRAME_IS_LAMBDA ? 1 : 0;
 
 	TCL_DTRACE_PROC_ENTRY(l < iPtr->varFramePtr->objc ?
 		TclGetString(iPtr->varFramePtr->objv[l]) : NULL,
@@ -1933,13 +1810,13 @@
      * allocated later on the stack.
      */
 
     freePtr = iPtr->framePtr;
     Tcl_PopCallFrame(interp);		/* Pop but do not free. */
-    TclStackFree(interp, freePtr->compiledLocals);
+    ckfree(freePtr->compiledLocals);
 					/* Free compiledLocals. */
-    TclStackFree(interp, freePtr);	/* Free CallFrame. */
+    ckfree(freePtr);	/* Free CallFrame. */
 
     return result;
 }
 
 /*
@@ -2013,12 +1890,10 @@
 	    TclFreeIntRep(bodyPtr);
 	}
     }
 
     if (bodyPtr->typePtr != &tclByteCodeType) {
-	Tcl_HashEntry *hePtr;
-
 #ifdef TCL_COMPILE_DEBUG
 	if (tclTraceCompile >= 1) {
 	    /*
 	     * Display a line summarizing the top level command we are about
 	     * to compile.
@@ -2080,25 +1955,11 @@
 	}
 
 	TclPushStackFrame(interp, &framePtr, (Tcl_Namespace *) nsPtr,
 		/* isProcCallFrame */ 0);
 
-	/*
-	 * TIP #280: We get the invoking context from the cmdFrame which
-	 * was saved by 'Tcl_ProcObjCmd' (using linePBodyPtr).
-	 */
-
-	hePtr = Tcl_FindHashEntry(iPtr->linePBodyPtr, (char *) procPtr);
-
-	/*
-	 * Constructed saved frame has body as word 0. See Tcl_ProcObjCmd.
-	 */
-
-	iPtr->invokeWord = 0;
-	iPtr->invokeCmdFramePtr = (hePtr ? Tcl_GetHashValue(hePtr) : NULL);
 	tclByteCodeType.setFromAnyProc(interp, bodyPtr);
-	iPtr->invokeCmdFramePtr = NULL;
 	TclPopStackFrame(interp);
     } else if (codePtr->nsEpoch != nsPtr->resolverEpoch) {
 	/*
 	 * The resolver epoch has changed, but we only need to invalidate the
 	 * resolver cache.
@@ -2200,13 +2061,10 @@
 {
     register CompiledLocal *localPtr;
     Tcl_Obj *bodyPtr = procPtr->bodyPtr;
     Tcl_Obj *defPtr;
     Tcl_ResolvedVarInfo *resVarInfo;
-    Tcl_HashEntry *hePtr = NULL;
-    CmdFrame *cfPtr = NULL;
-    Interp *iPtr = procPtr->iPtr;
 
     if (bodyPtr != NULL) {
 	Tcl_DecrRefCount(bodyPtr);
     }
     for (localPtr = procPtr->firstLocalPtr; localPtr != NULL; ) {
@@ -2227,38 +2085,10 @@
 	}
 	ckfree(localPtr);
 	localPtr = nextPtr;
     }
     ckfree(procPtr);
-
-    /*
-     * TIP #280: Release the location data associated with this Proc
-     * structure, if any. The interpreter may not exist (For example for
-     * procbody structures created by tbcload.
-     */
-
-    if (iPtr == NULL) {
-	return;
-    }
-
-    hePtr = Tcl_FindHashEntry(iPtr->linePBodyPtr, (char *) procPtr);
-    if (!hePtr) {
-	return;
-    }
-
-    cfPtr = Tcl_GetHashValue(hePtr);
-
-    if (cfPtr) {
-	if (cfPtr->type == TCL_LOCATION_SOURCE) {
-	    Tcl_DecrRefCount(cfPtr->data.eval.path);
-	    cfPtr->data.eval.path = NULL;
-	}
-	ckfree(cfPtr->line);
-	cfPtr->line = NULL;
-	ckfree(cfPtr);
-    }
-    Tcl_DeleteHashEntry(hePtr);
 }
 
 /*
  *----------------------------------------------------------------------
  *
@@ -2482,15 +2312,13 @@
 static int
 SetLambdaFromAny(
     Tcl_Interp *interp,		/* Used for error reporting if not NULL. */
     register Tcl_Obj *objPtr)	/* The object to convert. */
 {
-    Interp *iPtr = (Interp *) interp;
     const char *name;
     Tcl_Obj *argsPtr, *bodyPtr, *nsObjPtr, **objv;
-    int isNew, objc, result;
-    CmdFrame *cfPtr = NULL;
+    int objc, result;
     Proc *procPtr;
 
     if (interp == NULL) {
 	return TCL_ERROR;
     }
@@ -2531,97 +2359,10 @@
      * procPtr->refCount = 1;
      */
 
     procPtr->cmdPtr = NULL;
 
-    /*
-     * TIP #280: Remember the line the apply body is starting on. In a Byte
-     * code context we ask the engine to provide us with the necessary
-     * information. This is for the initialization of the byte code compiler
-     * when the body is used for the first time.
-     *
-     * NOTE: The body is the second word in the 'objPtr'. Its location,
-     * accessible through 'context.line[1]' (see below) is therefore only the
-     * first approximation of the actual line the body is on. We have to use
-     * the string rep of the 'objPtr' to determine the exact line. This is
-     * available already through 'name'. Use 'TclListLines', see 'switch'
-     * (tclCmdMZ.c).
-     *
-     * This code is nearly identical to the #280 code in Tcl_ProcObjCmd, see
-     * this file. The differences are the different index of the body in the
-     * line array of the context, and the special processing mentioned in the
-     * previous paragraph to track into the list. Find a way to factor the
-     * common elements into a single function.
-     */
-
-    if (iPtr->cmdFramePtr) {
-	CmdFrame *contextPtr = TclStackAlloc(interp, sizeof(CmdFrame));
-
-	*contextPtr = *iPtr->cmdFramePtr;
-	if (contextPtr->type == TCL_LOCATION_BC) {
-	    /*
-	     * Retrieve the source context from the bytecode. This call
-	     * accounts for the reference to the source file, if any, held in
-	     * 'context.data.eval.path'.
-	     */
-
-	    TclGetSrcInfoForPc(contextPtr);
-	} else if (contextPtr->type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * We created a new reference to the source file path name when we
-	     * created 'context' above. Account for the reference.
-	     */
-
-	    Tcl_IncrRefCount(contextPtr->data.eval.path);
-
-	}
-
-	if (contextPtr->type == TCL_LOCATION_SOURCE) {
-	    /*
-	     * We can record source location within a lambda only if the body
-	     * was not created by substitution.
-	     */
-
-	    if (contextPtr->line
-		    && (contextPtr->nline >= 2) && (contextPtr->line[1] >= 0)) {
-		int buf[2];
-
-		/*
-		 * Move from approximation (line of list cmd word) to actual
-		 * location (line of 2nd list element).
-		 */
-
-		cfPtr = ckalloc(sizeof(CmdFrame));
-		TclListLines(objPtr, contextPtr->line[1], 2, buf, NULL);
-
-		cfPtr->level = -1;
-		cfPtr->type = contextPtr->type;
-		cfPtr->line = ckalloc(sizeof(int));
-		cfPtr->line[0] = buf[1];
-		cfPtr->nline = 1;
-		cfPtr->framePtr = NULL;
-		cfPtr->nextPtr = NULL;
-
-		cfPtr->data.eval.path = contextPtr->data.eval.path;
-		Tcl_IncrRefCount(cfPtr->data.eval.path);
-
-		cfPtr->cmd.str.cmd = NULL;
-		cfPtr->cmd.str.len = 0;
-	    }
-
-	    /*
-	     * 'contextPtr' is going out of scope. Release the reference that
-	     * it's holding to the source file path
-	     */
-
-	    Tcl_DecrRefCount(contextPtr->data.eval.path);
-	}
-	TclStackFree(interp, contextPtr);
-    }
-    Tcl_SetHashValue(Tcl_CreateHashEntry(iPtr->linePBodyPtr, procPtr,
-	    &isNew), cfPtr);
-
     /*
      * Set the namespace for this lambda: given by objv[2] understood as a
      * global reference, or else global per default.
      */
 
@@ -2752,31 +2493,15 @@
     result = TclGetNamespaceFromObj(interp, nsObjPtr, &nsPtr);
     if (result != TCL_OK) {
 	return TCL_ERROR;
     }
 
-    extraPtr = TclStackAlloc(interp, sizeof(ApplyExtraData));
+    extraPtr = ckalloc(sizeof(ApplyExtraData));
     memset(&extraPtr->cmd, 0, sizeof(Command));
     procPtr->cmdPtr = &extraPtr->cmd;
     extraPtr->cmd.nsPtr = (Namespace *) nsPtr;
 
-    /*
-     * TIP#280 (semi-)HACK!
-     *
-     * Using cmd.clientData to tell [info frame] how to render the lambdaPtr.
-     * The InfoFrameCmd will detect this case by testing cmd.hPtr for NULL.
-     * This condition holds here because of the memset() above, and nowhere
-     * else (in the core). Regular commands always have a valid hPtr, and
-     * lambda's never.
-     */
-
-    extraPtr->efi.length = 1;
-    extraPtr->efi.fields[0].name = "lambda";
-    extraPtr->efi.fields[0].proc = NULL;
-    extraPtr->efi.fields[0].clientData = lambdaPtr;
-    extraPtr->cmd.clientData = &extraPtr->efi;
-
     isRootEnsemble = (iPtr->ensembleRewrite.sourceObjs == NULL);
     if (isRootEnsemble) {
 	iPtr->ensembleRewrite.sourceObjs = objv;
 	iPtr->ensembleRewrite.numRemovedObjs = 1;
 	iPtr->ensembleRewrite.numInsertedObjs = 0;
@@ -2803,11 +2528,11 @@
 
     if (extraPtr->isRootEnsemble) {
 	((Interp *) interp)->ensembleRewrite.sourceObjs = NULL;
     }
 
-    TclStackFree(interp, extraPtr);
+    ckfree(extraPtr);
     return result;
 }
 
 /*
  *----------------------------------------------------------------------

Index: generic/tclScan.c
==================================================================
--- generic/tclScan.c
+++ generic/tclScan.c
@@ -257,11 +257,11 @@
 {
     int gotXpg, gotSequential, value, i, flags;
     char *end;
     Tcl_UniChar ch;
     int objIndex, xpgSize, nspace = numVars;
-    int *nassign = TclStackAlloc(interp, nspace * sizeof(int));
+    int *nassign = ckalloc(nspace * sizeof(int));
     char buf[TCL_UTF_MAX+1];
     Tcl_Obj *errorMsg;		/* Place to build an error messages. Note that
 				 * these are messy operations because we do
 				 * not want to use the formatting engine;
 				 * we're inside there! */
@@ -478,12 +478,11 @@
 		if (xpgSize) {
 		    nspace = xpgSize;
 		} else {
 		    nspace += 16;	/* formerly STATIC_LIST_SIZE */
 		}
-		nassign = TclStackRealloc(interp, nassign,
-			nspace * sizeof(int));
+		nassign = ckrealloc(nassign, nspace * sizeof(int));
 		for (i = value; i < nspace; i++) {
 		    nassign[i] = 0;
 		}
 	    }
 	    nassign[objIndex]++;
@@ -524,11 +523,11 @@
 	    Tcl_SetErrorCode(interp, "TCL", "FORMAT", "UNASSIGNED", NULL);
 	    goto error;
 	}
     }
 
-    TclStackFree(interp, nassign);
+    ckfree(nassign);
     return TCL_OK;
 
   badIndex:
     if (gotXpg) {
 	Tcl_SetObjResult(interp, Tcl_NewStringObj(
@@ -540,11 +539,11 @@
 		-1));
 	Tcl_SetErrorCode(interp, "TCL", "FORMAT", "FIELDVARMISMATCH", NULL);
     }
 
   error:
-    TclStackFree(interp, nassign);
+    ckfree(nassign);
     return TCL_ERROR;
 }
 
 /*
  *----------------------------------------------------------------------

Index: generic/tclStubInit.c
==================================================================
--- generic/tclStubInit.c
+++ generic/tclStubInit.c
@@ -190,11 +190,11 @@
     TCL_STUB_MAGIC,
     0,
     0, /* 0 */
     0, /* 1 */
     0, /* 2 */
-    TclAllocateFreeObjects, /* 3 */
+    0, /* 3 */
     0, /* 4 */
     TclCleanupChildren, /* 5 */
     TclCleanupCommand, /* 6 */
     TclCopyAndCollapse, /* 7 */
     TclCopyChannelOld, /* 8 */
@@ -256,23 +256,23 @@
     TclObjInvoke, /* 64 */
     0, /* 65 */
     0, /* 66 */
     0, /* 67 */
     0, /* 68 */
-    TclpAlloc, /* 69 */
+    0, /* 69 */
     0, /* 70 */
     0, /* 71 */
     0, /* 72 */
     0, /* 73 */
-    TclpFree, /* 74 */
+    0, /* 74 */
     TclpGetClicks, /* 75 */
     TclpGetSeconds, /* 76 */
     TclpGetTime, /* 77 */
     0, /* 78 */
     0, /* 79 */
     0, /* 80 */
-    TclpRealloc, /* 81 */
+    0, /* 81 */
     0, /* 82 */
     0, /* 83 */
     0, /* 84 */
     0, /* 85 */
     0, /* 86 */
@@ -402,29 +402,29 @@
     0, /* 210 */
     0, /* 211 */
     TclpFindExecutable, /* 212 */
     TclGetObjNameOfExecutable, /* 213 */
     TclSetObjNameOfExecutable, /* 214 */
-    TclStackAlloc, /* 215 */
-    TclStackFree, /* 216 */
+    0, /* 215 */
+    0, /* 216 */
     TclPushStackFrame, /* 217 */
     TclPopStackFrame, /* 218 */
     0, /* 219 */
     0, /* 220 */
     0, /* 221 */
     0, /* 222 */
     0, /* 223 */
     TclGetPlatform, /* 224 */
     TclTraceDictPath, /* 225 */
-    TclObjBeingDeleted, /* 226 */
+    0, /* 226 */
     TclSetNsPath, /* 227 */
     0, /* 228 */
     TclPtrMakeUpvar, /* 229 */
     TclObjLookupVar, /* 230 */
     TclGetNamespaceFromObj, /* 231 */
-    TclEvalObjEx, /* 232 */
-    TclGetSrcInfoForPc, /* 233 */
+    0, /* 232 */
+    0, /* 233 */
     TclVarHashCreateVar, /* 234 */
     TclInitVarHashTable, /* 235 */
     0, /* 236 */
     TclResetCancellation, /* 237 */
     TclNRInterpProc, /* 238 */

Index: generic/tclTest.c
==================================================================
--- generic/tclTest.c
+++ generic/tclTest.c
@@ -6782,11 +6782,11 @@
     Tcl_Obj *const objv[])
 {
     Interp *iPtr = (Interp *) interp;
     static ptrdiff_t *refDepth = NULL;
     ptrdiff_t depth;
-    Tcl_Obj *levels[6];
+    Tcl_Obj *levels[5];
     int i = 0;
     NRE_callback *cbPtr = iPtr->execEnvPtr->callbackPtr;
 
     if (refDepth == NULL) {
 	refDepth = &depth;
@@ -6794,22 +6794,20 @@
 
     depth = (refDepth - &depth);
 
     levels[0] = Tcl_NewIntObj(depth);
     levels[1] = Tcl_NewIntObj(iPtr->numLevels);
-    levels[2] = Tcl_NewIntObj(iPtr->cmdFramePtr->level);
-    levels[3] = Tcl_NewIntObj(iPtr->varFramePtr->level);
-    levels[4] = Tcl_NewIntObj(iPtr->execEnvPtr->execStackPtr->tosPtr
-	    - iPtr->execEnvPtr->execStackPtr->stackWords);
+    levels[2] = Tcl_NewIntObj(iPtr->varFramePtr->level);
+
 
     while (cbPtr) {
 	i++;
 	cbPtr = cbPtr->nextPtr;
     }
-    levels[5] = Tcl_NewIntObj(i);
+    levels[3] = Tcl_NewIntObj(i);
 
-    Tcl_SetObjResult(interp, Tcl_NewListObj(6, levels));
+    Tcl_SetObjResult(interp, Tcl_NewListObj(4, levels));
     return TCL_OK;
 }
 
 /*
  *----------------------------------------------------------------------

DELETED  generic/tclThreadAlloc.c
Index: generic/tclTrace.c
==================================================================
--- generic/tclTrace.c
+++ generic/tclTrace.c
@@ -1677,11 +1677,11 @@
 
     /*
      * Copy the command characters into a new string.
      */
 
-    commandCopy = TclStackAlloc(interp, (unsigned) numChars + 1);
+    commandCopy = ckalloc((unsigned) numChars + 1);
     memcpy(commandCopy, command, (size_t) numChars);
     commandCopy[numChars] = '\0';
 
     /*
      * Call the trace function then free allocated storage.
@@ -1688,11 +1688,11 @@
      */
 
     traceCode = tracePtr->proc(tracePtr->clientData, (Tcl_Interp *) iPtr,
 	    iPtr->numLevels, commandCopy, (Tcl_Command) cmdPtr, objc, objv);
 
-    TclStackFree(interp, commandCopy);
+    ckfree(commandCopy);
     return traceCode;
 }
 
 /*
  *----------------------------------------------------------------------
@@ -2265,11 +2265,11 @@
     /*
      * This is a bit messy because we have to emulate the old trace interface,
      * which uses strings for everything.
      */
 
-    argv = (const char **) TclStackAlloc(interp,
+    argv = (const char **) ckalloc(
 	    (unsigned) ((objc + 1) * sizeof(const char *)));
     for (i = 0; i < objc; i++) {
 	argv[i] = Tcl_GetString(objv[i]);
     }
     argv[objc] = 0;
@@ -2280,11 +2280,11 @@
      * either command or argv.
      */
 
     data->proc(data->clientData, interp, level, (char *) command,
 	    cmdPtr->proc, cmdPtr->clientData, objc, argv);
-    TclStackFree(interp, (void *) argv);
+    ckfree((void *) argv);
 
     return TCL_OK;
 }
 
 /*

Index: generic/tclVar.c
==================================================================
--- generic/tclVar.c
+++ generic/tclVar.c
@@ -1929,13 +1929,10 @@
 		varPtr->value.objPtr = newValuePtr;
 		Tcl_IncrRefCount(newValuePtr);
 	    } else {
 		if (Tcl_IsShared(oldValuePtr)) {	/* Append to copy. */
 		    varPtr->value.objPtr = Tcl_DuplicateObj(oldValuePtr);
-
-		    TclContinuationsCopy(varPtr->value.objPtr, oldValuePtr);
-
 		    TclDecrRefCount(oldValuePtr);
 		    oldValuePtr = varPtr->value.objPtr;
 		    Tcl_IncrRefCount(oldValuePtr);	/* Since var is ref */
 		}
 		Tcl_AppendObjToObj(oldValuePtr, newValuePtr);

ADDED    normBench
DELETED  tests/assemble.test
DELETED  tests/assemble1.bench
Index: tests/coroutine.test
==================================================================
--- tests/coroutine.test
+++ tests/coroutine.test
@@ -17,10 +17,11 @@
 ::tcltest::loadTestedCommands
 catch [list package require -exact Tcltest [info patchlevel]]
 
 testConstraint testnrelevels [llength [info commands testnrelevels]]
 testConstraint memory [llength [info commands memory]]
+testConstraint infoframe [expr ![catch {info frame 0}]]
 
 set lambda [list {{start 0} {stop 10}} {
     # init
     set i    $start
     set imax $stop
@@ -294,11 +295,11 @@
     set l2 [b]
     expr {$l2 - $l1}
 } -cleanup {
     rename a {}
     rename b {}
-} -result 1
+} -result 1 -constraints infoframe
 test coroutine-3.3 {info coroutine} -setup {
     proc a {} {info coroutine}
     proc b {} a
 } -body {
     b
@@ -339,11 +340,11 @@
 } -body {
     coroutine aa a
 } -cleanup {
     rename stack {}
     rename a {}
-} -result {}
+} -result {} -constraints infoframe
 
 test coroutine-4.1 {bug #2093188} -setup {
     proc foo {} {
 	set v 1
 	trace add variable v {write unset} bar
@@ -481,11 +482,11 @@
 	    nestedYield
 	}
     }
     set res {}
 } -body {
-    set base [getNumLevel]
+    set base [relativeLevel 0]
     lappend res [relativeLevel $base]
     eval {coroutine a foo}
     # back to base level
     lappend res [relativeLevel $base]
     a

Index: tests/dict.test
==================================================================
--- tests/dict.test
+++ tests/dict.test
@@ -1566,10 +1566,12 @@
 	}
 	return $a,$b
     }}
 } 1,2
 
+if 0 {
+    # TEST REMOVED: uses [info frame]
 proc linenumber {} {
     dict get [info frame -1] line
 }
 test dict-23.1 {dict compilation crash: Bug 3487626} {
     apply {{} {apply {n {
@@ -1584,10 +1586,11 @@
 		}
 	    }
 	}
     }} [linenumber]}}
 } 5
+
 test dict-23.2 {dict compilation crash: Bug 3487626} knownBug {
     # Something isn't quite right in line number and continuation line
     # tracking; at time of writing, this test produces 7, not 5, which
     # indicates that the extra newlines in the non-script argument are
     # confusing things.
@@ -1616,10 +1619,11 @@
 	    }
 	}
     }} [linenumber]}}
 } 5
 rename linenumber {}
+}
 
 test dict-24.1 {dict map command: syntax} -returnCodes error -body {
     dict map
 } -result {wrong # args: should be "dict map {keyVar valueVar} dictionary script"}
 test dict-24.2 {dict map command: syntax} -returnCodes error -body {
@@ -1800,10 +1804,13 @@
     apply {{x y args} {
 	dict map {a b} $x {}
 	concat "c=$y,$args"
     }} {} 1 2 3
 } {c=1,2 3}
+
+if 0 {
+    # TEST REMOVED: uses [info frame]
 proc linenumber {} {
     dict get [info frame -1] line
 }
 test dict-24.20.1 {dict compilation crash: 'dict for' bug 3487626} {
     apply {{} {apply {n {
@@ -1818,10 +1825,11 @@
 		}
 	    }
 	}
     }} [linenumber]}}
 } 5
+
 test dict-24.21 {dict compilation crash: 'dict for' bug 3487626} knownBug {
     apply {{} {apply {n {
 	set e {}
 	set k {}
 	dict map {a {
@@ -1846,10 +1854,12 @@
 	    }
 	}
     }} [linenumber]}}
 } 5
 rename linenumber {}
+}
+
 test dict-24.22 {dict map results (non-compiled)} {
     dict map {k v} [dict map {k v} {a 1 b 2 c 3 d 4} { list $v $k }] {
 	return -level 0 "$k,$v"
     }
 } {a {a,1 a} b {b,2 b} c {c,3 c} d {d,4 d}}

Index: tests/info.test
==================================================================
--- tests/info.test
+++ tests/info.test
@@ -676,20 +676,28 @@
 test info-21.1 {miscellaneous error conditions} -returnCodes error -body {
     info
 } -result {wrong # args: should be "info subcommand ?arg ...?"}
 test info-21.2 {miscellaneous error conditions} -returnCodes error -body {
     info gorp
-} -result {unknown or ambiguous subcommand "gorp": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, frame, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
+} -result {unknown or ambiguous subcommand "gorp": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
 test info-21.3 {miscellaneous error conditions} -returnCodes error -body {
     info c
-} -result {unknown or ambiguous subcommand "c": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, frame, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
+} -result {unknown or ambiguous subcommand "c": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
 test info-21.4 {miscellaneous error conditions} -returnCodes error -body {
     info l
-} -result {unknown or ambiguous subcommand "l": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, frame, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
+} -result {unknown or ambiguous subcommand "l": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
 test info-21.5 {miscellaneous error conditions} -returnCodes error -body {
     info s
-} -result {unknown or ambiguous subcommand "s": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, frame, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
+} -result {unknown or ambiguous subcommand "s": must be args, body, class, cmdcount, commands, complete, coroutine, default, errorstack, exists, functions, globals, hostname, level, library, loaded, locals, nameofexecutable, object, patchlevel, procs, script, sharedlibextension, tclversion, or vars}
+
+## DONE!! The rest is [info frame]
+
+# cleanup
+catch {namespace delete test_ns_info1 test_ns_info2}
+::tcltest::cleanupTests
+return
+
 
 ##
 # ### ### ### ######### ######### #########
 ## info frame
 

Index: tests/nre.test
==================================================================
--- tests/nre.test
+++ tests/nre.test
@@ -26,13 +26,14 @@
 
 if {[testConstraint testnrelevels]} {
     namespace eval testnre {
 	namespace path ::tcl::mathop
 	#
-	# [testnrelevels] returns a 6-list with: C-stack depth, iPtr->numlevels,
-	# cmdFrame level, callFrame level, tosPtr and callback depth 
+	# [testnrelevels] returns a 4-list with: C-stack depth, iPtr->numlevels,
+	# callFrame level and callback depth 
 	#
+
 	variable last [testnrelevels] 
 	proc depthDiff {} {
 	    variable last
 	    set depth [testnrelevels]
 	    set res {}
@@ -50,11 +51,11 @@
 	    set x [depthDiff]
 	    if {[incr i] > 10} {
 		namespace upvar [namespace qualifiers \
 			[namespace origin depthDiff]] abs abs
 		incr abs [lindex [testnrelevels] 0]
-		return [list [lrange $x 0 3] $abs]
+		return [list [lrange $x 0 2] $abs]
 	    }
 	}
 	proc makebody txt {
 	    variable body0
 	    return "$body0; $txt"
@@ -61,31 +62,31 @@
 	}
 	namespace export *
     }
     namespace import testnre::*
 }
-
+
 test nre-1.1 {self-recursive procs} -setup {
     proc a i [makebody {a $i}]
 } -body {
     setabs
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 1 1 1} 0}
+} -result {{0 1 1} 0}
 test nre-1.2 {self-recursive lambdas} -setup {
     set a [list i [makebody {apply $::a $i}]]
 } -body {
     setabs
     apply $a 0
 } -cleanup {
     unset a
 } -constraints {
     testnrelevels
-} -result {{0 1 1 1} 0}
+} -result {{0 1 1} 0}
 test nre-1.3 {mutually recursive procs and lambdas} -setup {
     proc a i {
 	apply $::b [incr i]
     }
     set b [list i [makebody {a $i}]]
@@ -95,11 +96,11 @@
 } -cleanup {
     rename a {}
     unset b
 } -constraints {
     testnrelevels
-} -result {{0 2 2 2} 0}
+} -result {{0 2 2} 0}
 
 #
 # Test that aliases are non-recursive
 #
 
@@ -112,11 +113,11 @@
 } -cleanup {
     rename a {}
     rename b {}
 } -constraints {
     testnrelevels
-} -result {{0 2 1 1} 0}
+} -result {{0 2 1} 0}
 
 #
 # Test that imports are non-recursive
 #
 
@@ -132,11 +133,11 @@
 } -cleanup {
     rename a {}
     namespace delete ::foo
 } -constraints {
     testnrelevels
-} -result {{0 2 1 1} 0}
+} -result {{0 2 1} 0}
 
 test nre-4.1 {ensembles are not recursive} -setup {
     proc a i [makebody {b foo $i}]
     namespace ensemble create \
 	-command b \
@@ -147,11 +148,11 @@
 } -cleanup {
     rename a {}
     rename b {}
 } -constraints {
     testnrelevels
-} -result {{0 2 1 1} 0}
+} -result {{0 2 1} 0}
 
 test nre-5.1 {[namespace eval] is not recursive} -setup {
     namespace eval ::foo {
 	setabs
     }
@@ -160,11 +161,12 @@
     ::foo::a 0
 } -cleanup {
     namespace delete ::foo
 } -constraints {
     testnrelevels
-} -result {{0 2 2 2} 0}
+} -result {{0 2 2} 0}
+
 test nre-5.2 {[namespace eval] is not recursive} -setup {
     namespace eval ::foo {
 	setabs
     }
     proc foo::a i [makebody {namespace eval ::foo "set x $i; a $i"}]
@@ -172,11 +174,11 @@
     foo::a 0
 } -cleanup {
     namespace delete ::foo
 } -constraints {
     testnrelevels
-} -result {{0 2 2 2} 0}
+} -result {{0 2 2} 0}
 
 test nre-6.1 {[uplevel] is not recursive} -setup {
     proc a i [makebody {uplevel 1 [list a $i]}]
 } -body {
     setabs
@@ -183,21 +185,21 @@
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 0} 0}
+} -result {{0 2 0} 0}
 test nre-6.2 {[uplevel] is not recursive} -setup {
     setabs
     proc a i [makebody {uplevel 1 "set x $i; a $i"}]
 } -body {
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 0} 0}
+} -result {{0 2 0} 0}
 
 test nre-7.1 {[catch] is not recursive} -setup {
     setabs
     proc a i [makebody {uplevel 1 "catch {a $i} msg; set msg"}]
 } -body {
@@ -204,41 +206,41 @@
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 3 3 0} 0}
+} -result {{0 3 0} 0}
 test nre-7.2 {[if] is not recursive} -setup {
     setabs
     proc a i [makebody {uplevel 1 "if 1 {a $i}"}]
 } -body {
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 0} 0}
+} -result {{0 2 0} 0}
 test nre-7.3 {[while] is not recursive} -setup {
     setabs
     proc a i [makebody {uplevel 1 "while 1 {set res \[a $i\]; break}; set res"}]
 } -body {
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 0} 0}
+} -result {{0 2 0} 0}
 test nre-7.4 {[for] is not recursive} -setup {
     setabs
     proc a i [makebody {uplevel 1 "for {set j 0} {\$j < 10} {incr j} {set res \[a $i\]; break}; set res"}]
 } -body {
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 0} 0}
+} -result {{0 2 0} 0}
 test nre-7.5 {[foreach] is not recursive} -setup {
     #
     # Enable once [foreach] is NR-enabled
     #
     setabs
@@ -247,31 +249,31 @@
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 3 3 0} 0}
+} -result {{0 3 0} 0}
 test nre-7.6 {[eval] is not recursive} -setup {
     proc a i [makebody {eval [list a $i]}]
 } -body {
     setabs
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 1} 0}
+} -result {{0 2 1} 0}
 test nre-7.7 {[eval] is not recursive} -setup {
     proc a i [makebody {eval "a $i"}]
 } -body {
     setabs
     a 0
 } -cleanup {
     rename a {}
 } -constraints {
     testnrelevels
-} -result {{0 2 2 1} 0}
+} -result {{0 2 1} 0}
 test nre-7.8 {bug #2910748: switch out of stale BC is not nre-aware} -setup {
     proc foo args {}
     foo
     coroutine bar apply {{} {
 	yield
@@ -331,11 +333,11 @@
     foo bar 0
 } -cleanup {
     foo destroy
 } -constraints {
     testnrelevels
-} -result {{0 1 1 1} 0}
+} -result {{0 1 1} 0}
 test nre-oo.2 {really deep calls in oo - call via [self]} -setup {
     oo::object create foo
     oo::objdefine foo method bar i [makebody {[self] bar $i}]
 } -body {
     setabs
@@ -342,11 +344,11 @@
     foo bar 0
 } -cleanup {
     foo destroy
 } -constraints {
     testnrelevels
-} -result {{0 1 1 1} 0}
+} -result {{0 1 1} 0}
 test nre-oo.3 {really deep calls in oo - private calls} -setup {
     oo::object create foo
     oo::objdefine foo method bar i [makebody {my bar $i}]
 } -body {
     setabs
@@ -353,11 +355,11 @@
     foo bar 0
 } -cleanup {
     foo destroy
 } -constraints {
     testnrelevels
-} -result {{0 1 1 1} 0}
+} -result {{0 1 1} 0}
 test nre-oo.4 {really deep calls in oo - overriding} -setup {
     oo::class create foo {
 	method bar i [makebody {my bar $i}]
     }
     oo::class create boo {
@@ -369,11 +371,11 @@
     [boo new] bar 0
 } -cleanup {
     foo destroy
 } -constraints {
     testnrelevels
-} -result {{0 1 1 1} 0}
+} -result {{0 1 1} 0}
 test nre-oo.5 {really deep calls in oo - forwards} -setup {
     oo::object create foo
     set body [makebody {my boo $i}]
     oo::objdefine foo "
 	method bar i {$body}
@@ -384,11 +386,11 @@
     foo bar 0
 } -cleanup {
     foo destroy
 } -constraints {
     testnrelevels
-} -result {{0 2 1 1} 0}
+} -result {{0 2 1} 0}
 
 #
 # NASTY BUG found by tcllib's interp package
 #
 
@@ -407,11 +409,11 @@
 	list [filter [eval $x]] [filter [eval $y]] [filter [$j eval $x]] [filter [$j eval $y]]
     }
 } -cleanup {
     interp delete $i
 } -result {::foo ::foo {} {}}
-
+
 # cleanup
 ::tcltest::cleanupTests
 
 if {[testConstraint testnrelevels]} {
     namespace forget testnre::*

Index: tests/oo.test
==================================================================
--- tests/oo.test
+++ tests/oo.test
@@ -11,10 +11,12 @@
 package require tcltest 2
 if {"::tcltest" in [namespace children]} {
     namespace import -force ::tcltest::*
 }
 
+testConstraint infoframe [expr ![catch {info frame 0}]]
+
 testConstraint memory [llength [info commands memory]]
 if {[testConstraint memory]} {
     proc getbytes {} {
 	set lines [split [memory info] \n]
 	return [lindex $lines 3 3]
@@ -2589,11 +2591,11 @@
 	method level {} {
 	    expr {[next] - [info frame]}
 	}
     }
     list [i level] [i frames] [dict get [c frame] object]
-} -cleanup {
+} -constraints infoframe -cleanup {
     c destroy
 } -result {1 {{* cmd {info frame 0} method frames class ::c level 0} {* cmd {info frame 0} method frames object ::i level 0}} ::c}
 test oo-22.2 {OO and info frame: Bug 3001438} -setup {
     oo::class create c
 } -body {
@@ -2601,11 +2603,11 @@
 	if {$x} {my test 0}
 	lsort {q w e r t y u i o p}; # Overwrite the Tcl stack
 	info frame 0
     }
     [c new] test
-} -match glob -cleanup {
+} -match glob -constraints infoframe -cleanup {
     c destroy
 } -result {* cmd {info frame 0} method test class ::c level 0}
 
 # Prove that the issue in [Bug 1865054] isn't an issue any more
 test oo-23.1 {Self-like derivation; complex case!} -setup {

Index: tests/regexpComp.test
==================================================================
--- tests/regexpComp.test
+++ tests/regexpComp.test
@@ -828,16 +828,16 @@
 	regexp -nocase FOO dogfod
     }
 } 0
 test regexpComp-21.6 {regexp command compiling tests} {
     evalInProc {
-	regexp -n foo dogfoOd
+	regexp -nocase foo dogfoOd
     }
 } 1
 test regexpComp-21.7 {regexp command compiling tests} {
     evalInProc {
-	regexp -no -- FoO dogfood
+	regexp -nocase -- FoO dogfood
     }
 } 1
 test regexpComp-21.8 {regexp command compiling tests} {
     evalInProc {
 	regexp -- foo dogfod
@@ -943,17 +943,17 @@
     }
 } 0
 test regexpComp-24.6 {regexp command compiling tests} {
     evalInProc {
 	set re foo
-	regexp -n $re dogfoOd
+	regexp -nocase $re dogfoOd
     }
 } 1
 test regexpComp-24.7 {regexp command compiling tests} {
     evalInProc {
 	set re FoO
-	regexp -no -- $re dogfood
+	regexp -nocase -- $re dogfood
     }
 } 1
 test regexpComp-24.8 {regexp command compiling tests} {
     evalInProc {
 	set re foo
@@ -980,13 +980,13 @@
 	set text {this is *bold* !}
 	set re {\*bold\*.*!}
 	regexp -- $re $text
     }
 } 1
-
+
 # cleanup
 ::tcltest::cleanupTests
 return
 
 # Local Variables:
 # mode: tcl
 # End:

Index: tests/tailcall.test
==================================================================
--- tests/tailcall.test
+++ tests/tailcall.test
@@ -25,17 +25,22 @@
 #
 
 if {[testConstraint testnrelevels]} {
     namespace eval testnre {
 	#
-	# [testnrelevels] returns a 6-list with: C-stack depth, iPtr->numlevels,
-	# cmdFrame level, callFrame level, tosPtr and callback depth 
+	#
+	# [testnrelevels] returns a 4-list with: C-stack depth, iPtr->numlevels,
+	# callFrame level and callback depth 
 	#
-	variable last [testnrelevels] 
+
 	proc depthDiff {} {
 	    variable last
 	    set depth [testnrelevels]
+	    if {![info exists last]} {
+		set last $depth
+		return $last
+	    }
 	    set res {}
 	    foreach t $depth l $last {
 		lappend res [expr {$t-$l}]
 	    }
 	    set last $depth
@@ -55,69 +60,61 @@
 	#
 	# NOTE: there may be a diff in callback depth with the first call
 	# ($i==0) due to the fact that the first is from an eval. Successive
 	# calls should add nothing to any stack depths.
 	#
-	if {$i == 1} {
-	    depthDiff
-	}
+	set x [depthDiff]
 	if {[incr i] > 10} {
-	    return [depthDiff]
+	    return $x
 	}
 	tailcall a $i
     }
 } -body {
     a 0
 } -cleanup {
     rename a {}
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-0.2 {tailcall is constant space} -constraints testnrelevels -setup {
     set a { i {
-	if {$i == 1} {
-	    depthDiff
-	}
+	set x [depthDiff]
 	if {[incr i] > 10} {
-	    return [depthDiff]
+	    return $x
 	}
 	upvar 1 a a
 	tailcall apply $a $i
     }}
 } -body {
     apply $a 0
 } -cleanup {
     unset a
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-0.3 {tailcall is constant space} -constraints testnrelevels -setup {
     proc a i {
-	if {$i == 1} {
-	    depthDiff
-	}
+	set x [depthDiff]
 	if {[incr i] > 10} {
-	    return [depthDiff]
+	    return $x
 	}
 	tailcall b $i
     }
     interp alias {} b {} a
 } -body {
     b 0
 } -cleanup {
     rename a {}
     rename b {}
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-0.4 {tailcall is constant space} -constraints testnrelevels -setup {
     namespace eval ::ns {
 	namespace export *
     }
     proc ::ns::a i {
-	if {$i == 1} {
-	    depthDiff
-	}
+	set x [depthDiff]
 	if {[incr i] > 10} {
-	    return [depthDiff]
+	    return $x
 	}
 	set b [uplevel 1 [list namespace which b]]
 	tailcall $b $i
     }
     namespace import ::ns::a
@@ -125,40 +122,36 @@
 } -body {
     b 0
 } -cleanup {
     rename b {}
     namespace delete ::ns
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-0.5 {tailcall is constant space} -constraints testnrelevels -setup {
     proc b i {
-	if {$i == 1} {
-	    depthDiff
-	}
+	set x [depthDiff]
 	if {[incr i] > 10} {
-	    return [depthDiff]
+	    return $x
 	}
 	tailcall a b $i
     }
     namespace ensemble create -command a -map {b b}
 } -body {
     a b 0
 } -cleanup {
     rename a {}
     rename b {}
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-0.6 {tailcall is constant space} -constraints {testnrelevels knownBug} -setup {
     #
     # This test fails because ns-unknown is not NR-enabled
     #
     proc c i {
-	if {$i == 1} {
-	    depthDiff
-	}
+	set x [depthDiff]
 	if {[incr i] > 10} {
-	    return [depthDiff]
+	    return $x
 	}
 	tailcall a b $i
     }
     proc d {ens sub args} {
 	return [list $ens c]
@@ -168,21 +161,19 @@
     a b 0
 } -cleanup {
     rename a {}
     rename c {}
     rename d {}
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-0.7 {tailcall is constant space} -constraints testnrelevels -setup {
     catch {rename foo {}}
     oo::class create foo {
 	method b i {
-	    if {$i == 1} {
-		depthDiff
-	    }
+	    set x [depthDiff]
 	    if {[incr i] > 10} {
-		return [depthDiff]
+		return $x
 	    }
 	    tailcall [self] b $i
 	}
     }
 } -body {
@@ -189,11 +180,11 @@
     foo create a
     a b 0
 } -cleanup {
     rename a {}
     rename foo {}
-} -result {0 0 0 0 0 0}
+} -result {0 0 0 0}
 
 test tailcall-1 {tailcall} -body {
     namespace eval a {
 	variable x *::a
 	proc xset {} {

Index: unix/Makefile.in
==================================================================
--- unix/Makefile.in
+++ unix/Makefile.in
@@ -288,29 +288,28 @@
 	tclThreadTest.o tclUnixTest.o
 
 XTTEST_OBJS = xtTestInit.o tclTest.o tclTestObj.o tclTestProcBodyObj.o \
 	tclThreadTest.o tclUnixTest.o tclXtNotify.o tclXtTest.o
 
-GENERIC_OBJS = regcomp.o regexec.o regfree.o regerror.o tclAlloc.o \
+GENERIC_OBJS = regcomp.o regexec.o regfree.o regerror.o \
 	tclAsync.o tclBasic.o tclBinary.o tclCkalloc.o tclClock.o \
 	tclCmdAH.o tclCmdIL.o tclCmdMZ.o tclCompCmds.o tclCompCmdsSZ.o \
 	tclCompExpr.o tclCompile.o tclConfig.o tclDate.o tclDictObj.o \
 	tclEncoding.o tclEnsemble.o \
 	tclEnv.o tclEvent.o tclExecute.o tclFCmd.o tclFileName.o tclGet.o \
 	tclHash.o tclHistory.o tclIndexObj.o tclInterp.o tclIO.o tclIOCmd.o \
 	tclIORChan.o tclIORTrans.o tclIOGT.o tclIOSock.o tclIOUtil.o \
 	tclLink.o tclListObj.o \
 	tclLiteral.o tclLoad.o tclMain.o tclNamesp.o tclNotify.o \
-	tclObj.o tclPanic.o tclParse.o tclPathObj.o tclPipe.o \
+	tclObj.o tclObjAlloc.o tclPanic.o tclParse.o tclPathObj.o tclPipe.o \
 	tclPkg.o tclPkgConfig.o tclPosixStr.o \
 	tclPreserve.o tclProc.o tclRegexp.o \
 	tclResolve.o tclResult.o tclScan.o tclStringObj.o \
 	tclStrToD.o tclThread.o \
-	tclThreadAlloc.o tclThreadJoin.o tclThreadStorage.o tclStubInit.o \
+	tclThreadJoin.o tclThreadStorage.o tclStubInit.o \
 	tclTimer.o tclTrace.o tclUtf.o tclUtil.o tclVar.o tclZlib.o \
-	tclTomMathInterface.o \
-	tclAssembly.o
+	tclTomMathInterface.o
 
 OO_OBJS = tclOO.o tclOOBasic.o tclOOCall.o tclOODefineCmds.o tclOOInfo.o \
 	tclOOMethod.o tclOOStubInit.o
 
 TOMMATH_OBJS = bncore.o bn_reverse.o bn_fast_s_mp_mul_digs.o \
@@ -382,12 +381,10 @@
 GENERIC_SRCS = \
 	$(GENERIC_DIR)/regcomp.c \
 	$(GENERIC_DIR)/regexec.c \
 	$(GENERIC_DIR)/regfree.c \
 	$(GENERIC_DIR)/regerror.c \
-	$(GENERIC_DIR)/tclAlloc.c \
-	$(GENERIC_DIR)/tclAssembly.c \
 	$(GENERIC_DIR)/tclAsync.c \
 	$(GENERIC_DIR)/tclBasic.c \
 	$(GENERIC_DIR)/tclBinary.c \
 	$(GENERIC_DIR)/tclCkalloc.c \
 	$(GENERIC_DIR)/tclClock.c \
@@ -426,10 +423,11 @@
 	$(GENERIC_DIR)/tclLoad.c \
 	$(GENERIC_DIR)/tclMain.c \
 	$(GENERIC_DIR)/tclNamesp.c \
 	$(GENERIC_DIR)/tclNotify.c \
 	$(GENERIC_DIR)/tclObj.c \
+	$(GENERIC_DIR)/tclObjAlloc.c \
 	$(GENERIC_DIR)/tclParse.c \
 	$(GENERIC_DIR)/tclPathObj.c \
 	$(GENERIC_DIR)/tclPipe.c \
 	$(GENERIC_DIR)/tclPkg.c \
 	$(GENERIC_DIR)/tclPkgConfig.c \
@@ -445,18 +443,16 @@
 	$(GENERIC_DIR)/tclStrToD.c \
 	$(GENERIC_DIR)/tclTest.c \
 	$(GENERIC_DIR)/tclTestObj.c \
 	$(GENERIC_DIR)/tclTestProcBodyObj.c \
 	$(GENERIC_DIR)/tclThread.c \
-	$(GENERIC_DIR)/tclThreadAlloc.c \
 	$(GENERIC_DIR)/tclThreadJoin.c \
 	$(GENERIC_DIR)/tclThreadStorage.c \
 	$(GENERIC_DIR)/tclTimer.c \
 	$(GENERIC_DIR)/tclTrace.c \
 	$(GENERIC_DIR)/tclUtil.c \
 	$(GENERIC_DIR)/tclVar.c \
-	$(GENERIC_DIR)/tclAssembly.c \
 	$(GENERIC_DIR)/tclZlib.c
 
 OO_SRCS = \
 	$(GENERIC_DIR)/tclOO.c \
 	$(GENERIC_DIR)/tclOOBasic.c \
@@ -1018,16 +1014,10 @@
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/regerror.c
 
 tclAppInit.o: $(UNIX_DIR)/tclAppInit.c
 	$(CC) -c $(APP_CC_SWITCHES) $(UNIX_DIR)/tclAppInit.c
 
-tclAlloc.o: $(GENERIC_DIR)/tclAlloc.c
-	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclAlloc.c
-
-tclAssembly.o: $(GENERIC_DIR)/tclAssembly.c $(COMPILEHDR)
-	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclAssembly.c
-
 tclAsync.o: $(GENERIC_DIR)/tclAsync.c
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclAsync.c
 
 tclBasic.o: $(GENERIC_DIR)/tclBasic.c $(COMPILEHDR) $(MATHHDRS) $(NREHDR)
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclBasic.c
@@ -1138,10 +1128,13 @@
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclLiteral.c
 
 tclObj.o: $(GENERIC_DIR)/tclObj.c $(COMPILEHDR) $(MATHHDRS)
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclObj.c
 
+tclObjAlloc.o: $(GENERIC_DIR)/tclObjAlloc.c
+	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclObjAlloc.c
+
 tclLoad.o: $(GENERIC_DIR)/tclLoad.c
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclLoad.c
 
 tclLoadAix.o: $(UNIX_DIR)/tclLoadAix.c
 	$(CC) -c $(CC_SWITCHES) $(UNIX_DIR)/tclLoadAix.c
@@ -1294,13 +1287,10 @@
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclTimer.c
 
 tclThread.o: $(GENERIC_DIR)/tclThread.c
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclThread.c
 
-tclThreadAlloc.o: $(GENERIC_DIR)/tclThreadAlloc.c
-	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclThreadAlloc.c
-
 tclThreadJoin.o: $(GENERIC_DIR)/tclThreadJoin.c
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclThreadJoin.c
 
 tclThreadStorage.o: $(GENERIC_DIR)/tclThreadStorage.c
 	$(CC) -c $(CC_SWITCHES) $(GENERIC_DIR)/tclThreadStorage.c

Index: unix/tclUnixPipe.c
==================================================================
--- unix/tclUnixPipe.c
+++ unix/tclUnixPipe.c
@@ -428,12 +428,12 @@
     /*
      * We need to allocate and convert this before the fork so it is properly
      * deallocated later
      */
 
-    dsArray = TclStackAlloc(interp, argc * sizeof(Tcl_DString));
-    newArgv = TclStackAlloc(interp, (argc+1) * sizeof(char *));
+    dsArray = ckalloc(argc * sizeof(Tcl_DString));
+    newArgv = ckalloc((argc+1) * sizeof(char *));
     newArgv[argc] = NULL;
     for (i = 0; i < argc; i++) {
 	newArgv[i] = Tcl_UtfToExternalDString(NULL, argv[i], -1, &dsArray[i]);
     }
 
@@ -501,12 +501,12 @@
      */
 
     for (i = 0; i < argc; i++) {
 	Tcl_DStringFree(&dsArray[i]);
     }
-    TclStackFree(interp, newArgv);
-    TclStackFree(interp, dsArray);
+    ckfree(newArgv);
+    ckfree(dsArray);
 
     if (pid == -1) {
 	Tcl_SetObjResult(interp, Tcl_ObjPrintf(
 		"couldn't fork child process: %s", Tcl_PosixError(interp)));
 	goto error;

Index: unix/tclUnixThrd.c
==================================================================
--- unix/tclUnixThrd.c
+++ unix/tclUnixThrd.c
@@ -672,16 +672,15 @@
 #else
     return inet_ntoa(addr);
 #endif
 }
 
-#ifdef TCL_THREADS
+#if defined(TCL_THREADS)
 /*
  * Additions by AOL for specialized thread memory allocator.
  */
 
-#ifdef USE_THREAD_ALLOC
 static volatile int initialized = 0;
 static pthread_key_t key;
 
 typedef struct allocMutex {
     Tcl_Mutex tlock;
@@ -713,10 +712,11 @@
 	return;
     }
     pthread_mutex_destroy(&lockPtr->plock);
     free(lockPtr);
 }
+
 
 void
 TclpFreeAllocCache(
     void *ptr)
 {
@@ -723,12 +723,13 @@
     if (ptr != NULL) {
 	/*
 	 * Called by the pthread lib when a thread exits
 	 */
 
+#ifndef PURIFY
 	TclFreeAllocCache(ptr);
-
+#endif
     } else if (initialized) {
 	/*
 	 * Called by us in TclFinalizeThreadAlloc() during the library
 	 * finalization initiated from Tcl_Finalize()
 	 */
@@ -756,12 +757,13 @@
 TclpSetAllocCache(
     void *arg)
 {
     pthread_setspecific(key, arg);
 }
-#endif /* USE_THREAD_ALLOC */
+#endif
 
+#ifdef TCL_THREADS
 void *
 TclpThreadCreateKey(void)
 {
     pthread_key_t *ptkeyPtr;
 

