# Commands covered:  regexp, regsub
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1998 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

# prepare:
namespace inscope ::tcltest {rename cleanupTests _cleanupTests; proc cleanupTests {args} {}}
rename test __test
proc test {args} {}

set err [catch {

  # test all available regexp engines (switch default to another one):
  set org_reeng [interp regexp {}]

  foreach reeng {classic pcre dfa} {

    proc _test_reeng_available {} {
      variable reeng
      interp regexp {} $reeng
      # note we should not use simple regexp here (to avoid compile it via TclReToGlob to the glob expr):
      if {[catch { regexp -- {^(_)(?!_)$} {_} } errMsg]} {
        puts "ignore test of engine \"$reeng\": $errMsg"
        return 0
      }
      return 1
    }

    testConstraint reeng_$reeng [_test_reeng_available]

    # wrapper for tests from regexp.test (add suffix with re-engine type):
    proc test {args} {
      variable reeng
      uplevel [list __test [lindex $args 0]-$reeng {*}[lrange $args 1 end]]
    }

# ---------------------------------------------------------------------------

# constraint for longest-match instead first-match supported for some features (e.g. alternative patterns):
testConstraint longest-match [expr {[regexp -inline {a|ab|abc} abc] eq "abc"}]
testConstraint pcre [expr {[interp regexp {}] eq "pcre"}]
testConstraint dfa [expr {[interp regexp {}] eq "dfa"}]
testConstraint classic [expr {[interp regexp {}] eq "classic"}]

# special engine-related tests:

test regexp2-0.1 {test of interim "switch" of engine} -body {
  # this test will fail if current engine is not classic (no lookbehind syntax), and if it will be not
  # switched via parameter -type classic (regardless PCRE available or not)
  set re {(?<![xyz])abc|(?<!\d)cba}
  list [catch {regexp -inline -type classic $re "1cba xabc"} msg] $msg \
       [catch {regexp -inline -type classic $re "acba"} msg] $msg \
       [catch {regexp -inline -type classic $re "1abc"} msg] $msg
} -match glob -result \
{1 {*quantifier operand invalid} 1 {*quantifier operand invalid} 1 {*quantifier operand invalid}}

test regexp2-1.1   {alternative patterns: longest match} {longest-match} {
  regexp {a|ab|abc} -abc- v; set v
} {abc}
test regexp2-1.1.1 {alternative patterns: first match} {pcre} {
  regexp -inline {a|ab|abc} -abc-
} {a}
test regexp2-1.1.2 {alternative patterns: first/longest match} {pcre} {
  regexp -inline {abc|ab|a} -abc-
} {abc}
test regexp2-1.1.1 {alternative patterns: all matches} {dfa} {
  regexp -inline {a|ab|abc} -abc-
} {abc ab a}
test regexp2-1.1.1 {alternative patterns: longest match} {classic} {
  regexp -inline {a|ab|abc} -abc-
} {abc}
test regexp2-1.2   {alternative patterns: longest match (end anchored)} {
  regexp -inline {(?:a|ab|abc)$} -abc
} {abc}
test regexp2-1.2.1 {alternative patterns: longest match (word boundary)} {pcre} {
  regexp -inline {(?:a|ab|abc)\b} -abc-
} {abc}
test regexp2-1.2.2 {alternative patterns: longest match (word boundary)} {dfa} {
  regexp -inline {(?:a|ab|abc)\b} -abc-
} {abc}
test regexp2-1.2.2 {alternative patterns: longest match (word boundary)} {classic} {
  regexp -inline {(?:a|ab|abc)\M} -abc-
} {abc}
test regexp2-1.3   {alternative patterns: longest match (start anchored)} {longest-match} {
  regexp {^(?:a|ab|abc)} abc-; set v
} {abc}
test regexp2-1.3.1 {alternative patterns: longest match (start anchored + boundary)} {pcre} {
  regexp -inline {^(?:a|bc|ab|abc)\b} abc-
} {abc}
test regexp2-1.3.2 {alternative patterns: longest match only (start anchored + boundary)} {dfa} {
  regexp -inline {^(?:a|bc|ab|abc)\b} abc-
} {abc}
test regexp2-1.3.3 {alternative patterns: longest match (start anchored)} {classic} {
  regexp -inline {^(?:a|bc|ab|abc)} abc-
} {abc}

# ---------------------------------------------------------------------------

    # skip all tests (already processed directly in regexp.test):
    if {$reeng eq $org_reeng} continue
    # skip all tests in order to avoid errors in test-suite if default regexp engine not available:
    if {![testConstraint reeng_$reeng]} {
      continue
    }
    # evaluate the tests from regexp.test,
    # don't test "dfa" here, because no group-captures at all supported (thus incompatible)
    if {$reeng ne "dfa"} {
      source -encoding utf-8 [file join [file dirname [info script]] regexp.test]
    }

  }; #end of engine cycle

} errMsg opt]

# restore
interp regexp {} $org_reeng
rename test {}; rename __test test
namespace inscope ::tcltest {rename cleanupTests {}; rename _cleanupTests cleanupTests}

# cleanup
::tcltest::cleanupTests
if {$err} {
  return {*}$opt -level 1 $errMsg
}
