# Exercise AbstractList API via the "lstring" command defined in tclTestABSList.c
#
# Copyright Â© 2022 Brian Griffin
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {"::tcltest" ni [namespace children]} {
    package require tcltest 2.5
    namespace import -force ::tcltest::*
}

proc value-isa {var {expected ""}} {
    upvar $var v
    set t [lindex [tcl::unsupported::representation $v] 3]
    if {$expected ne "" && $expected ne $t} {
	set fail " expecting: $expected"
    } else {
	set fail ""
    }
    return "value in $var is a $t$fail"
}

set str "My name is Inigo Montoya. You killed my father. Prepare to die!"
set str2 "Vizzini: HE DIDN'T FALL? INCONCEIVABLE. Inigo Montoya: You keep using that word. I do not think it means what you think it means."

test abstractlist-1.0 {error cases} -body {
    lstring
} \
    -returnCodes 1 \
    -result {wrong # args: should be "lstring string"}

test abstractlist-1.1 {error cases} -body {
    lstring a b c
} -returnCodes 1 \
    -result {wrong # args: should be "lstring string"}

test abstractlist-2.0 {no shimmer llength} {
    set l [lstring $str]
    set l-isa [value-isa l]
    set len [llength $l]
    set l-isa2 [value-isa l]
    list $l ${l-isa} ${len} ${l-isa2}
} {{M y { } n a m e { } i s { } I n i g o { } M o n t o y a . { } Y o u { } k i l l e d { } m y { } f a t h e r . { } P r e p a r e { } t o { } d i e !} {value in l is a lstring} 63 {value in l is a lstring}}

test abstractlist-2.1 {no shimmer lindex} {
    set l [lstring $str]
    set l-isa [value-isa l]
    set ele [lindex $l 22]
    set l-isa2 [value-isa l]
    list $l ${l-isa} ${ele} ${l-isa2}
} {{M y { } n a m e { } i s { } I n i g o { } M o n t o y a . { } Y o u { } k i l l e d { } m y { } f a t h e r . { } P r e p a r e { } t o { } d i e !} {value in l is a lstring} y {value in l is a lstring}}

test abstractlist-2.2 {no shimmer lreverse} {
    set l [lstring $str]
    set l-isa [value-isa l]
    set r [lreverse $l]
    set r-isa [value-isa r]
    set l-isa2 [value-isa l]
    list $r ${l-isa} ${r-isa} ${l-isa2}
} {{! e i d { } o t { } e r a p e r P { } . r e h t a f { } y m { } d e l l i k { } u o Y { } . a y o t n o M { } o g i n I { } s i { } e m a n { } y M} {value in l is a lstring} {value in r is a lstring} {value in l is a lstring}}

test abstractlist-2.3 {no shimmer lrange} {
    set l [lstring $str]
    set l-isa [value-isa l]
    set il [lsearch -all [lstring $str] { }]
    set l-isa2 [value-isa l]
    lappend il [llength $l]
    set start 0
    set words [lmap i $il {
	set w [join [lrange $l $start $i-1] {} ]
	set start [expr {$i+1}]
	set w
    }]
    set l-isa3 [value-isa l]
    list ${l-isa} $il ${l-isa2} ${l-isa3} $words
} {{value in l is a lstring} {2 7 10 16 25 29 36 39 47 55 58 63} {value in l is a lstring} {value in l is a lstring} {My name is Inigo Montoya. You killed my father. Prepare to die!}}

test abstractlist-2.4 {no shimmer foreach} {
    set l [lstring $str]
    set l-isa [value-isa l]
    set word {}
    set words {}
    foreach c $l {
	if {$c eq { }} {
	    lappend words $word
	    set word {}
	} else {
	    append word $c
	}
    }
    if {$word ne ""} {
	lappend words $word
    }
    set l-isa2 [value-isa l]
    list ${l-isa} ${l-isa2} $words
} {{value in l is a lstring} {value in l is a lstring} {My name is Inigo Montoya. You killed my father. Prepare to die!}}

#
# The TBCE implements lreplace as a lrange + lappend operation, so, in this case, $m results is a list, not an lstring.
#
test abstractlist-2.5 {!no shimmer lreplace} {
    set l [lstring $str2]
    set l-isa [value-isa l]
    set m [lreplace $l 18 23 { } f a i l ?]
    set m-isa [value-isa m]
    set l-isa1 [value-isa l]
    list ${l-isa} $m ${m-isa} ${l-isa1}
} {{value in l is a lstring} {V i z z i n i : { } H E { } D I D N ' T { } f a i l ? { } I N C O N C E I V A B L E . { } I n i g o { } M o n t o y a : { } Y o u { } k e e p { } u s i n g { } t h a t { } w o r d . { } I { } d o { } n o t { } t h i n k { } i t { } m e a n s { } w h a t { } y o u { } t h i n k { } i t { } m e a n s .} {value in m is a list} {value in l is a lstring}}

test abstractlist-2.6 {no shimmer ledit} {
    # "ledit m 9 8 S"
    set l [lstring $str2]
    set l-isa [value-isa l]
    set e [ledit l 9 8 S]
    set e-isa [value-isa e]
    #puts [list linsert {$m} 13 {*}[split "almost " {}]]
    #puts [linsert $m 13 {*}[split "almost " {}]]
    list ${l-isa} $e ${e-isa}
} {{value in l is a lstring} {V i z z i n i : { } S H E { } D I D N ' T { } F A L L ? { } I N C O N C E I V A B L E . { } I n i g o { } M o n t o y a : { } Y o u { } k e e p { } u s i n g { } t h a t { } w o r d . { } I { } d o { } n o t { } t h i n k { } i t { } m e a n s { } w h a t { } y o u { } t h i n k { } i t { } m e a n s .} {value in e is a lstring}}

test abstractlist-2.7 {no shimmer linsert} {
    # "ledit m 9 8 S"
    set l [lstring $str2]
    set l-isa [value-isa l]
    set i [linsert $l 12 {*}[split "almost " {}]]
    set i-isa [value-isa i]
    set res [list ${l-isa} $i ${i-isa}]
    set p [lpop i 23]
    set p-isa [value-isa p]
    set i-isa2 [value-isa i]
    lappend res $p ${p-isa} $i ${i-isa2}
} {{value in l is a lstring} {V i z z i n i : { } H E { } a l m o s t { } D I D N ' T { } F A L L ? { } I N C O N C E I V A B L E . { } I n i g o { } M o n t o y a : { } Y o u { } k e e p { } u s i n g { } t h a t { } w o r d . { } I { } d o { } n o t { } t h i n k { } i t { } m e a n s { } w h a t { } y o u { } t h i n k { } i t { } m e a n s .} {value in i is a lstring} ' {value in p is a pure} {V i z z i n i : { } H E { } a l m o s t { } D I D N T { } F A L L ? { } I N C O N C E I V A B L E . { } I n i g o { } M o n t o y a : { } Y o u { } k e e p { } u s i n g { } t h a t { } w o r d . { } I { } d o { } n o t { } t h i n k { } i t { } m e a n s { } w h a t { } y o u { } t h i n k { } i t { } m e a n s .} {value in i is a list}}
