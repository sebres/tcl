# Commands covered:  proc
#
# This file contains a collection of tests for one or more of the Tcl built-in
# commands.  Sourcing this file into Tcl runs the tests and generates output
# for errors.  No output means no errors were found.
#
# See the file "license.terms" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

testConstraint procbodytest [expr {![catch {package require procbodytest}]}]

test proc-enh-1.1 {default option} {
    proc p { { a -default 1 } } { list $a }
    list [p] [p 2]
} {1 2}
test proc-enh-1.3 {default option twice} {
    proc p { { a -default 1 -default 2 } } { list $a }; p
} {2}
test proc-enh-1.4 {unknown option} {
    list [catch {
	proc p { { a -foo 1 } } { }
    } msg] $msg $errorCode
} {1 {unknown argument option "-foo" or too many fields in argument specifier " a -foo 1 "} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.5 {unexpected fields number} {
    list [catch {
	proc p { { a -default 1 -name } } { }
    } msg] $msg $errorCode
} {1 {unexpected fields number in argument specifier " a -default 1 -name "} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.6 {-value without -name} {
    list [catch {
	proc p { { a -default 0 -value 1 } } { }
    } msg] $msg $errorCode
} {1 {-name required for -value} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.7 {-value without -default} {
    list [catch {
	proc p { { a -name foo -value 1 } } { }
	p
    } msg] $msg $errorCode
} {1 {wrong # args: should be "p |-foo|"} {TCL WRONGARGS}}
test proc-enh-1.8 {switch test} {
    proc p { { a -default 3 -name zero -value 0 -name ten -value 10 } } { list $a }
    list [p] [p -zero] [p -ten]
} {3 0 10}
test proc-enh-1.9 {named arg test} {
    proc p { { a -default 3 -name value } } { list $a }
    list [p] [p -value 5]
} {3 5}
test proc-enh-1.9 {named arg test without value} {
    proc p { { a -default 3 -name value } } { list $a }
    list [catch {
	p -value
    } msg] $msg $errorCode
} {1 {wrong # args: should be "p ?|-value a|?"} {TCL WRONGARGS}}
test proc-enh-1.10 {multiple name test} {
    proc p { { a -default 3 -name zero -value 0 -name ten -value 10 -name value } } { list $a }
    list [p] [p -zero] [p -ten] [p -value 5]
} {3 0 10 5}
test proc-enh-1.10b {namearg group} {
    proc p1 { { a -name a } { b -name b } { c 0 } } { list $a $b $c }
    proc p2 { { a -default Z -name a } { b -name b } { c 0 } } { list $a $b $c }
    list [p1 -a 1 -b 2] [p1 -b B -a A] [p2 -b Y] [p2 -b Z -- -5] [p2 -b B --] [p2 -b 1 6]
} {{1 2 0} {A B 0} {Z Y 0} {Z Z -5} {Z B 0} {Z 1 6}}
test proc-enh-1.10c {namearg group followed by a pos arg with leading dash} {
    list [catch {
	proc p { { a -default Z -name a } { b -name b } { c 0 } } { list $a $b $c }
	list [p -b Z -5]
    } msg] $msg $errorCode
} {1 {wrong # args: should be "p ?|-a a|? |-b b| ?c?"} {TCL WRONGARGS}}
test proc-enh-1.10d {namearg group followed by more options than allowed} {
    list [catch {
	proc p { { a -default Z -name a } b } { list $a $b $c }
	list [p -- 5 6]
    } msg] $msg $errorCode
} {1 {wrong # args: should be "p ?|-a a|? b"} {TCL WRONGARGS}}
test proc-enh-1.11 {upvar group} {
    proc p { { a -upvar up1 } { b -name b -upvar up2 } } {
	incr a; list $up1 $a $up2 $b
    }
    set i 5; set j 42
    list [p i -b j] [p j -b i]
} {{i 6 j 42} {j 43 i 6}}
test proc-enh-1.11b {upvar group} {
    proc p { { a -upvar up1 } { b -name b -upvar up2 -name b2 } } {
	incr a; list $up1 $a [if {[info exist up2]} {list $up2} {list ?}] $b
    }
    set i 5; set j 42
    list [p i -b j] [p j -b2 i]
} {{i 6 j 42} {j 43 ? i}}
test proc-enh-1.12 {wrong num args with named arguments group} {
    proc p { { a -name A -name U -upvar {} } { c -default 0 -name C -value 2 } } { }
    list [catch {
	p
    } msg] $msg $errorCode
} {1 {wrong # args: should be "p |-A a|-U &a&| ?|-C|?"} {TCL WRONGARGS}}
test proc-enh-1.13 {wrong num args with upvar arg} {
    proc p { { a -upvar up } } { }
    list [catch {
	p
    } msg] $msg $errorCode
} {1 {wrong # args: should be "p &a&"} {TCL WRONGARGS}}
test proc-enh-1.14 {upvar arg: proc call with non-existing arg (read)} {
    proc p { { a -upvar up } } { list $up $a }
    if [info exists v] { unset v}
    list [catch {
	p v
    } msg] $msg $errorCode
} {1 {can't read "a": no such variable} {TCL READ VARNAME}}
test proc-enh-1.14b {upvar arg: proc call with non-existing arg (name+read)} {
    proc p { { a -name A -upvar up } } { list $up $a }
    if [info exists v] { unset v}
    list [catch {
	p -A v
    } msg] $msg $errorCode
} {1 {can't read "a": no such variable} {TCL READ VARNAME}}
test proc-enh-1.14c {upvar arg: proc call with non-existing arg (write)} {
    proc p { { a -upvar up } } { set a ini }
    if [info exists v] { unset v}
    list [info exists v] [p v] [info exists v] $v
} {0 ini 1 ini}
test proc-enh-1.14d {upvar arg: proc call with non-existing arg (name+write)} {
    proc p { { a -name A -upvar up } } { set a ini }
    if [info exists v] { unset v}
    list [info exists v] [p -A v] [info exists v] $v
} {0 ini 1 ini}
test proc-enh-1.15 {upvar before first name} {
    list [catch {
	proc p { { a -upvar {} -name A } } { }
    } msg] $msg $errorCode
} {1 {-upvar is not allowed before first -name} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.16 {both upvar and value are invalid} {
    list [catch {
	proc p { { a -name A -upvar {} -value 1 } } { }
    } msg] $msg $errorCode
} {1 {-upvar and -value are not allowed together} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.16b {both upvar and value are invalid} {
    list [catch {
	proc p { { a -name A -value 1 -upvar {} } } { }
    } msg] $msg $errorCode
} {1 {-upvar and -value are not allowed together} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.17 {-default after -name} {
    list [catch {
	proc p { { a -name A -default 1} } { }
    } msg] $msg $errorCode
} {1 {-default is not allowed after -name} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.18 {-upvar set twice} {
    list [catch {
	proc p { { a -upvar up1 -upvar up2 } } { }
    } msg] $msg $errorCode
} {1 {-upvar has already been set} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.18b {-upvar set twice} {
    list [catch {
	proc p { { a -name U -upvar up1 -upvar up2 } } { }
    } msg] $msg $errorCode
} {1 {-upvar has already been set} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.19 {-upvar with non scalar arg} {
    list [catch {
	proc p { { a -upvar a(1) } } { list $a(1) $a }
    } msg] $msg $errorCode
} {1 {upvar parameter "a(1)" is an array element} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}
test proc-enh-1.19b {-upvar with non scalar arg} {
    list [catch {
	proc p { { a -upvar b::c } } { list $b::c $a }
    } msg] $msg $errorCode
} {1 {upvar parameter "b::c" is not a simple name} {TCL OPERATION PROC FORMALARGUMENTFORMAT}}

test proc-enh-2.1 {precompiled, inconsistent arg default value} -body {
    proc p {x y {z -default 2}} { }
    procbodytest::proc t {x y {z ZZ}} p
} -constraints procbodytest -returnCodes error -cleanup {
    catch {rename p ""}
    catch {rename t ""}
} -result {procedure "t": formal parameter "z" has argument spec inconsistent with precompiled body}
test proc-enh-2.2 {precompiled, inconsistent arg spec} -body {
    proc p {x y {z -name z}} { }
    procbodytest::proc t {x y {z -name ZZ}} p
} -constraints procbodytest -returnCodes error -cleanup {
    catch {rename p ""}
    catch {rename t ""}
} -result {procedure "t": formal parameter "z" has argument spec inconsistent with precompiled body}
test proc-enh-2.3 {precompiled with upvar arg} -body {
    proc p {x {y -upvar up} z} { }
    procbodytest::proc t {x {y -upvar up} z} p
} -constraints procbodytest -result {}

test proc-enh-3.1 {apply/lambda - wrong args} {
    list [catch {
	set lambda [list {{a -name A -name A1 -value 1} {b -default B0 -name B}} {list $a $b}]
	apply $lambda
    } msg] $msg $errorCode
} {1 {wrong # args: should be "apply lambdaExpr |-A a|-A1| ?|-B b|?"} {TCL WRONGARGS}}
test proc-enh-3.1 {apply/lambda - correct usage} {
    set lambda [list {{a -name A -name A1 -value 1} {b -default B0 -name B}} {list $a $b}]
    list [apply $lambda -A1] [apply $lambda -B 4 -A 8]
} {{1 B0} {8 4}}

# cleanup
::tcltest::cleanupTests
return

# Local Variables:
# mode: tcl
# fill-column: 78
# End:
