# Commands covered:  range
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright Â© 2003 Simon Geard.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {"::tcltest" ni [namespace children]} {
    package require tcltest 2.5
    namespace import -force ::tcltest::*
}

## Arg errors
test range-1.1 {error cases} {
    -body {
	range
    }
    -returnCodes 1
    -result {wrong # args: should be "range start op end ?by step?"}
}

test range-1.2 {step magnitude} {
    -body {
	range 10 .. 1 by 2 ;# or this could be an error - or not
    }
    -result {10 8 6 4 2}
}

test range-1.3 {synergy between int and double} {
    -body {
	set rl [range 25. to 5. by 5]
	set il [range 25  to 5  by 5]
	lmap r $rl i $il { if {$r ne "" && $i ne ""} {expr {int($r) == $i}} else {list $r $i} }
    }
    -result {1 1 1 1 1}
}

test range-1.4 {integer decreasing} {
    -body {
	range 10 .. 1
    }
    -result {10 9 8 7 6 5 4 3 2 1}
}

test range-1.5 {integer increasing} {
    -body {
	range 1 .. 10
    }
    -result {1 2 3 4 5 6 7 8 9 10}
}

test range-1.6 {integer decreasing with step} {
    -body {
	range 10 .. 1 by -2
    }
    -result {10 8 6 4 2}
}

test range-1.7 {real increasing range} {
    -body {
	range 5.0 to 15.
    }
    -result {5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0}
}

test range-1.8 {real increasing range with step} {
    -body {
	range 5.0 to 25. by 5
    }
    -result {5.0 10.0 15.0 20.0 25.0}
}

test range-1.9 {real decreasing with step} {
    -body {
	range 25. to 5. by -5
    }
    -result {25.0 20.0 15.0 10.0 5.0}
}

# note, 10 cannot be in such a list, but allowed
test range-1.10 {integer range with step} {
    -body {
	range 1 to 10 by 2
    }
    -result {1 3 5 7 9}
}

test range-1.11 {error case: increasing wrong step direction} {
    -body {
	range 1 to 10 by -2
    }
    -result {1 3 5 7 9}
}

test range-1.12 {decreasing range with step} {
    -body {
	range 25. to -25. by -5
    }
    -result { 25.0 20.0 15.0 10.0 5.0 0.0 -5.0 -10.0 -15.0 -20.0 -25.0}
}

test range-1.13 {count operation} {
    -body {
	range 5 -count 5
    }
    -result {5 6 7 8 9}
}

test range-1.14 {count with step} {
    -body {
	range 5 -count 5 by 2
    }
    -result {5 7 9 11 13}
}

test range-1.15 {count with decreasing step} {
    -body {
	range 5 -count 5 by -2
    }
    -result {5 3 1 -1 -3}
}

test range-1.16 {large numbers} {
    -body {
	range [expr {int(1e6)}] [expr {int(2e6)}] [expr {int(1e5)}]
    }
    -result {1000000 1100000 1200000 1300000 1400000 1500000 1600000 1700000 1800000 1900000 2000000}
}

#
# Short-hand use cases
#
test range-2.2 {step magnitude} {
    -body {
	range 10 1 2 ;# or this could be an error - or not
    }
    -result {10 8 6 4 2}
}

test range-2.3 {step wrong sign} {
    -body {
	range 25. 5. 5 ;# ditto - maybe this is an error
    }
    -result {25.0 20.0 15.0 10.0 5.0}
}

test range-2.4 {integer decreasing} {
    -body {
	range 10 1
    }
    -result {10 9 8 7 6 5 4 3 2 1}
}

test range-2.5 {integer increasing} {
    -body {
	range 1 10
    }
    -result {1 2 3 4 5 6 7 8 9 10}
}

test range-2.6 {integer decreasing with step} {
    -body {
	range 10 1 by -2
    }
    -result {10 8 6 4 2}
}

test range-2.7 {real increasing range} {
    -body {
	range 5.0 15.
    }
    -result {5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0}
}

test range-2.8 {real increasing range with step} {
    -body {
	range 5.0 25. 5
    }
    -result {5.0 10.0 15.0 20.0 25.0}
}

test range-2.9 {real decreasing with step} {
    -body {
	range 25. 5. -5
    }
    -result {25.0 20.0 15.0 10.0 5.0}
}

# note, 10 cannot be in such a list, but allowed
test range-2.10 {integer range with step} {
    -body {
	range 1 10 2
    }
    -result {1 3 5 7 9}
}

test range-2.11 {error case: increasing wrong step direction} {
    -body {
	range 1 10 -2
    }
    -result {1 3 5 7 9}
}

test range-2.12 {decreasing range with step} {
    -body {
	range 25. -25. -5
    }
    -result { 25.0 20.0 15.0 10.0 5.0 0.0 -5.0 -10.0 -15.0 -20.0 -25.0}
}

test range-2.13 {count only operation} {
    -body {
	range 5 
    }
    -result {0 1 2 3 4}
}

test range-2.14 {count with step} {
    -body {
	range 5 -count 5 2
    }
    -result {5 7 9 11 13}
}

test range-2.15 {count with decreasing step} {
    -body {
	range 5 -count 5 -2
    }
    -result {5 3 1 -1 -3}
}

test range-2.16 {large numbers} {
    -body {
	range 1e6 2e6 1e5
    }
    -result {1000000.0 1100000.0 1200000.0 1300000.0 1400000.0 1500000.0 1600000.0 1700000.0 1800000.0 1900000.0 2000000.0}
}

test range-3.1 {experiement} {
    -body {
	set ans {}
	foreach factor [range 2.0 10.0] {
	    set start 1
	    set end 10
	    for {set step 1} {$step < 1e8} {} {
		set l [range $start to $end by $step]
		if {[llength $l] != ($step == 1 ? 10 : 11)} {
		    lappend ans $factor $step [llength $l] $l
		}
		set step [expr {$step * $factor}]
		set end [expr {$end * $factor}]
	    }
	}
	if {$ans eq {}} {
	    set ans OK
	}
	set ans
    }
    -result {OK}
}

test range-3.2 {error case} {
    -body {
	range foo
    }
    -returnCodes 1
    -result {bad start value: "foo"}
}

test range-3.3 {error case} {
    -body {
	range 10 foo
    }
    -returnCodes 1
    -result {bad end value: "foo"}
}

test range-3.4 {error case} {
    -body {
	range 25 or 6
    }
    -returnCodes 1
    -result {bad range operation "or": must be .., to, or -count}
}

test range-3.5 {error case} {
    -body {
	range 25 by 6
    }
    -returnCodes 1
    -result {bad range operation "by": must be .., to, or -count}
}

test range-3.6 {error case} {
    -body {
	range 1 7 or 3
    }
    -returnCodes 1
    -result {bad step keyword "or": must be by}
}
