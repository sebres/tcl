# Commands covered:  array
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2016 Andy Goth
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] < 0} {
    package require tcltest 2
    namespace import -force ::tcltest::test
}

::tcltest::loadTestedCommands
catch [list package require -exact Tcltest [info patchlevel]]

# Get list of variables and procs to facilitate cleanup later.
set vars [info vars]
set procs [info procs]

# commas --
# Joins a list by commas, the word "or", or both, using Oxford comma rules,
# matching Tcl's internal algorithm for displaying lists in error messages.
proc commas {list} {
    if {[llength $list] > 1} {
        lset list end "or [lindex $list end]"
    }
    if {[llength $list] < 3} {
        join $list " "
    } else {
        join $list ", "
    }
}

# [array] subcommand  arrayName             mode and filter
# ------------------  --------------------  ---------------
# anymore             array required        not allowed
# donesearch          array required        not allowed
# exists              anything              optional
# get                 anything              optional
# names               anything              optional
# nextelement         array required        not allowed
# set                 array or nonexistent  not allowed
# size                anything              optional
# startsearch         array required        optional
# statistics          array required        not allowed
# unset               anything              optional
# (unique abbrev)     (see above)           (see above)
# (ambiguous abbrev)  (error)               (error)
# (invalid)           (error)               (error)

# Possible arrayName arguments:
# - empty array
# - non-empty array
# - nonexistent
# - proc slot only
# - scalar variable
# - element of empty array
# - element of nonexistent array
# - element of proc-slot-only array
# - element of scalar variable
# - existing element of array
# - nonexistent element of array
# - bad namespace
# - array with array trace that causes error
# - array with array trace that does not cause error
# - (omitted)

# Possible mode and pattern arguments:
# - (no filter)
# - (default)
# - -exact
# - -glob
# - -regexp
# - -regexp (with invalid regexp pattern)

# Formal parameters for each command.
set params {
    anymore     {arrayName searchId}
    donesearch  {arrayName searchId}
    exists      {arrayName ?mode? ?pattern?}
    get         {arrayName ?mode? ?pattern?}
    names       {arrayName ?mode? ?pattern?}
    nextelement {arrayName searchId}
    set         {arrayName list}
    size        {arrayName ?mode? ?pattern?}
    startsearch {arrayName ?mode? ?pattern?}
    statistics  {arrayName}
    unset       {arrayName ?mode? ?pattern?}
}

# Produces a list of sample arguments, given a list of parameters.
proc samples {params} {
    lmap elem $params {dict get {
        arrayName   a
        searchId    s-1-a
        ?mode?      -exact
        ?pattern?   hello
        list        {hello world}
    } $elem}
}

# List of commands.
set commands [lsort [dict keys $params]]

# Ambiguous and unambiguous abbreviations.
foreach command $commands {
    for {set i 0} {$i < [string length $command] - 1} {incr i} {
        set abbrev [string range $command 0 $i]
        if {$abbrev in $commands
         || [llength [lsearch -all $commands $abbrev*]] == 1} {
            dict lappend abbrevs $command $abbrev
        } else {
            dict set ambig $abbrev {}
        }
    }
}
set ambig [lsort [dict keys $ambig]]
unset i command abbrev

# List of valid mode options.
set modes [lsort {-exact -glob -regexp}]

# array-1.*: subcommand dispatch
test array-1.1 {no subcommand} -body {
    list [catch array msg] $msg
} -result {1 {wrong # args: should be "array subcommand ?arg ...?"}}
test array-1.2 {empty subcommand} -body {
    list [catch {array {}} msg] $msg
} -result [list 1\
    "unknown or ambiguous subcommand \"\": must be [commas $commands]"]
test array-1.3 {invalid subcommand} -body {
    list [catch {array BAD&CMD} msg] $msg
} -result [list 1\
    "unknown or ambiguous subcommand \"BAD&CMD\": must be [commas $commands]"]
foreach cmd $ambig {
    test array-1.4 {ambiguous subcommand: \[array $cmd\]} -body {
        list [catch {array $cmd} msg] $msg
    } -result [list 1\
        "unknown or ambiguous subcommand \"$cmd\": must be [commas $commands]"]
}
foreach cmd $commands {
    test array-1.5.$cmd "formal parameter lists: \[array $cmd\]"\
    -body [list apply {{cmd} {
        list [catch {array $cmd} msg] $msg
    }} $cmd] -result [list 1\
        "wrong # args: should be \"array $cmd [dict get $params $cmd]\""]
}

# array-2.*: common argument parsing
foreach cmd $commands {
    test array-2.1.$cmd "too many arguments: \[array $cmd\]"\
    -body [list apply {{cmd params} {
        list [catch {array $cmd {*}$params extra} msg] $msg
    }} $cmd [dict get $params $cmd]] -result [list 1\
        "wrong # args: should be \"array $cmd [dict get $params $cmd]\""]
    if {"?mode?" in [dict get $params $cmd]} {
        test array-2.2.$cmd "ambiguous mode: \[array $cmd\]"\
        -body [list apply {{cmd} {
            array set a {}
            list [catch {array $cmd a {} {}} msg] $msg
        }} $cmd] -result [list 1\
            "ambiguous option \"\": must be [commas $modes]"]
        test array-2.3.$cmd "invalid mode: \[array $cmd\]"\
        -body [list apply {{cmd} {
            array set a {}
            list [catch {array $cmd a INVALID {}} msg] $msg
        }} $cmd] -result [list 1\
            "bad option \"INVALID\": must be [commas $modes]"]
        test array-2.4.$cmd "invalid regexp: \[array $cmd\]"\
        -body [list apply {{cmd} {
            array set a {e 1}
            list [catch {array $cmd a -regexp **} msg] $msg
        }} $cmd] -result [list 1 "couldn't compile regular expression pattern:\
            quantifier operand invalid"]
    }
    test array-2.5.$cmd "array trace error during variable lookup:\
    \[array $cmd\]" -body [list apply {{cmd params} {
        trace add variable a array {apply {{args} {error $args}}}
        set params [lmap elem $params {dict get {
            arrayName   a
            searchId    s-1-a
            ?mode?      -exact
            ?pattern?   hello
            list        {hello world}
        } $elem}]
        list [catch {array $cmd {*}$params} msg] $msg
    }} $cmd [dict get $params $cmd]] -result\
        {1 {can't trace array "a": a {} array}}
}
foreach cmd {anymore donesearch nextelement startsearch statistics} {
    ::tcltest::test array-2.6.$cmd {nonexistent array: \[array $cmd\]}\
    -body [list apply {{args} {
        list [catch $args msg] $msg
    }} array $cmd {*}[samples [dict get $params $cmd]]] -result\
        {1 {"a" isn't an array}}
}

# Cleanup.
foreach proc [info procs] {
    if {$proc ni $procs} {
        rename $proc {}
    }
}
foreach var [info vars] {
    if {$var ne "vars" && $var ni $vars} {
        unset $var
    }
}
unset -nocomplain var
::tcltest::cleanupTests
return

# vim: set sts=4 sw=4 tw=80 et ft=tcl:
# Local Variables:
# mode: tcl
# End:
