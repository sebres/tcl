# Commands covered:  array
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2016 Andy Goth
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] < 0} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

::tcltest::loadTestedCommands
catch [list package require -exact Tcltest [info patchlevel]]

# Get list of variables and procs to facilitate cleanup later.
set vars [info vars]
set procs [info procs]

# commaList --
# Joins a list by commas, the word "or", or both, using Oxford comma rules,
# matching Tcl's internal algorithm for displaying lists in error messages.
proc commaList {list} {
    if {[llength $list] > 1} {
	lset list end "or [lindex $list end]"
    }
    if {[llength $list] < 3} {
	join $list " "
    } else {
	join $list ", "
    }
}

# [array] subcommand  arrayName             mode and filter
# ------------------  --------------------  ---------------
# anymore             array required        not allowed
# donesearch          array required        not allowed
# exists              anything              optional
# get                 anything              optional
# names               anything              optional
# nextelement         array required        not allowed
# set                 array or nonexistent  not allowed
# size                anything              optional
# startsearch         array required        optional
# statistics          array required        not allowed
# unset               anything              optional
# (unique abbrev)     (see above)           (see above)
# (ambiguous abbrev)  (error)               (error)
# (invalid)           (error)               (error)

# Possible arrayName values:
# - empty array
# - non-empty array
# - nonexistent
# - proc slot only
# - scalar variable
# - element of empty array
# - element of nonexistent array
# - element of proc-slot-only array
# - element of scalar variable
# - existing element of array
# - nonexistent element of array
# - bad namespace
# - (omitted)

# Possible mode and pattern arguments:
# - (no filter)
# - (default)
# - -exact
# - -glob
# - -regexp
# - -regexp (with invalid regexp pattern)

# Formal parameters for each command.
set params {
    anymore	{arrayName searchId}
    donesearch	{arrayName searchId}
    exists	{arrayName ?mode? ?pattern?}
    get		{arrayName ?mode? ?pattern?}
    names	{arrayName ?mode? ?pattern?}
    nextelement	{arrayName searchId}
    set		{arrayName list}
    size	{arrayName ?mode? ?pattern?}
    startsearch	{arrayName ?mode? ?pattern?}
    statistics	{arrayName}
    unset	{arrayName ?mode? ?pattern?}
}

# List of commands.
set cmds [lsort [dict keys $params]]

# List of commands with interstitial commas.
set cmdDisplay [commaList $cmds]

# Ambiguous and unambiguous abbreviations.
foreach cmd $cmds {
    for {set i 0} {$i < [string length $cmd] - 1} {incr i} {
	set abbrev [string range $cmd 0 $i]
	if {$abbrev in $cmds || [llength [lsearch -all $cmds $abbrev*]] == 1} {
	    dict lappend abbrevs $cmd $abbrev
	} else {
	    dict set ambig $abbrev {}
	}
    }
}
set ambig [lsort [dict keys $ambig]]
unset i cmd abbrev


# array-1.*: subcommand dispatch
test array-1.1 {no subcommand} -body {
    list [catch array msg] $msg
} -result {1 {wrong # args: should be "array subcommand ?arg ...?"}}
test array-1.2 {invalid subcommand} -body {
    list [catch {array {}} msg] $msg
} -result [list 1\
    "unknown or ambiguous subcommand \"\": must be $cmdDisplay"]
test array-1.3 {ambiguous subcommands} -body {
    lmap i $ambig {
	list [catch {array $i} msg] $msg
    }
} -result [lmap i $ambig {
    list 1 "unknown or ambiguous subcommand \"$i\": must be $cmdDisplay"
}]
foreach i $cmds {
    test array-1.4.$i "formal parameter lists: \[array $i\]"\
    -setup [list set i $i] -body {
	list [catch {array $i} msg] $msg
    } -result [list 1\
	"wrong # args: should be \"array $i [dict get $params $i]\""]
}

# array-2.*: common argument parsing

# Cleanup
foreach proc [info procs] {
    if {$proc ni $procs} {
	rename $proc {}
    }
}
foreach var [info vars] {
    if {$var ne "vars" && $var ni $vars} {
	unset $var
    }
}
unset -nocomplain var
::tcltest::cleanupTests
return

# vim: set sts=4 sw=4 noet tw=80 ft=tcl:
# Local Variables:
# mode: tcl
# End:
